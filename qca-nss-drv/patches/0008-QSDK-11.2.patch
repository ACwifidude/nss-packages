--- a/Makefile
+++ b/Makefile
@@ -26,6 +26,7 @@ qca-nss-drv-objs := \
 			nss_eth_rx_strings.o \
 			nss_gmac_stats.o \
 			nss_if.o \
+			nss_if_log.o \
 			nss_init.o \
 			nss_ipv4.o \
 			nss_ipv4_stats.o \
@@ -93,10 +94,9 @@ qca-nss-drv-objs := \
 			nss_wifi_mac_db.o
 
 # Base NSS data plane/HAL support
-qca-nss-drv-objs += nss_data_plane/nss_data_plane.o
+qca-nss-drv-objs += nss_data_plane/nss_data_plane_common.o
 qca-nss-drv-objs += nss_hal/nss_hal.o
 
-
 ifneq "$(NSS_DRV_L2TP_ENABLE)" "n"
 ccflags-y += -DNSS_DRV_L2TP_ENABLE
 qca-nss-drv-objs += \
@@ -317,7 +317,7 @@ ccflags-y += -I$(obj)/nss_hal/ipq806x -D
 endif
 
 ifeq ($(SoC),$(filter $(SoC),ipq60xx ipq60xx_64 ipq807x ipq807x_64))
-qca-nss-drv-objs += nss_data_plane/nss_data_plane_edma.o
+qca-nss-drv-objs += nss_data_plane/nss_data_plane.o
 
 ifneq "$(NSS_DRV_IPSEC_ENABLE)" "n"
 ccflags-y += -DNSS_DRV_IPSEC_ENABLE
@@ -328,9 +328,15 @@ endif
 
 ifneq "$(NSS_DRV_CRYPTO_ENABLE)" "n"
 ccflags-y += -DNSS_DRV_CRYPTO_ENABLE
+ccflags-y += -DNSS_DRV_DMA_ENABLE
+
 qca-nss-drv-objs += \
 		    nss_crypto_cmn.o \
-		    nss_crypto_cmn_log.o
+		    nss_crypto_cmn_log.o \
+		    nss_dma.o \
+		    nss_dma_log.o \
+		    nss_dma_stats.o \
+		    nss_dma_strings.o
 endif
 
 ifneq "$(NSS_DRV_DTLS_ENABLE)" "n"
@@ -356,18 +362,21 @@ endif
 endif
 
 ifeq ($(SoC),$(filter $(SoC),ipq807x ipq807x_64))
-qca-nss-drv-objs += nss_hal/ipq807x/nss_hal_pvt.o
+qca-nss-drv-objs += nss_hal/ipq807x/nss_hal_pvt.o \
+		    nss_data_plane/hal/nss_ipq807x.o
 ccflags-y += -I$(obj)/nss_hal/ipq807x -DNSS_HAL_IPQ807x_SUPPORT -DNSS_MULTI_H2N_DATA_RING_SUPPORT
 endif
 
 ifeq ($(SoC),$(filter $(SoC),ipq60xx ipq60xx_64))
-qca-nss-drv-objs += nss_hal/ipq60xx/nss_hal_pvt.o
+qca-nss-drv-objs += nss_hal/ipq60xx/nss_hal_pvt.o \
+		    nss_data_plane/hal/nss_ipq60xx.o
 ccflags-y += -I$(obj)/nss_hal/ipq60xx -DNSS_HAL_IPQ60XX_SUPPORT -DNSS_MULTI_H2N_DATA_RING_SUPPORT
 endif
 
 ifeq ($(SoC),$(filter $(SoC),ipq50xx ipq50xx_64))
-qca-nss-drv-objs += nss_data_plane/nss_data_plane_edma.o \
-			nss_hal/ipq50xx/nss_hal_pvt.o
+qca-nss-drv-objs += nss_data_plane/nss_data_plane.o \
+		    nss_hal/ipq50xx/nss_hal_pvt.o \
+		    nss_data_plane/hal/nss_ipq50xx.o
 
 ifneq "$(NSS_DRV_IPSEC_ENABLE)" "n"
 ccflags-y += -DNSS_DRV_IPSEC_ENABLE
@@ -393,10 +402,12 @@ ccflags-y += -I$(obj)/nss_hal/ipq50xx -D
 endif
 
 ccflags-y += -I$(obj)/nss_hal/include -I$(obj)/nss_data_plane/include -I$(obj)/exports -DNSS_DEBUG_LEVEL=0 -DNSS_PKT_STATS_ENABLED=1
-
+ccflags-y += -I$(obj)/nss_data_plane/hal/include
 ccflags-y += -DNSS_PM_DEBUG_LEVEL=0 -DNSS_SKB_REUSE_SUPPORT=1
 ccflags-y += -Werror
 
+KERNELVERSION := $(word 1, $(subst ., ,$(KERNELVERSION))).$(word 2, $(subst ., ,$(KERNELVERSION)))
+
 ifneq ($(findstring 3.4, $(KERNELVERSION)),)
 NSS_CCFLAGS = -DNSS_DT_SUPPORT=0 -DNSS_FW_DBG_SUPPORT=1 -DNSS_PM_SUPPORT=1
 else
--- a/Makefile.fsm
+++ b/Makefile.fsm
@@ -36,6 +36,7 @@ qca-nss-drv-objs := \
 			nss_gre_tunnel_log.o \
 			nss_gre_tunnel_stats.o \
 			nss_if.o \
+                        nss_if_log.o \
 			nss_init.o \
 			nss_ipsec.o \
 			nss_ipsec_log.o \
@@ -110,7 +111,7 @@ qca-nss-drv-objs := \
 
 qca-nss-drv-objs += nss_hal/nss_hal.o
 qca-nss-drv-objs += nss_hal/fsm9010/nss_hal_pvt.o
-qca-nss-drv-objs += nss_data_plane/nss_data_plane.o
+qca-nss-drv-objs += nss_data_plane/nss_data_plane_common.o
 qca-nss-drv-objs += nss_data_plane/nss_data_plane_gmac.o
 
 ccflags-y += -I$(obj)/nss_hal/include
--- a/exports/nss_api_if.h
+++ b/exports/nss_api_if.h
@@ -44,10 +44,12 @@
 #include "nss_ipv6.h"
 #include "nss_shaper.h"
 #include "nss_if.h"
+#include "nss_phy_if.h"
 #include "nss_virt_if.h"
 #include "nss_pppoe.h"
 #include "nss_crypto.h"
 #include "nss_crypto_cmn.h"
+#include "nss_dma.h"
 
 #include "nss_profiler.h"
 #include "nss_dynamic_interface.h"
@@ -117,7 +119,7 @@
 #define NSS_MAX_PHYSICAL_INTERFACES 8	/**< Maximum number of physical interfaces. */
 #define NSS_MAX_VIRTUAL_INTERFACES 16	/**< Maximum number of virtual interfaces. */
 #define NSS_MAX_TUNNEL_INTERFACES 4	/**< Maximum number of tunnel interfaces. */
-#define NSS_MAX_SPECIAL_INTERFACES 66	/**< Maximum number of special interfaces. */
+#define NSS_MAX_SPECIAL_INTERFACES 67	/**< Maximum number of special interfaces. */
 #define NSS_MAX_WIFI_RADIO_INTERFACES 3	/**< Maximum number of radio interfaces. */
 
 /*
@@ -262,9 +264,12 @@
 #define NSS_TLS_INTERFACE (NSS_SPECIAL_IF_START + 61)
 		/**< Special interface number for TLS. */
 #define NSS_PPE_VP_INTERFACE (NSS_SPECIAL_IF_START + 62)
-		/**< Special interface number for the virtual port interface. */
+		/**< Special interface number for the virtual port (62, 63, 64) interface. */
 #define NSS_WIFI_MAC_DB_INTERFACE (NSS_SPECIAL_IF_START + 65)
 		/**< Special interface number for the Wi-Fi MAC database. */
+#define NSS_DMA_INTERFACE (NSS_SPECIAL_IF_START + 66)
+		/**< Special interface number for the DMA interface. */
+
 
 #ifdef __KERNEL__ /* only kernel will use. */
 
--- a/exports/nss_bridge.h
+++ b/exports/nss_bridge.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2016-2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016-2018,2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -338,8 +338,8 @@ nss_tx_status_t nss_bridge_tx_vsi_unassi
  * @datatypes
  * nss_bridge_fdb_learn_mode
  *
- * @param[in] if_num     Interface number of the bridge.
- * @param[in] fdb_learn  FDB learning disable/enable.
+ * @param[in] bridge_if_num  Interface number of the bridge.
+ * @param[in] fdb_learn      FDB learning disable/enable.
  *
  * @return
  * Status of the Tx operation.
--- a/exports/nss_clmap.h
+++ b/exports/nss_clmap.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -22,6 +22,11 @@
 #ifndef __NSS_CLMAP_H
 #define __NSS_CLMAP_H
 
+ /**
+  * @addtogroup nss_clmap_subsystem
+  * @{
+  */
+
 /**
  * Maximum number of supported client map interface.
  */
@@ -87,7 +92,7 @@ struct nss_clmap_stats_msg {
 
 /**
  * nss_clmap_mac_msg
- *	CLient map MAC message structure.
+ *	Client map MAC message structure.
  */
 struct nss_clmap_mac_msg {
 	uint32_t vlan_id;			/**< VLAN ID. */
@@ -200,7 +205,7 @@ extern nss_tx_status_t nss_clmap_tx_msg_
  * sk_buff
  *
  * @param[in] nss_ctx  Pointer to the NSS context.
- * @param[in] os_buf   Pointer to the data buffer.
+ * @param[in] buf   Pointer to the data buffer.
  * @param[in] if_num   NSS interface number.
  *
  * @return
--- /dev/null
+++ b/exports/nss_dma.h
@@ -0,0 +1,264 @@
+/*
+ **************************************************************************
+ * Copyright (c) 2020, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for
+ * any purpose with or without fee is hereby granted, provided that the
+ * above copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ **************************************************************************
+ */
+/**
+ * @file nss_dma.h
+ *	NSS DMA for linearization and split interface definitions.
+ */
+
+#ifndef __NSS_DMA_H
+#define __NSS_DMA_H
+
+/**
+ * @addtogroup nss_dma_subsystem
+ * @{
+ */
+
+/**
+ * nss_dma_msg_type
+ *	Supported message types.
+ */
+enum nss_dma_msg_type {
+	NSS_DMA_MSG_TYPE_NONE,			/**< Invalid message type. */
+	NSS_DMA_MSG_TYPE_CONFIGURE,		/**< Configure DMA. */
+	NSS_DMA_MSG_TYPE_SYNC_STATS,		/**< Statistics synchronization. */
+	NSS_DMA_MSG_TYPE_TEST_PERF,		/**< Performance test. */
+	NSS_DMA_MSG_TYPE_MAX			/**< Maximum message type. */
+};
+
+/**
+ * nss_dma_msg_error
+ *	Message error types.
+ */
+enum nss_dma_msg_error {
+	NSS_DMA_MSG_ERROR_NONE,			/**< No error. */
+	NSS_DMA_MSG_ERROR_HW_INIT,		/**< Invalid operation. */
+	NSS_DMA_MSG_ERROR_UNHANDLED,		/**< Invalid test ID. */
+	NSS_DMA_MSG_ERROR_TEST,			/**< Performance test failed. */
+	NSS_DMA_MSG_ERROR_MAX			/**< Maximum error type. */
+};
+
+/**
+ * nss_dma_test_type
+ *	DMA Test types.
+ */
+enum nss_dma_test_type {
+	NSS_DMA_TEST_TYPE_DEFAULT = 0,		/**< Test default segment size. */
+	NSS_DMA_TEST_TYPE_SWEEP,		/**< Test sweep segment size. */
+	NSS_DMA_TEST_TYPE_LARGE,		/**< Test large segment size. */
+	NSS_DMA_TEST_TYPE_VERIFY,		/**< Verify contents at receive processing. */
+	NSS_DMA_TEST_TYPE_MAX			/**< Maximum test type. */
+};
+
+#ifdef __KERNEL__ /* only kernel will use. */
+/*
+ * Maximum number of HW specific statistics
+ */
+#define NSS_DMA_HW_ERROR_MAX 16
+
+/*
+ * Test configuration flags
+ */
+#define NSS_DMA_TEST_FLAGS_LINEARIZE 0x01	/**< Linearize test. */
+#define NSS_DMA_TEST_FLAGS_SPLIT 0x02		/**< Split test. */
+
+/**
+ * nss_dma_test_cfg
+ *	Test configuration.
+ */
+struct nss_dma_test_cfg {
+	struct nss_cmn_node_stats node_stats;	/**< Common node statistics for DMA interface. */
+	uint32_t flags;				/**< Test configuration flags. */
+	uint32_t time_delta;			/**< Difference between start and end. */
+	uint16_t packet_count;			/**< Number of packets to send. */
+	uint16_t type;				/**< Type of test to run. */
+};
+
+/**
+ * nss_dma_stats
+ *	DMA statistics.
+ */
+struct nss_dma_stats {
+	struct nss_cmn_node_stats node_stats;	/**< Common node statistics for DMA interface. */
+	uint32_t no_req;			/**< Request descriptor not available. */
+	uint32_t no_desc;			/**< DMA descriptors not available. */
+	uint32_t fail_nexthop;			/**< Failed to retrive next hop. */
+	uint32_t fail_nexthop_queue;		/**< Failed to queue next hop. */
+	uint32_t fail_linear_sz;		/**< Failed to get memory for linearization. */
+	uint32_t fail_linear_alloc;		/**< Failed to allocate buffer for linearization. */
+	uint32_t fail_linear_no_sg;		/**< Skip linearization due to non-SG packet. */
+	uint32_t fail_split_sz;			/**< Failed to spliting buffer into multiple buffers. */
+	uint32_t fail_split_alloc;		/**< Failed to allocate buffer for split. */
+	uint32_t fail_sync_alloc;		/**< Failed to allocate buffer for sending statistics. */
+	uint32_t fail_ctx_active;		/**< Failed to queue as the node is not active. */
+	uint32_t fail_hw[NSS_DMA_HW_ERROR_MAX]; /**< Hardware failures. */
+};
+
+/**
+ * nss_dma_msg
+ *	Message structure for configuring the DMA interface.
+ */
+struct nss_dma_msg {
+	struct nss_cmn_msg cm;			/**< Common message header. */
+
+	/**
+	 * Payload of a NSS core-to-core transmission rule or statistics message.
+	 */
+	union {
+		struct nss_dma_test_cfg test_cfg;
+						/**< DMA test configuration. */
+		struct nss_dma_stats stats;	/**< DMA interface statistics. */
+	} msg;					/**< Message payload. */
+};
+
+/**
+ * nss_dma_register_handler
+ *	Registers the DMA message handler.
+ *
+ * @datatypes
+ * nss_ctx_instance
+ *
+ * @param[in] nss_ctx  Pointer to the NSS context.
+ *
+ * @return
+ * None.
+ */
+void nss_dma_register_handler(void);
+
+/**
+ * Callback function for receiving DMA messages.
+ *
+ * @datatypes
+ * nss_c2c_tx_msg
+ *
+ * @param[in] app_data  Pointer to the application context of the message.
+ * @param[in] msg       Pointer to the message data.
+ */
+typedef void (*nss_dma_msg_callback_t)(void *app_data, struct nss_cmn_msg *msg);
+
+/**
+ * nss_dma_tx_msg
+ *	Transmits a DMA message to the NSS.
+ *
+ * @datatypes
+ * nss_ctx_instance \n
+ * nss_dma_msg
+ *
+ * @param[in] nss_ctx   Pointer to the NSS context.
+ * @param[in] ndm      Pointer to the message data.
+ *
+ * @return
+ * Status of the transmit operation.
+ */
+extern nss_tx_status_t nss_dma_tx_msg(struct nss_ctx_instance *nss_ctx, struct nss_dma_msg *ndm);
+
+/**
+ * nss_dma_msg_init
+ *	Initializes DMA messages.
+ *
+ * @datatypes
+ * nss_dma_msg \n
+ * nss_dma_msg_callback_t
+ *
+ * @param[in]     ndm       Pointer to the NSS interface message.
+ * @param[in]     if_num    NSS interface number.
+ * @param[in]     type      Type of message.
+ * @param[in]     len       Size of the payload.
+ * @param[in]     cb        Callback function for the message.
+ * @param[in]     app_data  Pointer to the application context of the message.
+ *
+ * @return
+ * None.
+ */
+extern void nss_dma_msg_init(struct nss_dma_msg *ndm, uint16_t if_num, uint32_t type, uint32_t len,
+			nss_dma_msg_callback_t cb, void *app_data);
+
+/**
+ * nss_dma_notify_register
+ *	Registers a notifier callback for DMA messages with the NSS.
+ *
+ * @datatypes
+ * nss_dma_msg_callback_t
+ *
+ * @param[in] core      NSS core number index to the notifier callback table.
+ * @param[in] cb        Callback function for the message.
+ * @param[in] app_data  Pointer to the application context of the message.
+ *
+ * @return
+ * Pointer to the NSS core context.
+ */
+struct nss_ctx_instance *nss_dma_notify_register(int core, nss_dma_msg_callback_t cb, void *app_data);
+
+/**
+ * nss_dma_notify_unregister
+ *	Deregisters a DMA message notifier callback from the NSS.
+ *
+ * @param[in] core  NSS core number index to the notifier callback table.
+ *
+ * @return
+ * None.
+ *
+ * @dependencies
+ * The notifier callback must have been previously registered.
+ */
+void nss_dma_notify_unregister(int core);
+
+/**
+ * nss_dma_register_sysctl
+ *     Registers the DMA interface to Linux system control tree.
+ *
+ * @return
+ * None.
+ */
+extern void nss_dma_register_sysctl(void);
+
+/**
+ * nss_dma_unregister_sysctl
+ *     Deregisters the DMA interface from Linux system control tree.
+ *
+ * @return
+ * None.
+ *
+ * @dependencies
+ * The system control must have been previously registered.
+ */
+extern void nss_dma_unregister_sysctl(void);
+
+/**
+ * nss_dma_init
+ *	Initializes the DMA interface.
+ *
+ * @return
+ * None.
+ */
+void nss_dma_init(void);
+
+/**
+ * nss_dma_get_context
+ *	Get the per NSS core context enabled for DMA.
+ *
+ * @return
+ * Pointer to the NSS core context.
+ */
+extern struct nss_ctx_instance *nss_dma_get_context(void);
+#endif /*__KERNEL__ */
+
+/**
+ * @}
+ */
+
+#endif /* __NSS_C2C_TX_H */
--- a/exports/nss_dtls_cmn.h
+++ b/exports/nss_dtls_cmn.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -31,8 +31,10 @@
 #define NSS_DTLS_CMN_CTX_HDR_UDPLITE 0x0002		/**< DTLS with UDPLite. */
 #define NSS_DTLS_CMN_CTX_HDR_CAPWAP 0x0004		/**< DTLS with CAPWAP. */
 #define NSS_DTLS_CMN_CTX_CIPHER_MODE_GCM 0x0008		/**< DTLS with GCM cipher mode. */
-#define NSS_DTLS_CMN_CTX_OUTER_UDPLITE_CSUM 0x10000	/**< Checksum only UDPLite header. */
-#define NSS_DTLS_CMN_CTX_INNER_ACCEPT_ALL 0x20000
+#define NSS_DTLS_CMN_CTX_ENCAP_UDPLITE_CSUM 0x10000	/**< Checksum only UDPLite header. */
+#define NSS_DTLS_CMN_CTX_ENCAP_METADATA 0x20000		/**< Valid metadata in encapsulation direction. */
+#define NSS_DTLS_CMN_CTX_DECAP_ACCEPT_ALL 0x40000	/**< Exception all error packets to host. */
+
 #define NSS_DTLS_CMN_CLE_MAX 32				/**< Max classification error. */
 
 /**
--- a/exports/nss_gre_tunnel.h
+++ b/exports/nss_gre_tunnel.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2016-2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016-2018,2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -104,7 +104,7 @@ enum nss_gre_tunnel_error_types {
 struct nss_gre_tunnel_di_to_wlan_id {
 	uint32_t dynamic_interface_num;		/**< Dynamic interface number. */
 	uint16_t wlan_id;			/**< WLAN ID number. */
-	uint16_t reserved0;			/**< Reserved padding. */
+	uint16_t fwd_policy;                    /**< Forward policy bits. */
 };
 
 /**
--- a/exports/nss_if.h
+++ b/exports/nss_if.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -22,6 +22,8 @@
 #ifndef __NSS_IF_H
 #define __NSS_IF_H
 
+#define NSS_IF_TX_TIMEOUT 3000 /* 3 Seconds */
+
 /**
  * @addtogroup nss_driver_subsystem
  * @{
@@ -323,20 +325,51 @@ extern nss_tx_status_t nss_if_tx_buf(str
 nss_tx_status_t nss_if_tx_msg(struct nss_ctx_instance *nss_ctx, struct nss_if_msg *nim);
 
 /**
- * nss_phys_if_set_nexthop
- *	Configure nexthop for an interface.
+ * nss_if_msg_sync
+ *	Sends a message to the NSS interface and wait for the response.
+ *
+ * @datatypes
+ * nss_ctx_instance \n
+ * nss_if_msg
+ *
+ * @param[in,out] nss_ctx  Pointer to the NSS context.
+ * @param[in]     nim      Pointer to the NSS interface message.
+ *
+ * @return
+ * Status of the Tx operation.
+ */
+nss_tx_status_t nss_if_msg_sync(struct nss_ctx_instance *nss_ctx, struct nss_if_msg *nim);
+
+/**
+ * nss_if_set_nexthop
+ *	Configure the next hop for an interface.
  *
  * @datatypes
  * nss_ctx_instance
  *
  * @param[in] nss_ctx  Pointer to the NSS context.
- * @param[in] if_num   Network physical or virtual interface number.
- * @param[in] nexthop   Network physical or virtual interface number.
+ * @param[in] if_num   NSS interface number.
+ * @param[in] nexthop  NSS interface number for next hop node.
+ *
+ * @return
+ * Status of the Tx operation.
+ */
+nss_tx_status_t nss_if_set_nexthop(struct nss_ctx_instance *nss_ctx, uint32_t if_num, uint32_t nexthop);
+
+/**
+ * nss_if_reset_nexthop
+ *	De-configure the next hop for an interface.
+ *
+ * @datatypes
+ * nss_ctx_instance
+ *
+ * @param[in] nss_ctx  Pointer to the NSS context.
+ * @param[in] if_num   NSS interface number.
  *
  * @return
  * Status of the Tx operation.
  */
-nss_tx_status_t nss_phys_if_set_nexthop(struct nss_ctx_instance *nss_ctx, uint32_t if_num, uint32_t nexthop);
+nss_tx_status_t nss_if_reset_nexthop(struct nss_ctx_instance *nss_ctx, uint32_t if_num);
 
 /**
  * @}
--- a/exports/nss_ipsec_cmn.h
+++ b/exports/nss_ipsec_cmn.h
@@ -23,7 +23,7 @@
 #define __NSS_IPSEC_CMN_H_
 
 /**
- * @addtogroup nss_nss_ipsec_subsystem
+ * @addtogroup nss_ipsec_subsystem
  * @{
  */
 
--- a/exports/nss_l2tpv2.h
+++ b/exports/nss_l2tpv2.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2015,2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2015, 2017-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -103,7 +103,7 @@ struct nss_l2tpv2_session_destroy_msg {
 
 /**
  * nss_l2tpv2_bind_ipsec_if_msg
- *	Message for binding IPsec interface with L2TP.
+ *	Message for binding the IPsec interface with L2TP.
  *
  * Message for configuring the L2TP session with an
  * IPsec inner interface number. This is used when
@@ -139,7 +139,7 @@ struct nss_l2tpv2_sync_session_stats_msg
 		uint32_t decap_pbuf_alloc_fail;
 				/**< Buffer allocation failure during decapsulation. */
 		uint32_t decap_l2tpoipsec_src_error;
-				/**< Packets dropped due to wrong source for L2TPoIPsec flow. */
+				/**< Packets dropped due to the wrong source for the L2TPoIPsec flow. */
 	} debug_stats;	/**< Debug statistics object for l2tp v2. */
 };
 
--- /dev/null
+++ b/exports/nss_phy_if.h
@@ -0,0 +1,67 @@
+/*
+ **************************************************************************
+ * Copyright (c) 2020, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for
+ * any purpose with or without fee is hereby granted, provided that the
+ * above copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ **************************************************************************
+ */
+
+/**
+ * @file nss_phy_if.h.h
+ *	NSS physical interface definitions.
+ */
+
+#ifndef __NSS_PHY_IF_H
+#define __NSS_PHY_IF_H
+
+/**
+ * @addtogroup nss_driver_subsystem
+ * @{
+ */
+
+/**
+ * nss_phys_if_reset_nexthop
+ *	De-configure nexthop for an interface.
+ *
+ * @datatypes
+ * nss_ctx_instance
+ *
+ * @param[in] nss_ctx  Pointer to the NSS context.
+ * @param[in] if_num   Network physical interface number.
+ *
+ * @return
+ * Status of the Tx operation.
+ */
+nss_tx_status_t nss_phys_if_reset_nexthop(struct nss_ctx_instance *nss_ctx, uint32_t if_num);
+
+/**
+ * nss_phys_if_set_nexthop
+ *	Configure nexthop for an interface.
+ *
+ * @datatypes
+ * nss_ctx_instance
+ *
+ * @param[in] nss_ctx  Pointer to the NSS context.
+ * @param[in] if_num   Network physical interface number.
+ * @param[in] nexthop   Network physical or virtual interface number.
+ *
+ * @return
+ * Status of the Tx operation.
+ */
+nss_tx_status_t nss_phys_if_set_nexthop(struct nss_ctx_instance *nss_ctx, uint32_t if_num, uint32_t nexthop);
+
+/**
+ * @}
+ */
+
+#endif /*  __NSS_PHY_IF_H */
--- a/exports/nss_pvxlan.h
+++ b/exports/nss_pvxlan.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -270,7 +270,7 @@ extern nss_tx_status_t nss_pvxlan_tx_msg
  * sk_buff
  *
  * @param[in] nss_ctx  Pointer to the NSS context.
- * @param[in] os_buf   Pointer to the data buffer.
+ * @param[in] buf   Pointer to the data buffer.
  * @param[in] if_num   NSS interface number.
  *
  * @return
--- a/exports/nss_rmnet_rx.h
+++ b/exports/nss_rmnet_rx.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -27,7 +27,7 @@
 #include "nss_if.h"
 
 /**
- * @addtogroup nss_virtual_if_subsystem
+ * @addtogroup nss_rmnet_subsystem
  * @{
  */
 
--- a/exports/nss_trustsec_tx.h
+++ b/exports/nss_trustsec_tx.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2016-2017, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016-2017, 2020 The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -32,10 +32,11 @@
  *	Message types for TrustSec Tx requests and responses.
  */
 enum nss_trustsec_tx_msg_types {
-	NSS_TRUSTSEC_TX_CONFIGURE_MSG,
-	NSS_TRUSTSEC_TX_UNCONFIGURE_MSG,
-	NSS_TRUSTSEC_TX_STATS_SYNC_MSG,
-	NSS_TRUSTSEC_TX_MAX_MSG_TYPE
+	NSS_TRUSTSEC_TX_MSG_CONFIGURE,		/** Configure the TrustSec node. */
+	NSS_TRUSTSEC_TX_MSG_UNCONFIGURE,	/** Unconfigure the TrustSec node. */
+	NSS_TRUSTSEC_TX_MSG_STATS_SYNC,		/** Statistics sychronization. */
+	NSS_TRUSTSEC_TX_MSG_UPDATE_NEXTHOP,	/** Update next hop. */
+	NSS_TRUSTSEC_TX_MSG_MAX			/** Maximum message type. */
 };
 
 /**
@@ -43,11 +44,14 @@ enum nss_trustsec_tx_msg_types {
  *	Error types for the TrustSec Tx interface.
  */
 enum nss_trustsec_tx_error_types {
-	NSS_TRUSTSEC_TX_ERR_INVAL_SRC_IF,
-	NSS_TRUSTSEC_TX_ERR_RECONFIGURE_SRC_IF,
-	NSS_TRUSTSEC_TX_ERR_DEST_IF_NOT_FOUND,
-	NSS_TRUSTSEC_TX_ERR_NOT_CONFIGURED,
-	NSS_TRUSTSEC_TX_ERR_UNKNOWN,
+	NSS_TRUSTSEC_TX_ERR_NONE,		/** No error */
+	NSS_TRUSTSEC_TX_ERR_INVAL_SRC_IF,	/** Source interface is invalid. */
+	NSS_TRUSTSEC_TX_ERR_RECONFIGURE_SRC_IF,	/** Source interface is already configured. */
+	NSS_TRUSTSEC_TX_ERR_DEST_IF_NOT_FOUND,	/** Destination interface is not found. */
+	NSS_TRUSTSEC_TX_ERR_NOT_CONFIGURED,	/** Source interface is not configured. */
+	NSS_TRUSTSEC_TX_ERR_SGT_MISMATCH,	/** SGT mismatches. */
+	NSS_TRUSTSEC_TX_ERR_UNKNOWN,		/** Error is unknown. */
+	NSS_TRUSTSEC_TX_ERR_MAX,		/** Maximum error message. */
 };
 
 /**
@@ -83,6 +87,17 @@ struct nss_trustsec_tx_stats_sync_msg {
 };
 
 /**
+ * nss_trustsec_tx_update_nexthop_msg
+ *	Message information for updating the next hop for a TrustSec Tx interface.
+ */
+struct nss_trustsec_tx_update_nexthop_msg {
+	uint32_t src;	/**< Interface number of the source tunnel. */
+	uint32_t dest;	/**< Outgoing interface number. */
+	uint16_t sgt;	/**< Security Group Tag value to embed in the TrustSec header. */
+	uint8_t reserved[2];	/**< Reserved for word alignment. */
+};
+
+/**
  * nss_trustsec_tx_msg
  *	Data for sending and receiving TrustSec Tx messages.
  */
@@ -99,6 +114,8 @@ struct nss_trustsec_tx_msg {
 				/**< De-configure TrustSec Tx. */
 		struct nss_trustsec_tx_stats_sync_msg stats_sync;
 				/**< Synchronize TrustSec Tx statistics. */
+		struct nss_trustsec_tx_update_nexthop_msg upd_nexthop;
+				/**< Update next hop of TrustSec Tx. */
 	} msg;			/**< Message payload. */
 };
 
@@ -166,6 +183,19 @@ extern nss_tx_status_t nss_trustsec_tx_m
 extern nss_tx_status_t nss_trustsec_tx_msg_sync(struct nss_ctx_instance *nss_ctx, struct nss_trustsec_tx_msg *msg);
 
 /**
+ * nss_trustsec_tx_update_nexthop
+ *	Updates the next hop of the TrustSec.
+ *
+ * @param[in] src   Source interface number.
+ * @param[in] dest  Destination interface number.
+ * @param[in] sgt   Security Group Tag value.
+ *
+ * @return
+ * Pointer to the NSS core context.
+ */
+extern nss_tx_status_t nss_trustsec_tx_update_nexthop(uint32_t src, uint32_t dest, uint16_t sgt);
+
+/**
  * nss_trustsec_tx_get_ctx
  *	Gets the NSS context.
  *
@@ -180,7 +210,7 @@ extern struct nss_ctx_instance *nss_trus
  *
  * @param[in] src   Source interface number.
  * @param[in] dest  Destination interface number.
- * @param[in] sgt   Security Group Tag value
+ * @param[in] sgt   Security Group Tag value.
  *
  * @return
  * Pointer to the NSS core context.
--- a/exports/nss_tunipip6.h
+++ b/exports/nss_tunipip6.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014, 2017-2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014, 2017-2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -30,16 +30,18 @@
 #define NSS_TUNIPIP6_MAX_FMR_NUMBER 4	/**< Maximum number of forward mapping rule (FMR). */
 
 /**
- * nss_tunipip6_fmr
- *	Forward mapping rule (FMR) for direct forwarding traffic to the node in the same domain.
+ * nss_tunipip6_map_rule
+ *	Mapping rule (FMR/BMR) for forwarding traffic to the node in the same domain.
  */
-struct nss_tunipip6_fmr {
+struct nss_tunipip6_map_rule {
 	uint32_t ip6_prefix[4];		/**< An IPv6 prefix assigned by a mapping rule. */
 	uint32_t ip4_prefix;		/**< An IPv4 prefix assigned by a mapping rule. */
 	uint32_t ip6_prefix_len;	/**< IPv6 prefix length. */
 	uint32_t ip4_prefix_len;	/**< IPv4 prefix length. */
+	uint32_t ip6_suffix[4];		/**< IPv6 suffix. */
+	uint32_t ip6_suffix_len;	/**< IPv6 suffix length. */
 	uint32_t ea_len;		/**< Embedded Address (EA) bits. */
-	uint32_t offset;		/**< PSID offset default 6. */
+	uint32_t psid_offset;		/**< PSID offset default 6. */
 };
 
 /**
@@ -50,6 +52,11 @@ enum nss_tunipip6_metadata_types {
 	NSS_TUNIPIP6_TX_ENCAP_IF_CREATE,
 	NSS_TUNIPIP6_TX_DECAP_IF_CREATE,
 	NSS_TUNIPIP6_RX_STATS_SYNC,
+	NSS_TUNIPIP6_FMR_RULE_ADD,
+	NSS_TUNIPIP6_FMR_RULE_DEL,
+	NSS_TUNIPIP6_FMR_RULE_FLUSH,
+	NSS_TUNIPIP6_BMR_RULE_ADD,
+	NSS_TUNIPIP6_BMR_RULE_DEL,
 	NSS_TUNIPIP6_MAX,
 };
 
@@ -58,16 +65,16 @@ enum nss_tunipip6_metadata_types {
  *	Payload for configuring the DS-Lite interface.
  */
 struct nss_tunipip6_create_msg {
-	struct nss_tunipip6_fmr fmr[NSS_TUNIPIP6_MAX_FMR_NUMBER];	/**< Tunnel FMR array. */
 	uint32_t saddr[4];						/**< Tunnel source address. */
 	uint32_t daddr[4];						/**< Tunnel destination address. */
 	uint32_t flowlabel;						/**< Tunnel IPv6 flow label. */
 	uint32_t flags;							/**< Tunnel additional flags. */
-	uint32_t fmr_number;						/**< Tunnel FMR number. */
 	uint32_t sibling_if_num;					/**< Sibling interface number. */
-	uint16_t reserved1;						/**< Reserved for alignment. */
 	uint8_t hop_limit;						/**< Tunnel IPv6 hop limit. */
 	uint8_t draft03;						/**< Use MAP-E draft03 specification. */
+	bool ttl_inherit;						/**< Inherit IPv4 TTL to hoplimit. */
+	bool tos_inherit;						/**< Inherit IPv4 ToS. */
+	bool frag_id_update;						/**< Enable update of fragment identifier of IPv4. */
 };
 
 /**
@@ -90,10 +97,12 @@ struct nss_tunipip6_msg {
 	 */
 	union {
 		struct nss_tunipip6_create_msg tunipip6_create;
-				/**< Create a DS-Lite tunnel. */
+				/**< Create a DS-Lite/IPIP6 tunnel. */
 		struct nss_tunipip6_stats_sync_msg stats_sync;
 				/**< Synchronized statistics for the DS-Lite interface. */
-	} msg;			/**< Message payload for IPIP6 Tunnel messages exchanged with NSS core. */
+		struct nss_tunipip6_map_rule map_rule;
+				/**< BMR/FMR rule to add/delete, new or existing rules. */
+	} msg;			/**< Message payload for IPIP6 tunnel messages exchanged with NSS core. */
 };
 
 /**
@@ -124,6 +133,22 @@ typedef void (*nss_tunipip6_msg_callback
 extern nss_tx_status_t nss_tunipip6_tx(struct nss_ctx_instance *nss_ctx, struct nss_tunipip6_msg *msg);
 
 /**
+ * nss_tunipip6_tx_sync
+ *	Sends a DS-Lite message to NSS core synchronously.
+ *
+ * @datatypes
+ * nss_ctx_instance \n
+ * nss_tunipip6_msg
+ *
+ * @param[in] nss_ctx  Pointer to the NSS context.
+ * @param[in] msg      Pointer to the message data.
+ *
+ * @return
+ * Status of the Tx operation.
+ */
+extern nss_tx_status_t nss_tunipip6_tx_sync(struct nss_ctx_instance *nss_ctx, struct nss_tunipip6_msg *msg);
+
+/**
  * Callback function for receiving DS-Lite data.
  *
  * @datatypes
--- a/exports/nss_wifi.h
+++ b/exports/nss_wifi.h
@@ -90,6 +90,8 @@ enum nss_wifi_metadata_types {
 	NSS_WIFI_CMD_MSG,
 	NSS_WIFI_ENABLE_OL_STATSV2_MSG,
 	NSS_WIFI_OL_PEER_TIME_MSG,
+	NSS_WIFI_PEER_SET_VLAN_ID_MSG,
+	NSS_WIFI_PEER_ISOLATION_MSG,
 	NSS_WIFI_MAX_MSG
 };
 
@@ -739,7 +741,16 @@ struct nss_wifi_ol_stats_msg {
  *	Station kickout message from NSS Firmware
  */
 struct nss_wifi_sta_kickout_msg {
-	uint32_t peer_id;	/**< ID of the peer. */
+	uint32_t peer_id;	/**< Peer ID. */
+};
+
+/**
+ * nss_wifi_peer_isolation_msg
+ *	Peer isolation message
+ */
+struct nss_wifi_peer_isolation_msg {
+	uint16_t peer_id;	/**< Peer ID. */
+	uint16_t isolation;	/**< Isolation enabled/disabled. */
 };
 
 /**
@@ -905,6 +916,8 @@ struct nss_wifi_msg {
 				/**< Enable version 2 tx/rx stats. */
 		struct nss_wifi_ol_peer_time_msg wopt_msg;
 				/**< Send per peer/TID timestamp statistics to host. */
+		struct nss_wifi_peer_isolation_msg isolation_msg;
+				/**< Enable or disable peer isolation. */
 	} msg; /**< Message Payload. */
 };
 
--- a/exports/nss_wifi_vdev.h
+++ b/exports/nss_wifi_vdev.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2015-2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2015-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -762,6 +762,9 @@ struct nss_wifi_vdev_per_packet_metadata
  */
 struct nss_wifi_vdev_meshmode_rx_metadata {
 	uint16_t rs_ratephy;	/**< PHY rate. */
+	uint16_t rs_ratephy_lo;	/**< PHY rate lower bytes. */
+	uint16_t rs_ratephy_hi;	/**< PHY rate higher bytes. */
+	uint16_t cntr_chan_freq;	/** Center channel frequency. */
 	uint16_t vdev_id;	/**< Virtual device ID. */
 	uint16_t peer_id;	/**< Peer ID. */
 	uint16_t rs_rssi;	/**< Received signal strength indication (noise floor adjusted). */
--- a/exports/nss_wifili_if.h
+++ b/exports/nss_wifili_if.h
@@ -92,6 +92,8 @@
 				/**< Maximum number of physical devices on the external SoC. */
 #define NSS_WIFILI_PEER_AST_FLOWQ_MAX 4
 				/**< Maximum number of flow queues. */
+#define NSS_WIFILI_WBM_INTERNAL_ERR_MAX 5
+				/**< WBM internal maximum errors. */
 
 /*
  * Radio specific flags
@@ -179,6 +181,9 @@ enum nss_wifili_msg_types {
 	NSS_WIFILI_PEER_AST_FLOWID_MAP_MSG,
 	NSS_WIFILI_PEER_MEC_AGEOUT_MSG,
 	NSS_WIFILI_JITTER_STATS_MSG,
+	NSS_WIFILI_ISOLATION_MSG,
+	NSS_WIFILI_PEER_EXT_STATS_MSG,
+	NSS_WIFILI_CLR_STATS,
 	NSS_WIFILI_MAX_MSG
 };
 
@@ -558,6 +563,7 @@ enum nss_wifili_stats_rxdma_ring {
  *	Wifili WBM(Wireless Buffer Manager) ring statistics.
  */
 enum nss_wifili_stats_wbm {
+	NSS_WIFILI_STATS_WBM_IE_LOCAL_ALLOC_FAIL,	/**< Number of Wireless Buffer Manger internal local allocation failures. */
 	NSS_WIFILI_STATS_WBM_SRC_DMA,			/**< Number of Rx invalid source DMA. */
 	NSS_WIFILI_STATS_WBM_SRC_DMA_CODE_INV,		/**< Number of Rx invalid source DMA. */
 	NSS_WIFILI_STATS_WBM_SRC_REO,			/**< Number of Rx invalid source reorder. */
@@ -762,7 +768,7 @@ struct nss_wifili_pdev_init_msg {
 	uint32_t hwmode;
 			/**< MAC hardware mode. */
 	uint32_t lmac_id;
-			/**< lower MAC ID. */
+			/**< Lower MAC ID. */
 	uint32_t num_rx_swdesc;
 			/**< Number of descriptors per Rx pool. */
 	uint32_t target_pdev_id;
@@ -807,14 +813,16 @@ struct nss_wifili_peer_msg {
 			/**< Hardware address search table index. */
 	uint8_t is_nawds;
 			/**< NAWDS enabled for peer. */
-	uint8_t reserved;
-			/**< Padding for alignment. */
+	uint8_t pext_stats_valid;
+			/**< Peer extended statistics valid. */
 	uint16_t psta_vdev_id;
 			/**< Proxy station VAP ID. */
 	uint32_t nss_peer_mem;
 			/**< Holds peer memory adderss for NSS. */
 	uint32_t tx_ast_hash;
 			/**< AST hash to be used during packet transmission. */
+	uint32_t pext_stats_mem;
+			/**< Peer extended statistics memory. */
 };
 
 /**
@@ -980,6 +988,8 @@ struct nss_wifili_rx_wbm_ring_stats {
 						/**< Rx reoder error codes. */
 	uint32_t err_dma_codes[NSS_WIFILI_DMA_CODE_MAX];
 						/**< DMA error codes. */
+	uint32_t err_internal_codes[NSS_WIFILI_WBM_INTERNAL_ERR_MAX];
+						/**< Wireless Buffer Manger error codes. */
 };
 
 /**
@@ -1119,9 +1129,9 @@ struct nss_wifili_v3_tx_rx_per_ac_stats
  */
 struct nss_wifili_radio_tx_rx_stats_v3 {
 	struct nss_wifili_v3_tx_rx_per_tid_stats tid_stats[NSS_WIFILI_MAX_TID];
-				/**< Per TID Tx and Rx statistics. */
+				/**< Per-TID Tx and Rx statistics. */
 	struct nss_wifili_v3_tx_rx_per_ac_stats ac_stats[NSS_WIFILI_WME_AC_MAX];
-				/**< Per Access Category Tx and Rx statistics. */
+				/**< Per-Access Category Tx and Rx statistics. */
 };
 
 /**
@@ -1130,7 +1140,7 @@ struct nss_wifili_radio_tx_rx_stats_v3 {
  */
 struct nss_wifili_radio_delay_stats_v3 {
 	struct nss_wifili_v3_delay_per_tid_stats v3_delay_stats[NSS_WIFILI_MAX_TID];
-				/**< Per TID delay statistics. */
+				/**< Per-TID delay statistics. */
 };
 
 /**
@@ -1320,8 +1330,8 @@ struct nss_wifili_peer_stats_msg {
  *      Wifili sojourn per TID statistics.
  */
 struct nss_wifili_sojourn_per_tid_stats {
-	uint32_t avg_sojourn_msdu;	/**< Average per TID of all time difference. */
-	uint32_t sum_sojourn_msdu;	/**< Sum per TID of all time difference. */
+	uint32_t avg_sojourn_msdu;	/**< Average per-TID of all time difference. */
+	uint32_t sum_sojourn_msdu;	/**< Sum per-TID of all time difference. */
 	uint32_t num_msdus;		/**< MSDUs per TID. */
 };
 
@@ -1373,7 +1383,6 @@ struct nss_wifili_jitter_stats_msg {
 	struct nss_wifili_jitter_stats jitter_stats[1];	/**< Jitter statistics. */
 };
 
-
 /**
  * nss_wifili_wds_peer_msg
  *	Wi-Fi Wireless distribution system (WDS) peer-specific message.
@@ -1387,6 +1396,34 @@ struct nss_wifili_wds_peer_msg {
 };
 
 /**
+ * nss_wifili_peer_delay_stats
+ *	Per-peer delay statistics.
+ */
+struct nss_wifili_peer_delay_stats {
+        struct nss_wifili_delay_stats swq_delay;                    /**< Software enqueue delay. */
+        struct nss_wifili_delay_stats hwtx_delay;                   /**< Hardware transmit delay. */
+};
+
+/**
+ * nss_wifili_peer_ext_stats
+ *      Peer extended statistics.
+ */
+struct nss_wifili_peer_ext_stats {
+        uint32_t peer_id;                       /**< Peer ID. */
+        struct nss_wifili_peer_delay_stats delay_stats[NSS_WIFILI_MAX_TID];
+                                                /**< Delay statistics. */
+};
+
+/**
+ * nss_wifili_peer_ext_stats_msg
+ *      Peer extended statistics message.
+ */
+struct nss_wifili_peer_ext_stats_msg {
+        uint32_t npeers;                                /**< Number of peers. */
+        struct nss_wifili_peer_ext_stats ext_stats[1];      /**< Extended statistics. */
+};
+
+/**
  * nss_wifili_stats_cfg_msg
  *	Wifili stats enable/disable configuration message.
  */
@@ -1484,6 +1521,15 @@ struct nss_wifili_peer_vlan_id_msg {
 };
 
 /**
+ * nss_wifili_peer_isolation_msg
+ *	Wifili peer isolation message.
+ */
+struct nss_wifili_peer_isolation_msg {
+	uint16_t peer_id;			/**< Peer ID. */
+	uint16_t isolation;			/**< Isolation enabled/disabled. */
+};
+
+/**
  * nss_wifili_dbdc_repeater_set_msg
  *	Wifili DBDC repeater set message.
  */
@@ -1528,6 +1574,14 @@ struct nss_wifili_enable_v3_stats_msg {
 };
 
 /**
+ * nss_wifili_clr_stats_msg
+ *	NSS firmware statistics clear message.
+ */
+struct nss_wifili_clr_stats_msg {
+	uint8_t vdev_id;;	/**< VAP ID. */
+};
+
+/**
  * nss_wifili_update_pdev_lmac_id_msg
  * 	Physical device ID and lower MAC ID update message.
  */
@@ -1652,6 +1706,13 @@ struct nss_wifili_msg {
 				/**< Multicast echo check active information specific message. */
 		struct nss_wifili_jitter_stats_msg jt_stats_msg;
 				/**<Jitter statistics message. */
+		struct nss_wifili_peer_isolation_msg isolation_msg;
+				/**< Peer isolation message. */
+				/**< Jitter statistics message. */
+		struct nss_wifili_peer_ext_stats_msg pext_msg;
+				/**< Peer extended statistics message. */
+		struct nss_wifili_clr_stats_msg clrstats;
+				/**< Clear NSS firmware statistics. */
 	} msg;			/**< Message payload. */
 };
 
@@ -1672,6 +1733,22 @@ struct nss_wifili_msg {
 extern nss_tx_status_t nss_wifili_tx_msg(struct nss_ctx_instance *nss_ctx, struct nss_wifili_msg *msg);
 
 /**
+ * nss_wifili_tx_msg_sync
+ *	Send wifili messages synchronously.
+ *
+ * @datatypes
+ * nss_ctx_instance \n
+ * nss_wifili_msg
+ *
+ * @param[in] nss_ctx NSS context.
+ * @param[in] msg     NSS Wi-Fi message.
+ *
+ * @return
+ * nss_tx_status_t Tx status.
+ */
+extern nss_tx_status_t nss_wifili_tx_msg_sync(struct nss_ctx_instance *nss_ctx, struct nss_wifili_msg *msg);
+
+/**
  * nss_wifili_msg_callback_t
  *	Callback to receive wifili messages.
  *
--- a/nss_bridge.c
+++ b/nss_bridge.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2016-2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016-2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -45,12 +45,12 @@ static void nss_bridge_handler(struct ns
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >= NSS_BRIDGE_MSG_TYPE_MAX) {
-		nss_warning("%p: received invalid message %d for bridge interface", nss_ctx, ncm->type);
+		nss_warning("%px: received invalid message %d for bridge interface", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_bridge_msg)) {
-		nss_warning("%p: length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
@@ -150,12 +150,12 @@ nss_tx_status_t nss_bridge_tx_msg(struct
 	 * Sanity check the message
 	 */
 	if (!nss_is_dynamic_interface(ncm->interface)) {
-		nss_warning("%p: tx request for interface that is not a bridge: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: tx request for interface that is not a bridge: %d", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
 	if (ncm->type >= NSS_BRIDGE_MSG_TYPE_MAX) {
-		nss_warning("%p: message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
@@ -186,7 +186,7 @@ nss_tx_status_t nss_bridge_tx_msg_sync(s
 
 	status = nss_bridge_tx_msg(nss_ctx, nbm);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: bridge_tx_msg failed\n", nss_ctx);
+		nss_warning("%px: bridge_tx_msg failed\n", nss_ctx);
 		up(&bridge_pvt.sem);
 		return status;
 	}
@@ -194,7 +194,7 @@ nss_tx_status_t nss_bridge_tx_msg_sync(s
 	ret = wait_for_completion_timeout(&bridge_pvt.complete, msecs_to_jiffies(NSS_BRIDGE_TX_TIMEOUT));
 
 	if (!ret) {
-		nss_warning("%p: bridge msg tx failed due to timeout\n", nss_ctx);
+		nss_warning("%px: bridge msg tx failed due to timeout\n", nss_ctx);
 		bridge_pvt.response = NSS_TX_FAILURE;
 	}
 
@@ -229,7 +229,7 @@ nss_tx_status_t nss_bridge_tx_vsi_assign
 	}
 
 	if (nss_bridge_verify_if_num(if_num) == false) {
-		nss_warning("%p: invalid interface %d", nss_ctx, if_num);
+		nss_warning("%px: invalid interface %d", nss_ctx, if_num);
 		return NSS_TX_FAILURE;
 	}
 
@@ -257,7 +257,7 @@ nss_tx_status_t nss_bridge_tx_vsi_unassi
 	}
 
 	if (nss_bridge_verify_if_num(if_num) == false) {
-		nss_warning("%p: invalid interface %d", nss_ctx, if_num);
+		nss_warning("%px: invalid interface %d", nss_ctx, if_num);
 		return NSS_TX_FAILURE;
 	}
 
@@ -286,7 +286,7 @@ nss_tx_status_t nss_bridge_tx_set_mtu_ms
 	}
 
 	if (nss_bridge_verify_if_num(bridge_if_num) == false) {
-		nss_warning("%p: received invalid interface %d", nss_ctx, bridge_if_num);
+		nss_warning("%px: received invalid interface %d", nss_ctx, bridge_if_num);
 		return NSS_TX_FAILURE;
 	}
 
@@ -316,7 +316,7 @@ nss_tx_status_t nss_bridge_tx_set_mac_ad
 	}
 
 	if (nss_bridge_verify_if_num(bridge_if_num) == false) {
-		nss_warning("%p: received invalid interface %d", nss_ctx, bridge_if_num);
+		nss_warning("%px: received invalid interface %d", nss_ctx, bridge_if_num);
 		return NSS_TX_FAILURE;
 	}
 
@@ -345,13 +345,13 @@ nss_tx_status_t nss_bridge_tx_join_msg(u
 	}
 
 	if (nss_bridge_verify_if_num(bridge_if_num) == false) {
-		nss_warning("%p: received invalid interface %d\n", nss_ctx, bridge_if_num);
+		nss_warning("%px: received invalid interface %d\n", nss_ctx, bridge_if_num);
 		return NSS_TX_FAILURE;
 	}
 
 	slave_if_num = nss_cmn_get_interface_number_by_dev(netdev);
 	if (slave_if_num < 0) {
-		nss_warning("%p: invalid slave device %p\n", nss_ctx, netdev);
+		nss_warning("%px: invalid slave device %px\n", nss_ctx, netdev);
 		return NSS_TX_FAILURE;
 	}
 
@@ -379,13 +379,13 @@ nss_tx_status_t nss_bridge_tx_leave_msg(
 	}
 
 	if (nss_bridge_verify_if_num(bridge_if_num) == false) {
-		nss_warning("%p: received invalid interface %d\n", nss_ctx, bridge_if_num);
+		nss_warning("%px: received invalid interface %d\n", nss_ctx, bridge_if_num);
 		return NSS_TX_FAILURE;
 	}
 
 	slave_if_num = nss_cmn_get_interface_number_by_dev(netdev);
 	if (slave_if_num < 0) {
-		nss_warning("%p: invalid slave device %p\n", nss_ctx, netdev);
+		nss_warning("%px: invalid slave device %px\n", nss_ctx, netdev);
 		return NSS_TX_FAILURE;
 	}
 
@@ -412,12 +412,12 @@ nss_tx_status_t nss_bridge_tx_set_fdb_le
 	}
 
 	if (nss_bridge_verify_if_num(bridge_if_num) == false) {
-		nss_warning("%p: received invalid interface %d\n", nss_ctx, bridge_if_num);
+		nss_warning("%px: received invalid interface %d\n", nss_ctx, bridge_if_num);
 		return NSS_TX_FAILURE;
 	}
 
 	if (fdb_learn >= NSS_BRIDGE_FDB_LEARN_MODE_MAX) {
-		nss_warning("%p: received invalid fdb learn mode %d\n", nss_ctx, fdb_learn);
+		nss_warning("%px: received invalid fdb learn mode %d\n", nss_ctx, fdb_learn);
 		return NSS_TX_FAILURE;
 	}
 
--- a/nss_bridge_log.c
+++ b/nss_bridge_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -38,7 +38,7 @@ static int8_t *nss_bridge_log_message_ty
 static void nss_bridge_join_msg(struct nss_bridge_msg *nbm)
 {
 	struct nss_bridge_join_msg *nbjm __maybe_unused = &nbm->msg.br_join;
-	nss_trace("%p: NSS Bridge Join message \n"
+	nss_trace("%px: NSS Bridge Join message \n"
 		"Interface Number: %d\n",
 		nbm, nbjm->if_num);
 }
@@ -50,7 +50,7 @@ static void nss_bridge_join_msg(struct n
 static void nss_bridge_leave_msg(struct nss_bridge_msg *nbm)
 {
 	struct nss_bridge_leave_msg *nblm __maybe_unused = &nbm->msg.br_leave;
-	nss_trace("%p: NSS Bridge Leave message: \n"
+	nss_trace("%px: NSS Bridge Leave message: \n"
 		"Interface Number: %d\n",
 		nbm, nblm->if_num);
 }
@@ -63,7 +63,7 @@ static void nss_bridge_fdb_learn_msg(str
 {
 	struct nss_bridge_set_fdb_learn_msg *nbflm __maybe_unused =
 		&nbm->msg.fdb_learn;
-	nss_trace("%p: NSS Bridge Set FDB Learn message: \n"
+	nss_trace("%px: NSS Bridge Set FDB Learn message: \n"
 		"Mode: %d\n",
 		nbm, nbflm->mode);
 }
@@ -88,7 +88,7 @@ static void nss_bridge_log_verbose(struc
 		break;
 
 	default:
-		nss_trace("%p: Invalid message type\n", nbm);
+		nss_trace("%px: Invalid message type\n", nbm);
 		break;
 	}
 }
@@ -100,11 +100,11 @@ static void nss_bridge_log_verbose(struc
 void nss_bridge_log_tx_msg(struct nss_bridge_msg *nbm)
 {
 	if (nbm->cm.type >= NSS_BRIDGE_MSG_TYPE_MAX) {
-		nss_warning("%p: Invalid message type\n", nbm);
+		nss_warning("%px: Invalid message type\n", nbm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", nbm, nbm->cm.type, nss_bridge_log_message_types_str[nbm->cm.type - NSS_IF_MAX_MSG_TYPES - 1]);
+	nss_info("%px: type[%d]:%s\n", nbm, nbm->cm.type, nss_bridge_log_message_types_str[nbm->cm.type - NSS_IF_MAX_MSG_TYPES - 1]);
 	nss_bridge_log_verbose(nbm);
 }
 
@@ -115,18 +115,18 @@ void nss_bridge_log_tx_msg(struct nss_br
 void nss_bridge_log_rx_msg(struct nss_bridge_msg *nbm)
 {
 	if (nbm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", nbm);
+		nss_warning("%px: Invalid response\n", nbm);
 		return;
 	}
 
 	if (nbm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (nbm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", nbm, nbm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", nbm, nbm->cm.type,
 			nss_bridge_log_message_types_str[nbm->cm.type - NSS_IF_MAX_MSG_TYPES - 1],
 			nbm->cm.response, nss_cmn_response_str[nbm->cm.response]);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s\n",
 		nbm, nbm->cm.type, nss_bridge_log_message_types_str[nbm->cm.type - NSS_IF_MAX_MSG_TYPES - 1],
 		nbm->cm.response, nss_cmn_response_str[nbm->cm.response]);
 
--- a/nss_c2c_rx.c
+++ b/nss_c2c_rx.c
@@ -43,7 +43,7 @@ static void nss_c2c_rx_interface_handler
 	nss_c2c_rx_msg_callback_t cb;
 
 	if (!nss_c2c_rx_verify_if_num(ncm->interface)) {
-		nss_warning("%p: invalid interface %d for c2c_tx\n", nss_ctx, ncm->interface);
+		nss_warning("%px: invalid interface %d for c2c_tx\n", nss_ctx, ncm->interface);
 		return;
 	}
 
@@ -51,12 +51,12 @@ static void nss_c2c_rx_interface_handler
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >= NSS_C2C_RX_MSG_TYPE_MAX) {
-		nss_warning("%p: received invalid message %d for c2c_rx", nss_ctx, ncm->type);
+		nss_warning("%px: received invalid message %d for c2c_rx", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_c2c_rx_msg)) {
-		nss_warning("%p: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
--- a/nss_c2c_tx.c
+++ b/nss_c2c_tx.c
@@ -68,7 +68,7 @@ static void nss_c2c_tx_msg_handler(struc
 	nss_c2c_tx_msg_callback_t cb;
 
 	if (!nss_c2c_tx_verify_if_num(ncm->interface)) {
-		nss_warning("%p: invalid interface %d for c2c_tx\n", nss_ctx, ncm->interface);
+		nss_warning("%px: invalid interface %d for c2c_tx\n", nss_ctx, ncm->interface);
 		return;
 	}
 
@@ -76,12 +76,12 @@ static void nss_c2c_tx_msg_handler(struc
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >= NSS_C2C_TX_MSG_TYPE_MAX) {
-		nss_warning("%p: received invalid message %d for c2c_tx", nss_ctx, ncm->type);
+		nss_warning("%px: received invalid message %d for c2c_tx", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_c2c_tx_msg)) {
-		nss_warning("%p: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
@@ -137,7 +137,7 @@ static void nss_c2c_tx_msg_handler(struc
  */
 void nss_c2c_tx_register_handler(struct nss_ctx_instance *nss_ctx)
 {
-	nss_info("%p: nss_c2c_tx_register_handler", nss_ctx);
+	nss_info("%px: nss_c2c_tx_register_handler", nss_ctx);
 	nss_core_register_handler(nss_ctx, NSS_C2C_TX_INTERFACE, nss_c2c_tx_msg_handler, NULL);
 
 	if (nss_ctx->id == NSS_CORE_0) {
@@ -159,12 +159,12 @@ nss_tx_status_t nss_c2c_tx_tx_msg(struct
 	 * Sanity check the message
 	 */
 	if (!nss_c2c_tx_verify_if_num(ncm->interface)) {
-		nss_warning("%p: tx request for another interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: tx request for another interface: %d", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
 	if (ncm->type >= NSS_C2C_TX_MSG_TYPE_MAX) {
-		nss_warning("%p: message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
@@ -185,11 +185,11 @@ static void nss_c2c_tx_msg_cfg_map_callb
 {
 	struct nss_ctx_instance *nss_ctx __attribute__((unused)) = (struct nss_ctx_instance *)app_data;
 	if (nctm->cm.response != NSS_CMN_RESPONSE_ACK) {
-		nss_warning("%p: nss c2c_tx_map configuration failed: %d for NSS core %d\n",
+		nss_warning("%px: nss c2c_tx_map configuration failed: %d for NSS core %d\n",
 			nss_ctx, nctm->cm.error, nss_ctx->id);
 	}
 
-	nss_info("%p: nss c2c_tx_map configuration succeeded for NSS core %d\n",
+	nss_info("%px: nss c2c_tx_map configuration succeeded for NSS core %d\n",
 		nss_ctx, nss_ctx->id);
 }
 
@@ -205,13 +205,13 @@ static void nss_c2c_tx_msg_performance_t
 	 * Test start has been failed. Restore the value to initial state.
 	 */
 	if (nctm->cm.response != NSS_CMN_RESPONSE_ACK) {
-		nss_warning("%p: nss c2c_tx test start failed: %d for NSS core %d\n",
+		nss_warning("%px: nss c2c_tx test start failed: %d for NSS core %d\n",
 			nss_ctx, nctm->cm.error, nss_ctx->id);
 		nss_c2c_tx_test_id = -1;
 		return;
 	}
 
-	nss_info("%p: nss c2c_tx test successfully initialized for NSS core %d\n",
+	nss_info("%px: nss c2c_tx test successfully initialized for NSS core %d\n",
 		nss_ctx, nss_ctx->id);
 }
 
@@ -225,7 +225,7 @@ nss_tx_status_t nss_c2c_tx_msg_cfg_map(s
 	struct nss_c2c_tx_msg nctm;
 	struct nss_c2c_tx_map *cfg_map;
 
-	nss_info("%p: C2C map:%x\n", nss_ctx, tx_map);
+	nss_info("%px: C2C map:%x\n", nss_ctx, tx_map);
 	nss_c2c_tx_msg_init(&nctm, NSS_C2C_TX_INTERFACE, NSS_C2C_TX_MSG_TYPE_TX_MAP,
 		sizeof(struct nss_c2c_tx_map), nss_c2c_tx_msg_cfg_map_callback, (void *)nss_ctx);
 
@@ -251,7 +251,7 @@ nss_tx_status_t nss_c2c_tx_msg_performan
 	struct nss_c2c_tx_msg nctm;
 	struct nss_c2c_tx_test *test;
 
-	nss_info("%p: C2C test message:%x\n", nss_ctx, test_id);
+	nss_info("%px: C2C test message:%x\n", nss_ctx, test_id);
 	nss_c2c_tx_msg_init(&nctm, NSS_C2C_TX_INTERFACE, NSS_C2C_TX_MSG_TYPE_PERFORMANCE_TEST,
 		sizeof(struct nss_c2c_tx_test), nss_c2c_tx_msg_performance_test_callback, (void *)nss_ctx);
 
@@ -299,12 +299,12 @@ static int nss_c2c_tx_performance_test_h
 	}
 
 	if (current_state != -1) {
-		nss_warning("%p: Another test is running.\n", nss_ctx);
+		nss_warning("%px: Another test is running.\n", nss_ctx);
 		return -EINVAL;
 	}
 
 	if (nss_c2c_tx_test_id >= NSS_C2C_TX_TEST_TYPE_MAX || nss_c2c_tx_test_id <= 0) {
-		nss_warning("%p: Invalid test ID.\n", nss_ctx);
+		nss_warning("%px: Invalid test ID.\n", nss_ctx);
 		nss_c2c_tx_test_id = current_state;
 		return -EINVAL;
 	}
@@ -313,7 +313,7 @@ static int nss_c2c_tx_performance_test_h
 	ret_c2c_tx = nss_c2c_tx_msg_performance_test(nss_ctx, nss_c2c_tx_test_id);
 
 	if (ret_c2c_tx != NSS_SUCCESS) {
-		nss_warning("%p: Starting the test has failed.\n", nss_ctx);
+		nss_warning("%px: Starting the test has failed.\n", nss_ctx);
 		nss_c2c_tx_test_id = -1;
 	}
 
--- a/nss_c2c_tx_log.c
+++ b/nss_c2c_tx_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -46,7 +46,7 @@ static int8_t *nss_c2c_tx_log_error_resp
 static void nss_c2c_tx_map_msg(struct nss_c2c_tx_msg *nctm)
 {
 	struct nss_c2c_tx_map *nctmm __maybe_unused = &nctm->msg.map;
-	nss_trace("%p: NSS C2C TX Map message: \n"
+	nss_trace("%px: NSS C2C TX Map message: \n"
 		"C2C Receiver Queue Start Address: %d\n"
 		"C2C Interrupt Register Address: %d\n",
 		nctm,
@@ -65,7 +65,7 @@ static void nss_c2c_tx_log_verbose(struc
 		break;
 
 	default:
-		nss_trace("%p: Invalid message type\n", nctm);
+		nss_trace("%px: Invalid message type\n", nctm);
 		break;
 	}
 }
@@ -77,11 +77,11 @@ static void nss_c2c_tx_log_verbose(struc
 void nss_c2c_tx_log_tx_msg(struct nss_c2c_tx_msg *nctm)
 {
 	if (nctm->cm.type >= NSS_C2C_TX_MSG_TYPE_MAX) {
-		nss_info("%p: Invalid message type\n", nctm);
+		nss_info("%px: Invalid message type\n", nctm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", nctm, nctm->cm.type, nss_c2c_tx_log_message_types_str[nctm->cm.type]);
+	nss_info("%px: type[%d]:%s\n", nctm, nctm->cm.type, nss_c2c_tx_log_message_types_str[nctm->cm.type]);
 	nss_c2c_tx_log_verbose(nctm);
 }
 
@@ -92,26 +92,26 @@ void nss_c2c_tx_log_tx_msg(struct nss_c2
 void nss_c2c_tx_log_rx_msg(struct nss_c2c_tx_msg *nctm)
 {
 	if (nctm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", nctm);
+		nss_warning("%px: Invalid response\n", nctm);
 		return;
 	}
 
 	if (nctm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (nctm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", nctm, nctm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", nctm, nctm->cm.type,
 			nss_c2c_tx_log_message_types_str[nctm->cm.type],
 			nctm->cm.response, nss_cmn_response_str[nctm->cm.response]);
 		goto verbose;
 	}
 
 	if (nctm->cm.error >= NSS_C2C_TX_MSG_ERROR_MAX) {
-		nss_warning("%p: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
+		nss_warning("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
 			nctm, nctm->cm.type, nss_c2c_tx_log_message_types_str[nctm->cm.type],
 			nctm->cm.response, nss_cmn_response_str[nctm->cm.response],
 			nctm->cm.error);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
 		nctm, nctm->cm.type, nss_c2c_tx_log_message_types_str[nctm->cm.type],
 		nctm->cm.response, nss_cmn_response_str[nctm->cm.response],
 		nctm->cm.error, nss_c2c_tx_log_error_response_types_str[nctm->cm.error]);
--- a/nss_capwap.c
+++ b/nss_capwap.c
@@ -192,12 +192,12 @@ static void nss_capwap_msg_handler(struc
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type > NSS_CAPWAP_MSG_TYPE_MAX) {
-		nss_warning("%p: received invalid message %d for CAPWAP interface", nss_ctx, ncm->type);
+		nss_warning("%px: received invalid message %d for CAPWAP interface", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_capwap_msg)) {
-		nss_warning("%p: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
@@ -234,7 +234,7 @@ static void nss_capwap_msg_handler(struc
 	 * Do we have a callback
 	 */
 	if (!ncm->cb) {
-		nss_trace("%p: cb is null for interface %d", nss_ctx, ncm->interface);
+		nss_trace("%px: cb is null for interface %d", nss_ctx, ncm->interface);
 		return;
 	}
 
@@ -255,7 +255,7 @@ static bool nss_capwap_instance_alloc(st
 	 */
 	h = kmalloc(sizeof(struct nss_capwap_handle), GFP_ATOMIC);
 	if (h == NULL) {
-		nss_warning("%p: no memory for allocating CAPWAP instance for interface : %d", nss_ctx, if_num);
+		nss_warning("%px: no memory for allocating CAPWAP instance for interface : %d", nss_ctx, if_num);
 		return false;
 	}
 
@@ -266,7 +266,7 @@ static bool nss_capwap_instance_alloc(st
 	if (nss_capwap_hdl[if_num - NSS_DYNAMIC_IF_START] != NULL) {
 		spin_unlock(&nss_capwap_spinlock);
 		kfree(h);
-		nss_warning("%p: Another thread is already allocated instance for :%d", nss_ctx, if_num);
+		nss_warning("%px: Another thread is already allocated instance for :%d", nss_ctx, if_num);
 		return false;
 	}
 
@@ -302,7 +302,7 @@ nss_tx_status_t nss_capwap_tx_msg(struct
 	spin_lock(&nss_capwap_spinlock);
 	if (!nss_capwap_hdl[if_num]) {
 		spin_unlock(&nss_capwap_spinlock);
-		nss_warning("%p: capwap tunnel if_num is not there: %d", nss_ctx, msg->cm.interface);
+		nss_warning("%px: capwap tunnel if_num is not there: %d", nss_ctx, msg->cm.interface);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 	nss_capwap_refcnt_inc(msg->cm.interface);
@@ -372,14 +372,14 @@ struct nss_ctx_instance *nss_capwap_noti
 	nss_ctx = &nss_top_main.nss[nss_top_main.capwap_handler_id];
 
 	if (nss_capwap_verify_if_num(if_num) == false) {
-		nss_warning("%p: notfiy register received for invalid interface %d", nss_ctx, if_num);
+		nss_warning("%px: notfiy register received for invalid interface %d", nss_ctx, if_num);
 		return NULL;
 	}
 
 	spin_lock(&nss_capwap_spinlock);
 	if (nss_capwap_hdl[if_num - NSS_DYNAMIC_IF_START] != NULL) {
 		spin_unlock(&nss_capwap_spinlock);
-		nss_warning("%p: notfiy register tunnel already exists for interface %d", nss_ctx, if_num);
+		nss_warning("%px: notfiy register tunnel already exists for interface %d", nss_ctx, if_num);
 		return NULL;
 	}
 	spin_unlock(&nss_capwap_spinlock);
@@ -399,13 +399,13 @@ nss_tx_status_t nss_capwap_notify_unregi
 	int index;
 
 	if (nss_capwap_verify_if_num(if_num) == false) {
-		nss_warning("%p: notify unregister received for invalid interface %d", nss_ctx, if_num);
+		nss_warning("%px: notify unregister received for invalid interface %d", nss_ctx, if_num);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
 	nss_top = nss_ctx->nss_top;
 	if (nss_top == NULL) {
-		nss_warning("%p: notify unregister received for invalid nss_top %d", nss_ctx, if_num);
+		nss_warning("%px: notify unregister received for invalid nss_top %d", nss_ctx, if_num);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
@@ -413,7 +413,7 @@ nss_tx_status_t nss_capwap_notify_unregi
 	spin_lock(&nss_capwap_spinlock);
 	if (nss_capwap_hdl[index] == NULL) {
 		spin_unlock(&nss_capwap_spinlock);
-		nss_warning("%p: notify unregister received for unallocated if_num: %d", nss_ctx, if_num);
+		nss_warning("%px: notify unregister received for unallocated if_num: %d", nss_ctx, if_num);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
@@ -423,7 +423,7 @@ nss_tx_status_t nss_capwap_notify_unregi
 	 */
 	if (nss_capwap_refcnt(if_num) != 0) {
 		spin_unlock(&nss_capwap_spinlock);
-		nss_warning("%p: notify unregister tunnel %d: has reference", nss_ctx, if_num);
+		nss_warning("%px: notify unregister tunnel %d: has reference", nss_ctx, if_num);
 		return NSS_TX_FAILURE_QUEUE;
 	}
 
@@ -445,7 +445,7 @@ struct nss_ctx_instance *nss_capwap_data
 
 	nss_ctx = nss_capwap_get_ctx();
 	if (nss_capwap_verify_if_num(if_num) == false) {
-		nss_warning("%p: data register received for invalid interface %d", nss_ctx, if_num);
+		nss_warning("%px: data register received for invalid interface %d", nss_ctx, if_num);
 		return NULL;
 	}
 
@@ -458,12 +458,12 @@ struct nss_ctx_instance *nss_capwap_data
 
 	core_status = nss_core_register_handler(nss_ctx, if_num, nss_capwap_msg_handler, NULL);
 	if (core_status != NSS_CORE_STATUS_SUCCESS) {
-		nss_warning("%p: nss core register handler failed for if_num:%d with error :%d", nss_ctx, if_num, core_status);
+		nss_warning("%px: nss core register handler failed for if_num:%d with error :%d", nss_ctx, if_num, core_status);
 		return NULL;
 	}
 
 	if (nss_capwap_instance_alloc(nss_ctx, if_num) == false) {
-		nss_warning("%p: couldn't allocate tunnel  instance for if_num:%d", nss_ctx, if_num);
+		nss_warning("%px: couldn't allocate tunnel  instance for if_num:%d", nss_ctx, if_num);
 		return NULL;
 	}
 
@@ -484,7 +484,7 @@ bool nss_capwap_data_unregister(uint32_t
 
 	nss_ctx = nss_capwap_get_ctx();
 	if (nss_capwap_verify_if_num(if_num) == false) {
-		nss_warning("%p: data unregister received for invalid interface %d", nss_ctx, if_num);
+		nss_warning("%px: data unregister received for invalid interface %d", nss_ctx, if_num);
 		return false;
 	}
 
@@ -494,7 +494,7 @@ bool nss_capwap_data_unregister(uint32_t
 	 */
 	if (nss_capwap_refcnt(if_num) != 0) {
 		spin_unlock(&nss_capwap_spinlock);
-		nss_warning("%p: notify unregister tunnel %d: has reference", nss_ctx, if_num);
+		nss_warning("%px: notify unregister tunnel %d: has reference", nss_ctx, if_num);
 		return false;
 	}
 	h = nss_capwap_hdl[if_num - NSS_DYNAMIC_IF_START];
@@ -533,7 +533,7 @@ int nss_capwap_ifnum_with_core_id(int if
 
 	NSS_VERIFY_CTX_MAGIC(nss_ctx);
 	if (nss_is_dynamic_interface(if_num) == false) {
-		nss_info("%p: Invalid if_num: %d, must be a dynamic interface\n", nss_ctx, if_num);
+		nss_info("%px: Invalid if_num: %d, must be a dynamic interface\n", nss_ctx, if_num);
 		return 0;
 	}
 	return NSS_INTERFACE_NUM_APPEND_COREID(nss_ctx, if_num);
--- a/nss_capwap_log.c
+++ b/nss_capwap_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -69,10 +69,10 @@ static int8_t *nss_capwap_log_error_resp
 static void nss_capwap_rule_msg(struct nss_capwap_msg *ncm)
 {
 	struct nss_capwap_rule_msg *ncrm __maybe_unused = &ncm->msg.rule;
-	nss_trace("%p: NSS CAPWAP Rule message \n"
-		"Encap Rule Src IP: %p\n"
+	nss_trace("%px: NSS CAPWAP Rule message \n"
+		"Encap Rule Src IP: %px\n"
 		"Encap Rule Src Port: %d\n"
-		"Encap Rule Dst Ip: %p\n"
+		"Encap Rule Dst Ip: %px\n"
 		"Encap Rule Dst Port: %d\n"
 		"Encap Rule Path MTU: %d\n"
 		"Decap Rule Reassembly Timeout: %d\n"
@@ -87,7 +87,7 @@ static void nss_capwap_rule_msg(struct n
 		"GMAC Interface Number: %d\n"
 		"Enabled Features: %x\n"
 		"DTLS Interface Number: %d\n"
-		"BSSID: %p\n"
+		"BSSID: %px\n"
 		"Outer Segment Value: %x\n",
 		ncrm,
 		&ncrm->encap.src_ip.ip,
@@ -114,7 +114,7 @@ static void nss_capwap_rule_msg(struct n
 static void nss_capwap_path_mtu_msg(struct nss_capwap_msg *ncm)
 {
 	struct nss_capwap_path_mtu_msg *ncpmm __maybe_unused = &ncm->msg.mtu;
-	nss_trace("%p: NSS CAPWAP Path MTU message \n"
+	nss_trace("%px: NSS CAPWAP Path MTU message \n"
 		"CAPWAP Path MTU: %d\n",
 		ncpmm,
 		ncpmm->path_mtu);
@@ -127,7 +127,7 @@ static void nss_capwap_path_mtu_msg(stru
 static void nss_capwap_version_msg(struct nss_capwap_msg *ncm)
 {
 	struct nss_capwap_version_msg *ncvm __maybe_unused = &ncm->msg.version;
-	nss_trace("%p: NSS CAPWAP Version message \n"
+	nss_trace("%px: NSS CAPWAP Version message \n"
 		"CAPWAP Version: %d\n",
 		ncvm,
 		ncvm->version);
@@ -140,7 +140,7 @@ static void nss_capwap_version_msg(struc
 static void nss_capwap_dtls_msg(struct nss_capwap_msg *ncm)
 {
 	struct nss_capwap_dtls_msg *ncdm __maybe_unused = &ncm->msg.dtls;
-	nss_trace("%p: NSS CAPWAP dtls message \n"
+	nss_trace("%px: NSS CAPWAP dtls message \n"
 		"CAPWAP DTLS Enable: %d\n"
 		"CAPWAP DTLS Inner Interface Number: %d\n"
 		"CAPWAP MTU Adjust: %d\n"
@@ -156,7 +156,7 @@ static void nss_capwap_dtls_msg(struct n
  */
 static void nss_capwap_flow_rule_msg(struct nss_capwap_flow_rule_msg *ncfrm)
 {
-	nss_trace("%p: NSS CAPWAP Flow Rule message \n"
+	nss_trace("%px: NSS CAPWAP Flow Rule message \n"
 		"CAPWAP IP Version: %d\n"
 		"CAPWAP Layer 4 Protocol: %d\n"
 		"CAPWAP Source Port: %d\n"
@@ -226,7 +226,7 @@ static void nss_capwap_log_verbose(struc
 		break;
 
 	default:
-		nss_trace("%p: Invalid message type\n", ncm);
+		nss_trace("%px: Invalid message type\n", ncm);
 		break;
 	}
 }
@@ -238,11 +238,11 @@ static void nss_capwap_log_verbose(struc
 void nss_capwap_log_tx_msg(struct nss_capwap_msg *ncm)
 {
 	if (ncm->cm.type >= NSS_CAPWAP_MSG_TYPE_MAX) {
-		nss_warning("%p: Invalid message type\n", ncm);
+		nss_warning("%px: Invalid message type\n", ncm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", ncm, ncm->cm.type, nss_capwap_log_message_types_str[ncm->cm.type]);
+	nss_info("%px: type[%d]:%s\n", ncm, ncm->cm.type, nss_capwap_log_message_types_str[ncm->cm.type]);
 	nss_capwap_log_verbose(ncm);
 }
 
@@ -253,26 +253,26 @@ void nss_capwap_log_tx_msg(struct nss_ca
 void nss_capwap_log_rx_msg(struct nss_capwap_msg *ncm)
 {
 	if (ncm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", ncm);
+		nss_warning("%px: Invalid response\n", ncm);
 		return;
 	}
 
 	if (ncm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (ncm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", ncm, ncm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", ncm, ncm->cm.type,
 			nss_capwap_log_message_types_str[ncm->cm.type],
 			ncm->cm.response, nss_cmn_response_str[ncm->cm.response]);
 		goto verbose;
 	}
 
 	if (ncm->cm.error >= NSS_CAPWAP_ERROR_MSG_MAX) {
-		nss_warning("%p: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
+		nss_warning("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
 			ncm, ncm->cm.type, nss_capwap_log_message_types_str[ncm->cm.type],
 			ncm->cm.response, nss_cmn_response_str[ncm->cm.response],
 			ncm->cm.error);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
 		ncm, ncm->cm.type, nss_capwap_log_message_types_str[ncm->cm.type],
 		ncm->cm.response, nss_cmn_response_str[ncm->cm.response],
 		ncm->cm.error, nss_capwap_log_error_response_types_str[ncm->cm.error]);
--- a/nss_capwap_stats.c
+++ b/nss_capwap_stats.c
@@ -117,15 +117,18 @@ static ssize_t nss_capwap_stats_decap(ch
 		tcnt = s->rx_queue_full_drops;
 		return snprintf(line, len, "%s = %llu (n2h = %llu)\n", nss_capwap_strings_decap_stats[i].stats_name, tcnt, s->rx_n2h_queue_full_drops);
 	case 10:
-		tcnt = s->rx_mem_failure_drops;
+		tcnt = s->rx_n2h_queue_full_drops;
 		break;
 	case 11:
-		tcnt = s->rx_csum_drops;
+		tcnt = s->rx_mem_failure_drops;
 		break;
 	case 12:
-		tcnt = s->rx_malformed;
+		tcnt = s->rx_csum_drops;
 		break;
 	case 13:
+		tcnt = s->rx_malformed;
+		break;
+	case 14:
 		tcnt = s->fast_mem;
 		break;
 	default:
--- a/nss_clmap.c
+++ b/nss_clmap.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -88,12 +88,12 @@ static void nss_clmap_msg_handler(struct
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >= NSS_CLMAP_MSG_TYPE_MAX) {
-		nss_warning("%p: received invalid message %d for clmap interface", nss_ctx, ncm->type);
+		nss_warning("%px: received invalid message %d for clmap interface", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_clmap_msg)) {
-		nss_warning("%p: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
@@ -113,7 +113,7 @@ static void nss_clmap_msg_handler(struct
 	 * Update the callback and app_data for NOTIFY messages.
 	 */
 	if (ncm->response == NSS_CMN_RESPONSE_NOTIFY) {
-		ncm->cb = (nss_ptr_t)nss_top_main.if_rx_msg_callback[ncm->interface];
+		ncm->cb = (nss_ptr_t)nss_core_get_msg_handler(nss_ctx, ncm->interface);
 		ncm->app_data = (nss_ptr_t)nss_ctx->nss_rx_interface_handlers[nss_ctx->id][ncm->interface].app_data;
 	}
 
@@ -122,7 +122,7 @@ static void nss_clmap_msg_handler(struct
 	 */
 	cb = (nss_clmap_msg_callback_t)ncm->cb;
 	if (!cb) {
-		nss_trace("%p: cb is null for interface %d", nss_ctx, ncm->interface);
+		nss_trace("%px: cb is null for interface %d", nss_ctx, ncm->interface);
 		return;
 	}
 
@@ -169,14 +169,14 @@ nss_tx_status_t nss_clmap_tx_msg_sync(st
 
 	status = nss_clmap_tx_msg(nss_ctx, nclm);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: clmap_tx_msg failed\n", nss_ctx);
+		nss_warning("%px: clmap_tx_msg failed\n", nss_ctx);
 		up(&clmap_pvt.sem);
 		return status;
 	}
 
 	ret = wait_for_completion_timeout(&clmap_pvt.complete, msecs_to_jiffies(NSS_CLMAP_TX_TIMEOUT));
 	if (!ret) {
-		nss_warning("%p: clmap tx sync failed due to timeout\n", nss_ctx);
+		nss_warning("%px: clmap tx sync failed due to timeout\n", nss_ctx);
 		clmap_pvt.response = NSS_TX_FAILURE;
 	}
 
@@ -205,19 +205,25 @@ EXPORT_SYMBOL(nss_clmap_tx_buf);
 bool nss_clmap_unregister(uint32_t if_num)
 {
 	struct nss_ctx_instance *nss_ctx;
+	int status;
 
 	nss_ctx = nss_clmap_get_ctx();
 	NSS_VERIFY_CTX_MAGIC(nss_ctx);
 
 	if (!nss_clmap_verify_if_num(if_num)) {
-		nss_warning("%p: clmap unregister request received for invalid interface %d", nss_ctx, if_num);
+		nss_warning("%px: clmap unregister request received for invalid interface %d", nss_ctx, if_num);
+		return false;
+	}
+
+	status = nss_core_unregister_msg_handler(nss_ctx, if_num);
+	if (status != NSS_CORE_STATUS_SUCCESS) {
+		nss_warning("%px: Failed to unregister handler for clmap NSS I/F:%u\n", nss_ctx, if_num);
 		return false;
 	}
 
-	nss_clmap_stats_session_unregister(if_num);
-	nss_core_unregister_handler(nss_ctx, if_num);
 	nss_core_unregister_subsys_dp(nss_ctx, if_num);
-	nss_top_main.if_rx_msg_callback[if_num] = NULL;
+	nss_core_unregister_handler(nss_ctx, if_num);
+	nss_clmap_stats_session_unregister(if_num);
 
 	return true;
 }
@@ -242,8 +248,8 @@ struct nss_ctx_instance *nss_clmap_regis
 	NSS_VERIFY_CTX_MAGIC(nss_ctx);
 
 	if (!nss_clmap_verify_if_num(if_num)) {
-		nss_warning("%p: clmap register request received for invalid interface %d", nss_ctx, if_num);
-		return NULL;
+		nss_warning("%px: clmap register request received for invalid interface %d", nss_ctx, if_num);
+		goto fail;
 	}
 
 	if (di_type == NSS_DYNAMIC_INTERFACE_TYPE_CLMAP_US) {
@@ -253,22 +259,33 @@ struct nss_ctx_instance *nss_clmap_regis
 	}
 
 	if (!stats_status) {
-		nss_warning("%p: statistics registration failed for interface: %d\n", nss_ctx, if_num);
-		return NULL;
+		nss_warning("%px: statistics registration failed for interface: %d\n", nss_ctx, if_num);
+		goto fail;
 	}
 
 	core_status = nss_core_register_handler(nss_ctx, if_num, nss_clmap_msg_handler, (void *)netdev);
 	if (core_status != NSS_CORE_STATUS_SUCCESS) {
-		nss_clmap_stats_session_unregister(if_num);
-		nss_warning("%p: NSS core register handler failed for if_num:%d with error :%d", nss_ctx, if_num, core_status);
-		return NULL;
+		goto core_reg_fail;
+	}
+
+	core_status = nss_core_register_msg_handler(nss_ctx, if_num, notify_cb);
+	if (core_status != NSS_CORE_STATUS_SUCCESS) {
+		goto msg_reg_fail;
 	}
 
 	nss_core_register_subsys_dp(nss_ctx, if_num, data_cb, NULL, (void *)netdev, netdev, features);
 	nss_core_set_subsys_dp_type(nss_ctx, netdev, if_num, di_type);
-	nss_top_main.if_rx_msg_callback[if_num] = notify_cb;
 
 	return nss_ctx;
+
+msg_reg_fail:
+	nss_core_unregister_handler(nss_ctx, if_num);
+core_reg_fail:
+	nss_clmap_stats_session_unregister(if_num);
+	nss_warning("%px: NSS core register handler failed for if_num:%d with error :%d", nss_ctx, if_num, core_status);
+fail:
+	return NULL;
+
 }
 EXPORT_SYMBOL(nss_clmap_register);
 
@@ -282,7 +299,7 @@ int nss_clmap_ifnum_with_core_id(int if_
 
 	NSS_VERIFY_CTX_MAGIC(nss_ctx);
 	if (!nss_is_dynamic_interface(if_num)) {
-		nss_warning("%p: Invalid if_num: %d, must be a dynamic interface\n", nss_ctx, if_num);
+		nss_warning("%px: Invalid if_num: %d, must be a dynamic interface\n", nss_ctx, if_num);
 		return 0;
 	}
 	return NSS_INTERFACE_NUM_APPEND_COREID(nss_ctx, if_num);
--- a/nss_clmap_log.c
+++ b/nss_clmap_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -59,7 +59,7 @@ static char *nss_clmap_log_error_types_s
  */
 static void nss_clmap_log_mac_msg(struct nss_clmap_mac_msg *npvcm)
 {
-	nss_trace("%p: NSS clmap MAC message \n"
+	nss_trace("%px: NSS clmap MAC message \n"
 		"Clmap Mac Addr: %x : %x : %x"
 		"Clmap Flags: %u\n"
 		"Clmap VLAN ID: %u\n"
@@ -76,7 +76,7 @@ static void nss_clmap_log_mac_msg(struct
  */
 static void nss_clmap_log_interface_enable_msg(struct nss_clmap_msg *npvm)
 {
-	nss_trace("%p: NSS clmap interface state message: Enable \n", npvm);
+	nss_trace("%px: NSS clmap interface state message: Enable \n", npvm);
 }
 
 /*
@@ -85,7 +85,7 @@ static void nss_clmap_log_interface_enab
  */
 static void nss_clmap_log_interface_disable_msg(struct nss_clmap_msg *npvm)
 {
-	nss_trace("%p: NSS clmap interface state message: Disable \n", npvm);
+	nss_trace("%px: NSS clmap interface state message: Disable \n", npvm);
 }
 
 /*
@@ -115,7 +115,7 @@ static void nss_clmap_log_mac_del_msg(st
 static void nss_clmap_log_mac_flush_msg(struct nss_clmap_msg *npvm)
 {
 	struct nss_clmap_flush_mac_msg *npvcm __maybe_unused = &npvm->msg.mac_flush;
-	nss_trace("%p: NSS clmap MAC flush message \n"
+	nss_trace("%px: NSS clmap MAC flush message \n"
 		"Clmap Next-hop Interface Number: %d\n",
 		npvcm, npvcm->nexthop_ifnum);
 }
@@ -151,7 +151,7 @@ static void nss_clmap_log_verbose(struct
 		break;
 
 	default:
-		nss_trace("%p: Invalid message type\n", npvm);
+		nss_trace("%px: Invalid message type\n", npvm);
 		break;
 	}
 }
@@ -163,11 +163,11 @@ static void nss_clmap_log_verbose(struct
 void nss_clmap_log_tx_msg(struct nss_clmap_msg *npvm)
 {
 	if (npvm->cm.type >= NSS_CLMAP_MSG_TYPE_MAX) {
-		nss_warning("%p: Invalid message type\n", npvm);
+		nss_warning("%px: Invalid message type\n", npvm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", npvm, npvm->cm.type, nss_clmap_log_message_types_str[npvm->cm.type]);
+	nss_info("%px: type[%d]:%s\n", npvm, npvm->cm.type, nss_clmap_log_message_types_str[npvm->cm.type]);
 	nss_clmap_log_verbose(npvm);
 }
 
@@ -178,26 +178,26 @@ void nss_clmap_log_tx_msg(struct nss_clm
 void nss_clmap_log_rx_msg(struct nss_clmap_msg *npvm)
 {
 	if (npvm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", npvm);
+		nss_warning("%px: Invalid response\n", npvm);
 		return;
 	}
 
 	if (npvm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (npvm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", npvm, npvm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", npvm, npvm->cm.type,
 			nss_clmap_log_message_types_str[npvm->cm.type],
 			npvm->cm.response, nss_cmn_response_str[npvm->cm.response]);
 		goto verbose;
 	}
 
 	if (npvm->cm.error >= NSS_CLMAP_ERROR_MAX) {
-		nss_warning("%p: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
+		nss_warning("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
 			npvm, npvm->cm.type, nss_clmap_log_message_types_str[npvm->cm.type],
 			npvm->cm.response, nss_cmn_response_str[npvm->cm.response],
 			npvm->cm.error);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
 		npvm, npvm->cm.type, nss_clmap_log_message_types_str[npvm->cm.type],
 		npvm->cm.response, nss_cmn_response_str[npvm->cm.response],
 		npvm->cm.error, nss_clmap_log_error_types_str[npvm->cm.error]);
--- a/nss_clmap_stats.c
+++ b/nss_clmap_stats.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -79,7 +79,7 @@ bool nss_clmap_stats_session_register(ui
 		if (!stats_db[i]) {
 			stats_db[i] = (struct nss_clmap_stats *)kzalloc(sizeof(struct nss_clmap_stats), GFP_KERNEL);
 			if (!stats_db[i]) {
-				nss_warning("%p: could not allocate memory for statistics database for interface id: %d\n", netdev, if_num);
+				nss_warning("%px: could not allocate memory for statistics database for interface id: %d\n", netdev, if_num);
 				break;
 			}
 			stats_db[i]->valid = true;
@@ -228,7 +228,7 @@ void nss_clmap_stats_sync(struct nss_ctx
 
 	if (!s) {
 		spin_unlock_bh(&nss_clmap_stats_lock);
-		nss_warning("%p: Interface not found: %u", nss_ctx, if_num);
+		nss_warning("%px: Interface not found: %u", nss_ctx, if_num);
 		return;
 	}
 
--- a/nss_cmn.c
+++ b/nss_cmn.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -75,7 +75,7 @@ int32_t nss_cmn_get_interface_number(str
 
 	NSS_VERIFY_CTX_MAGIC(nss_ctx);
 	if (unlikely(nss_ctx->state != NSS_CORE_STATE_INITIALIZED)) {
-		nss_warning("%p: Interface number could not be found as core not ready\n", nss_ctx);
+		nss_warning("%px: Interface number could not be found as core not ready\n", nss_ctx);
 		return -1;
 	}
 
@@ -90,7 +90,7 @@ int32_t nss_cmn_get_interface_number(str
 		}
 	}
 
-	nss_warning("%p: Interface number could not be found as interface has not registered yet\n", nss_ctx);
+	nss_warning("%px: Interface number could not be found as interface has not registered yet\n", nss_ctx);
 	return -1;
 }
 EXPORT_SYMBOL(nss_cmn_get_interface_number);
@@ -119,7 +119,7 @@ struct net_device *nss_cmn_get_interface
 
 	NSS_VERIFY_CTX_MAGIC(nss_ctx);
 	if (unlikely(nss_ctx->state != NSS_CORE_STATE_INITIALIZED)) {
-		nss_warning("%p: Interface device could not be found as core not ready\n", nss_ctx);
+		nss_warning("%px: Interface device could not be found as core not ready\n", nss_ctx);
 		return NULL;
 	}
 
@@ -152,7 +152,7 @@ int32_t nss_cmn_get_interface_number_by_
 		}
 	}
 
-	nss_warning("Interface number could not be found for %p (%s) as interface has not registered yet\n", dev, dev->name);
+	nss_warning("Interface number could not be found for %px (%s) as interface has not registered yet\n", dev, dev->name);
 	return -1;
 }
 EXPORT_SYMBOL(nss_cmn_get_interface_number_by_dev_and_type);
@@ -287,7 +287,7 @@ nss_cb_register_status_t nss_cmn_registe
 		/*
 		 * We already have a callback registered for this service code.
 		 */
-		nss_warning("%p: a callback is registered already for this service code %d\n", nss_ctx, service_code);
+		nss_warning("%px: a callback is registered already for this service code %d\n", nss_ctx, service_code);
 
 		return NSS_CB_REGISTER_FAILED;
 	}
@@ -310,7 +310,7 @@ nss_cb_unregister_status_t nss_cmn_unreg
 		/*
 		 * No callback was registered for this service code.
 		 */
-		nss_warning("%p: no callback is registered for this service code %d\n", nss_ctx, service_code);
+		nss_warning("%px: no callback is registered for this service code %d\n", nss_ctx, service_code);
 		return NSS_CB_UNREGISTER_FAILED;
 	}
 
--- a/nss_core.c
+++ b/nss_core.c
@@ -382,7 +382,7 @@ void nss_core_handle_nss_status_pkt(stru
 	 * Check for version number
 	 */
 	if (ncm->version != expected_version) {
-		nss_warning("%p: Message %d for interface %d received with invalid version %d, expected version %d",
+		nss_warning("%px: Message %d for interface %d received with invalid version %d, expected version %d",
 							nss_ctx, ncm->type, nss_if, ncm->version, expected_version);
 		return;
 	}
@@ -391,7 +391,7 @@ void nss_core_handle_nss_status_pkt(stru
 	 * Validate message size
 	 */
 	if (ncm->len > nbuf->len) {
-		nss_warning("%p: Message %d for interface %d received with invalid length %d, expected length %d",
+		nss_warning("%px: Message %d for interface %d received with invalid length %d, expected length %d",
 							nss_ctx, ncm->type, nss_if, nbuf->len, ncm->len);
 		return;
 	}
@@ -400,7 +400,7 @@ void nss_core_handle_nss_status_pkt(stru
 	 * Check for validity of interface number
 	 */
 	if (nss_if >= NSS_MAX_NET_INTERFACES) {
-		nss_warning("%p: Message %d received with invalid interface number %d", nss_ctx, ncm->type, nss_if);
+		nss_warning("%px: Message %d received with invalid interface number %d", nss_ctx, ncm->type, nss_if);
 		return;
 	}
 
@@ -408,14 +408,14 @@ void nss_core_handle_nss_status_pkt(stru
 	app_data = nss_ctx->nss_rx_interface_handlers[nss_ctx->id][nss_if].app_data;
 
 	if (!cb) {
-		nss_warning("%p: Callback not registered for interface %d", nss_ctx, nss_if);
+		nss_warning("%px: Callback not registered for interface %d", nss_ctx, nss_if);
 		return;
 	}
 
 	cb(nss_ctx, ncm, app_data);
 
 	if (ncm->interface != nss_if) {
-		nss_warning("%p: Invalid NSS I/F %d expected %d", nss_ctx, ncm->interface, nss_if);
+		nss_warning("%px: Invalid NSS I/F %d expected %d", nss_ctx, ncm->interface, nss_if);
 	}
 
 	return;
@@ -465,16 +465,16 @@ static uint32_t nss_soc_mem_info(void)
 
 	ppp = (__be32 *)of_get_property(node, "#address-cells", NULL);
 	addr_cells = ppp ? be32_to_cpup(ppp) : 2;
-	nss_info("%p addr cells %d\n", ppp, addr_cells);
+	nss_info("%px addr cells %d\n", ppp, addr_cells);
 	ppp = (__be32 *)of_get_property(node, "#size-cells", NULL);
 	size_cells = ppp ? be32_to_cpup(ppp) : 2;
-	nss_info("%p size cells %d\n", ppp, size_cells);
+	nss_info("%px size cells %d\n", ppp, size_cells);
 
 	for_each_child_of_node(node, snode) {
 		/*
 		 * compare (snode->full_name, "/reserved-memory/nss@40000000") may be safer
 		 */
-		nss_info("%p snode %s fn %s\n", snode, snode->name, snode->full_name);
+		nss_info("%px snode %s fn %s\n", snode, snode->name, snode->full_name);
 		if (strcmp(snode->name, "nss") == 0)
 			break;
 	}
@@ -510,8 +510,9 @@ static void nss_get_ddr_info(struct nss_
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 5, 0))
 	cached = global_page_state(NR_FILE_PAGES);
 #else
-	cached = global_zone_page_state(NR_FILE_PAGES);
+	cached = global_node_page_state(NR_FILE_PAGES);
 #endif
+
 	avail_ddr = (vals.totalram + cached + vals.sharedram) * vals.mem_unit;
 	mmu->num_active_cores = nss_top_main.num_nss;
 
@@ -570,7 +571,7 @@ case3:
 			}
 		}
 		of_node_put(node);
-		nss_info_always("incorrect memory info %p items %d\n",
+		nss_info_always("incorrect memory info %px items %d\n",
 			ppp, n_items);
 	}
 
@@ -600,7 +601,7 @@ static void nss_send_ddr_info(struct nss
 	struct nss_n2h_msg nnm;
 	struct nss_cmn_msg *ncm = &nnm.cm;
 	uint32_t ret;
-	nss_info("%p: send DDR info\n", nss_own);
+	nss_info("%px: send DDR info\n", nss_own);
 
 	nss_cmn_msg_init(ncm, NSS_N2H_INTERFACE, NSS_TX_DDR_INFO_VIA_N2H_CFG,
 			sizeof(struct nss_mmu_ddr_info), NULL, NULL);
@@ -610,7 +611,7 @@ static void nss_send_ddr_info(struct nss
 
 	ret = nss_core_send_cmd(nss_own, &nnm, sizeof(nnm), NSS_NBUF_PAYLOAD_SIZE);
 	if (ret != NSS_TX_SUCCESS) {
-		nss_info_always("%p: Failed to send DDR info for core %d\n", nss_own, nss_own->id);
+		nss_info_always("%px: Failed to send DDR info for core %d\n", nss_own, nss_own->id);
 	}
 }
 
@@ -654,7 +655,7 @@ static inline uint16_t nss_core_cause_to
 static inline void nss_dump_desc(struct nss_ctx_instance *nss_ctx, struct n2h_descriptor *desc)
 {
 	printk("bad descriptor dump for nss core = %d\n", nss_ctx->id);
-	printk("\topaque = %p\n", (void *)desc->opaque);
+	printk("\topaque = %px\n", (void *)desc->opaque);
 	printk("\tinterface = %d\n", desc->interface_num);
 	printk("\tbuffer_type = %d\n", desc->buffer_type);
 	printk("\tbit_flags = %x\n", desc->bit_flags);
@@ -760,7 +761,7 @@ static inline void nss_core_handle_virt_
 	 */
 	ndev = subsys_dp_reg->ndev;
 	if (unlikely(!ndev)) {
-		nss_warning("%p: Received packet for unregistered virtual interface %d",
+		nss_warning("%px: Received packet for unregistered virtual interface %d",
 			nss_ctx, interface_num);
 
 		/*
@@ -831,7 +832,7 @@ static inline void nss_core_handle_virt_
 	xmit_ret = ndev->netdev_ops->ndo_start_xmit(nbuf, ndev);
 	if (unlikely(xmit_ret == NETDEV_TX_BUSY)) {
 		dev_kfree_skb_any(nbuf);
-		nss_info("%p: Congestion at virtual interface %d, %p", nss_ctx, interface_num, ndev);
+		nss_info("%px: Congestion at virtual interface %d, %px", nss_ctx, interface_num, ndev);
 	}
 	dev_put(ndev);
 }
@@ -983,7 +984,7 @@ static inline void nss_core_rx_pbuf(stru
 
 	if (interface_num >= NSS_MAX_NET_INTERFACES) {
 		NSS_PKT_STATS_INC(&nss_ctx->nss_top->stats_drv[NSS_DRV_STATS_RX_INVALID_INTERFACE]);
-		nss_warning("%p: Invalid interface_num: %d", nss_ctx, interface_num);
+		nss_warning("%px: Invalid interface_num: %d", nss_ctx, interface_num);
 		dev_kfree_skb_any(nbuf);
 		return;
 	}
@@ -993,7 +994,7 @@ static inline void nss_core_rx_pbuf(stru
 	 */
 	if (core_id > nss_top_main.num_nss) {
 		NSS_PKT_STATS_INC(&nss_ctx->nss_top->stats_drv[NSS_DRV_STATS_RX_INVALID_CORE_ID]);
-		nss_warning("%p: Invalid core id: %d", nss_ctx, core_id);
+		nss_warning("%px: Invalid core id: %d", nss_ctx, core_id);
 		dev_kfree_skb_any(nbuf);
 		return;
 	}
@@ -1052,14 +1053,14 @@ static inline void nss_core_rx_pbuf(stru
 		status = nss_core_send_buffer(nss_ctx, 0, nbuf, NSS_IF_H2N_DATA_QUEUE, H2N_BUFFER_RATE_TEST, H2N_BIT_FLAG_BUFFER_REUSABLE);
 		if (unlikely(status != NSS_CORE_STATUS_SUCCESS)) {
 			dev_kfree_skb_any(nbuf);
-			nss_warning("%p: Unable to enqueue\n", nss_ctx);
+			nss_warning("%px: Unable to enqueue\n", nss_ctx);
 		}
 		nss_hal_send_interrupt(nss_ctx, NSS_H2N_INTR_DATA_COMMAND_QUEUE);
 		break;
 
 	default:
 		NSS_PKT_STATS_INC(&nss_ctx->nss_top->stats_drv[NSS_DRV_STATS_RX_INVALID_BUFFER_TYPE]);
-		nss_warning("%p: Invalid buffer type %d received from NSS", nss_ctx, buffer_type);
+		nss_warning("%px: Invalid buffer type %d received from NSS", nss_ctx, buffer_type);
 		dev_kfree_skb_any(nbuf);
 	}
 }
@@ -1092,7 +1093,7 @@ static inline bool nss_core_handle_nr_fr
 		 * Free the old head as the frag list is corrupt.
 		 */
 		if (unlikely(jumbo_start)) {
-			nss_warning("%p: received a full frame before a last", jumbo_start);
+			nss_warning("%px: received a full frame before a last", jumbo_start);
 			dev_kfree_skb_any(jumbo_start);
 			*jumbo_start_ptr = NULL;
 		}
@@ -1139,7 +1140,7 @@ static inline bool nss_core_handle_nr_fr
 		 * Free the old head as the frag list is corrupt.
 		 */
 		if (unlikely(jumbo_start)) {
-			nss_warning("%p: received the second head before a last", jumbo_start);
+			nss_warning("%px: received the second head before a last", jumbo_start);
 			dev_kfree_skb_any(jumbo_start);
 		}
 
@@ -1182,7 +1183,7 @@ static inline bool nss_core_handle_nr_fr
 		/*
 		 * Middle before first! Free the middle.
 		 */
-		nss_warning("%p: saw a middle skb before head", nbuf);
+		nss_warning("%px: saw a middle skb before head", nbuf);
 		dev_kfree_skb_any(nbuf);
 		return false;
 	}
@@ -1220,7 +1221,7 @@ pull:
 	if (buffer_type != N2H_BUFFER_STATUS) {
 		if (!pskb_may_pull(nbuf, ETH_HLEN)) {
 			dev_kfree_skb(nbuf);
-			nss_warning("%p: could not pull eth header", nbuf);
+			nss_warning("%px: could not pull eth header", nbuf);
 			return false;
 		}
 	}
@@ -1259,7 +1260,7 @@ static inline bool nss_core_handle_linea
 		 * Free the old head as the frag list is corrupt.
 		 */
 		if (unlikely(head)) {
-			nss_warning("%p: received a full frame before a last", head);
+			nss_warning("%px: received a full frame before a last", head);
 			dev_kfree_skb_any(head);
 			*head_ptr = NULL;
 		}
@@ -1301,7 +1302,7 @@ static inline bool nss_core_handle_linea
 		 * Free the old head as the frag list is corrupt.
 		 */
 		if (unlikely(head)) {
-			nss_warning("%p: received the second head before a last", head);
+			nss_warning("%px: received the second head before a last", head);
 			NSS_PKT_STATS_DEC(&nss_ctx->nss_top->stats_drv[NSS_DRV_STATS_NSS_SKB_COUNT]);
 			dev_kfree_skb_any(head);
 		}
@@ -1313,7 +1314,7 @@ static inline bool nss_core_handle_linea
 			/*
 			 * We don't support chain in a chain.
 			 */
-			nss_warning("%p: skb already has a fraglist", nbuf);
+			nss_warning("%px: skb already has a fraglist", nbuf);
 			NSS_PKT_STATS_DEC(&nss_ctx->nss_top->stats_drv[NSS_DRV_STATS_NSS_SKB_COUNT]);
 			dev_kfree_skb_any(nbuf);
 			return false;
@@ -1353,7 +1354,7 @@ static inline bool nss_core_handle_linea
 		/*
 		 * Middle before first! Free the middle.
 		 */
-		nss_warning("%p: saw a middle skb before head", nbuf);
+		nss_warning("%px: saw a middle skb before head", nbuf);
 		dev_kfree_skb_any(nbuf);
 
 		return false;
@@ -1613,8 +1614,8 @@ static int32_t nss_core_handle_cause_que
 			 * a linear skb chain. If so we need to free.
 			 */
 			if (unlikely(n2h_desc_ring->head)) {
-				nss_warning("%p: we should not have an incomplete paged skb while"
-								" constructing a linear skb %p", nbuf, n2h_desc_ring->head);
+				nss_warning("%px: we should not have an incomplete paged skb while"
+								" constructing a linear skb %px", nbuf, n2h_desc_ring->head);
 
 				NSS_PKT_STATS_DEC(&nss_ctx->nss_top->stats_drv[NSS_DRV_STATS_NSS_SKB_COUNT]);
 				dev_kfree_skb_any(n2h_desc_ring->head);
@@ -1633,8 +1634,8 @@ static int32_t nss_core_handle_cause_que
 		 * a paged skb. If so we need to free the paged_skb and handle the linear skb.
 		 */
 		if (unlikely(n2h_desc_ring->jumbo_start)) {
-			nss_warning("%p: we should not have an incomplete linear skb while"
-							" constructing a paged skb %p", nbuf, n2h_desc_ring->jumbo_start);
+			nss_warning("%px: we should not have an incomplete linear skb while"
+							" constructing a paged skb %px", nbuf, n2h_desc_ring->jumbo_start);
 
 			NSS_PKT_STATS_DEC(&nss_ctx->nss_top->stats_drv[NSS_DRV_STATS_NSS_SKB_COUNT]);
 			dev_kfree_skb_any(n2h_desc_ring->jumbo_start);
@@ -1727,7 +1728,7 @@ static void nss_core_init_nss(struct nss
 		 */
 		ret = nss_n2h_cfg_empty_pool_size(nss_ctx, NSS_LOW_MEM_EMPTY_POOL_BUF_SZ);
 		if (ret != NSS_TX_SUCCESS) {
-			nss_warning("%p: Failed to update empty buffer pool config\n", nss_ctx);
+			nss_warning("%px: Failed to update empty buffer pool config\n", nss_ctx);
 		}
 #endif
 	} else {
@@ -1765,7 +1766,7 @@ static void nss_core_alloc_paged_buffers
 			 * ERR:
 			 */
 			NSS_PKT_STATS_INC(&nss_top->stats_drv[alloc_fail_count]);
-			nss_warning("%p: Could not obtain empty paged buffer", nss_ctx);
+			nss_warning("%px: Could not obtain empty paged buffer", nss_ctx);
 			break;
 		}
 
@@ -1776,7 +1777,7 @@ static void nss_core_alloc_paged_buffers
 			 */
 			dev_kfree_skb_any(nbuf);
 			NSS_PKT_STATS_INC(&nss_top->stats_drv[alloc_fail_count]);
-			nss_warning("%p: Could not obtain empty page", nss_ctx);
+			nss_warning("%px: Could not obtain empty page", nss_ctx);
 			break;
 		}
 
@@ -1799,7 +1800,7 @@ static void nss_core_alloc_paged_buffers
 			 * ERR:
 			 */
 			dev_kfree_skb_any(nbuf);
-			nss_warning("%p: DMA mapping failed for empty buffer", nss_ctx);
+			nss_warning("%px: DMA mapping failed for empty buffer", nss_ctx);
 			break;
 		}
 		/*
@@ -1857,7 +1858,7 @@ static void nss_core_alloc_jumbo_mru_buf
 			 * ERR:
 			 */
 			NSS_PKT_STATS_INC(&nss_top->stats_drv[NSS_DRV_STATS_NBUF_ALLOC_FAILS]);
-			nss_warning("%p: Could not obtain empty jumbo mru buffer", nss_ctx);
+			nss_warning("%px: Could not obtain empty jumbo mru buffer", nss_ctx);
 			break;
 		}
 
@@ -1872,7 +1873,7 @@ static void nss_core_alloc_jumbo_mru_buf
 			 * ERR:
 			 */
 			dev_kfree_skb_any(nbuf);
-			nss_warning("%p: DMA mapping failed for empty buffer", nss_ctx);
+			nss_warning("%px: DMA mapping failed for empty buffer", nss_ctx);
 			break;
 		}
 
@@ -1933,7 +1934,7 @@ static void nss_core_alloc_max_avail_siz
 			 * ERR:
 			 */
 			NSS_PKT_STATS_INC(&nss_top->stats_drv[NSS_DRV_STATS_NBUF_ALLOC_FAILS]);
-			nss_warning("%p: Could not obtain empty buffer", nss_ctx);
+			nss_warning("%px: Could not obtain empty buffer", nss_ctx);
 			break;
 		}
 
@@ -1947,7 +1948,7 @@ static void nss_core_alloc_max_avail_siz
 			 * ERR:
 			 */
 			dev_kfree_skb_any(nbuf);
-			nss_warning("%p: DMA mapping failed for empty buffer", nss_ctx);
+			nss_warning("%px: DMA mapping failed for empty buffer", nss_ctx);
 			break;
 		}
 
@@ -2024,7 +2025,7 @@ static inline void nss_core_handle_empty
 	mask = size - 1;
 	count = ((nss_index - hlos_index - 1) + size) & (mask);
 
-	nss_trace("%p: Adding %d buffers to empty queue\n", nss_ctx, count);
+	nss_trace("%px: Adding %d buffers to empty queue\n", nss_ctx, count);
 
 	/*
 	 * Fill empty buffer queue with buffers leaving one empty descriptor
@@ -2075,7 +2076,7 @@ static inline void nss_core_handle_paged
 
 	mask = size - 1;
 	count = ((nss_index - hlos_index - 1) + size) & (mask);
-	nss_trace("%p: Adding %d buffers to paged buffer queue", nss_ctx, count);
+	nss_trace("%px: Adding %d buffers to paged buffer queue", nss_ctx, count);
 
 	/*
 	 * Fill empty buffer queue with buffers leaving one empty descriptor
@@ -2102,7 +2103,7 @@ static inline void nss_core_handle_paged
 static inline void nss_core_handle_tx_unblocked(struct nss_ctx_instance *nss_ctx)
 {
 	int32_t i;
-	nss_trace("%p: Data queue unblocked", nss_ctx);
+	nss_trace("%px: Data queue unblocked", nss_ctx);
 
 	/*
 	 * Call callback functions of drivers that have registered with us
@@ -2154,7 +2155,7 @@ static void nss_core_handle_cause_nonque
 		nss_core_init_nss(nss_ctx, if_map);
 		nss_send_ddr_info(nss_ctx);
 
-		nss_info_always("%p: nss core %d booted successfully\n", nss_ctx, nss_ctx->id);
+		nss_info_always("%px: nss core %d booted successfully\n", nss_ctx, nss_ctx->id);
 		nss_top = nss_ctx->nss_top;
 
 #ifdef NSS_DRV_C2C_ENABLE
@@ -2349,7 +2350,7 @@ int nss_core_handle_napi(struct napi_str
 				break;
 
 			default:
-				nss_warning("%p: Invalid cause %x received from nss", nss_ctx, int_cause);
+				nss_warning("%px: Invalid cause %x received from nss", nss_ctx, int_cause);
 				nss_assert(0);
 				break;
 			}
@@ -2706,7 +2707,7 @@ no_reuse:
 	bit_flags &= ~H2N_BIT_FLAG_BUFFER_REUSABLE;
 	frag0phyaddr = nss_core_dma_map_single(nss_ctx->dev, nbuf);
 	if (unlikely(dma_mapping_error(nss_ctx->dev, frag0phyaddr))) {
-		nss_warning("%p: DMA mapping failed for virtual address = %p", nss_ctx, nbuf->head);
+		nss_warning("%px: DMA mapping failed for virtual address = %px", nss_ctx, nbuf->head);
 		return 0;
 	}
 
@@ -2742,7 +2743,7 @@ static inline int32_t nss_core_send_buff
 
 	uint32_t frag0phyaddr = nss_core_dma_map_single(nss_ctx->dev, nbuf);
 	if (unlikely(dma_mapping_error(nss_ctx->dev, frag0phyaddr))) {
-		nss_warning("%p: DMA mapping failed for virtual address = %p", nss_ctx, nbuf->head);
+		nss_warning("%px: DMA mapping failed for virtual address = %px", nss_ctx, nbuf->head);
 		return 0;
 	}
 
@@ -2782,7 +2783,7 @@ static inline int32_t nss_core_send_buff
 
 		buffer = skb_frag_dma_map(nss_ctx->dev, frag, 0, skb_frag_size(frag), DMA_TO_DEVICE);
 		if (unlikely(dma_mapping_error(nss_ctx->dev, buffer))) {
-			nss_warning("%p: DMA mapping failed for fragment", nss_ctx);
+			nss_warning("%px: DMA mapping failed for fragment", nss_ctx);
 			nss_core_send_unwind_dma(nss_ctx->dev, desc_if, hlos_index, i + 1, false);
 			return -(i + 1);
 		}
@@ -2837,7 +2838,7 @@ static inline int32_t nss_core_send_buff
 
 	uint32_t frag0phyaddr = nss_core_dma_map_single(nss_ctx->dev, nbuf);
 	if (unlikely(dma_mapping_error(nss_ctx->dev, frag0phyaddr))) {
-		nss_warning("%p: DMA mapping failed for virtual address = %p", nss_ctx, nbuf->head);
+		nss_warning("%px: DMA mapping failed for virtual address = %px", nss_ctx, nbuf->head);
 		return 0;
 	}
 
@@ -2876,7 +2877,7 @@ static inline int32_t nss_core_send_buff
 
 		buffer = nss_core_dma_map_single(nss_ctx->dev, iter);
 		if (unlikely(dma_mapping_error(nss_ctx->dev, buffer))) {
-			nss_warning("%p: DMA mapping failed for virtual address = %p", nss_ctx, iter->head);
+			nss_warning("%px: DMA mapping failed for virtual address = %px", nss_ctx, iter->head);
 			nss_core_send_unwind_dma(nss_ctx->dev, desc_if, hlos_index, i + 1, true);
 			return -(i+1);
 		}
@@ -2887,7 +2888,7 @@ static inline int32_t nss_core_send_buff
 		 */
 		nr_frags = skb_shinfo(iter)->nr_frags;
 		if (unlikely(nr_frags > 0)) {
-			nss_warning("%p: fraglist with page data are not supported: %p\n", nss_ctx, iter);
+			nss_warning("%px: fraglist with page data are not supported: %px\n", nss_ctx, iter);
 			nss_core_send_unwind_dma(nss_ctx->dev, desc_if, hlos_index, i + 1, true);
 			return -(i+1);
 		}
@@ -2994,7 +2995,7 @@ int32_t nss_core_send_buffer(struct nss_
 		 * Check that segments do not overflow the number of descriptors
 		 */
 		if (unlikely(segments > size)) {
-			nss_warning("%p: Unable to fit in skb - %d segments in our descriptors", nss_ctx, segments);
+			nss_warning("%px: Unable to fit in skb - %d segments in our descriptors", nss_ctx, segments);
 			return NSS_CORE_STATUS_FAILURE;
 		}
 	}
@@ -3025,7 +3026,7 @@ int32_t nss_core_send_buffer(struct nss_
 		h2n_desc_ring->tx_q_full_cnt++;
 		h2n_desc_ring->flags |= NSS_H2N_DESC_RING_FLAGS_TX_STOPPED;
 		spin_unlock_bh(&h2n_desc_ring->lock);
-		nss_warning("%p: Data/Command Queue full reached", nss_ctx);
+		nss_warning("%px: Data/Command Queue full reached", nss_ctx);
 
 #if (NSS_PKT_STATS_ENABLED == 1)
 		if (nss_ctx->id == NSS_CORE_0) {
@@ -3033,7 +3034,7 @@ int32_t nss_core_send_buffer(struct nss_
 		} else if (nss_ctx->id == NSS_CORE_1) {
 			NSS_PKT_STATS_INC(&nss_ctx->nss_top->stats_drv[NSS_DRV_STATS_TX_QUEUE_FULL_1]);
 		} else {
-			nss_warning("%p: Invalid nss core: %d\n", nss_ctx, nss_ctx->id);
+			nss_warning("%px: Invalid nss core: %d\n", nss_ctx, nss_ctx->id);
 		}
 #endif
 
@@ -3091,7 +3092,7 @@ int32_t nss_core_send_buffer(struct nss_
 		/*
 		 * We failed and hence we need to unmap dma regions
 		 */
-		nss_warning("%p: failed to map DMA regions:%d", nss_ctx, -count);
+		nss_warning("%px: failed to map DMA regions:%d", nss_ctx, -count);
 		spin_unlock_bh(&h2n_desc_ring->lock);
 		return NSS_CORE_STATUS_FAILURE;
 	}
@@ -3145,18 +3146,18 @@ int32_t nss_core_send_cmd(struct nss_ctx
 
 	NSS_VERIFY_CTX_MAGIC(nss_ctx);
 	if (unlikely(nss_ctx->state != NSS_CORE_STATE_INITIALIZED)) {
-		nss_warning("%p: interface: %d type: %d message dropped as core not ready\n", nss_ctx, ncm->interface, ncm->type);
+		nss_warning("%px: interface: %d type: %d message dropped as core not ready\n", nss_ctx, ncm->interface, ncm->type);
 		return NSS_TX_FAILURE_NOT_READY;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > size) {
-		nss_warning("%p: interface: %d type: %d message length %d is invalid, size = %d\n",
+		nss_warning("%px: interface: %d type: %d message length %d is invalid, size = %d\n",
 					nss_ctx, ncm->interface, ncm->type, nss_cmn_get_msg_len(ncm), size);
 		return NSS_TX_FAILURE_TOO_LARGE;
 	}
 
 	if (buf_size > PAGE_SIZE) {
-		nss_warning("%p: interface: %d type: %d tx request size too large: %u",
+		nss_warning("%px: interface: %d type: %d tx request size too large: %u",
 					nss_ctx, ncm->interface, ncm->type, buf_size);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
@@ -3164,7 +3165,7 @@ int32_t nss_core_send_cmd(struct nss_ctx
 	nbuf = dev_alloc_skb(buf_size);
 	if (unlikely(!nbuf)) {
 		NSS_PKT_STATS_INC(&nss_ctx->nss_top->stats_drv[NSS_DRV_STATS_NBUF_ALLOC_FAILS]);
-		nss_warning("%p: interface: %d type: %d msg dropped as command allocation failed", nss_ctx, ncm->interface, ncm->type);
+		nss_warning("%px: interface: %d type: %d msg dropped as command allocation failed", nss_ctx, ncm->interface, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
@@ -3174,7 +3175,7 @@ int32_t nss_core_send_cmd(struct nss_ctx
 	if (status != NSS_CORE_STATUS_SUCCESS) {
 		dev_kfree_skb_any(nbuf);
 		NSS_PKT_STATS_INC(&nss_ctx->nss_top->stats_drv[NSS_DRV_STATS_TX_CMD_QUEUE_FULL]);
-		nss_warning("%p: interface: %d type: %d unable to enqueue message status %d\n", nss_ctx, ncm->interface, ncm->type, status);
+		nss_warning("%px: interface: %d type: %d unable to enqueue message status %d\n", nss_ctx, ncm->interface, ncm->type, status);
 		return status;
 	}
 
@@ -3194,7 +3195,7 @@ int32_t nss_core_send_packet(struct nss_
 
 	NSS_VERIFY_CTX_MAGIC(nss_ctx);
 	if (unlikely(nss_ctx->state != NSS_CORE_STATE_INITIALIZED)) {
-		nss_warning("%p: interface: %d packet dropped as core not ready\n", nss_ctx, if_num);
+		nss_warning("%px: interface: %d packet dropped as core not ready\n", nss_ctx, if_num);
 		return NSS_TX_FAILURE_NOT_READY;
 	}
 
@@ -3206,7 +3207,7 @@ int32_t nss_core_send_packet(struct nss_
 #endif
 	status = nss_core_send_buffer(nss_ctx, if_num, nbuf, NSS_IF_H2N_DATA_QUEUE + queue_id, H2N_BUFFER_PACKET, flag);
 	if (status != NSS_CORE_STATUS_SUCCESS) {
-		nss_warning("%p: interface: %d unable to enqueue packet status %d\n", nss_ctx, if_num, status);
+		nss_warning("%px: interface: %d unable to enqueue packet status %d\n", nss_ctx, if_num, status);
 		return status;
 	}
 
--- a/nss_core.h
+++ b/nss_core.h
@@ -556,12 +556,11 @@ struct nss_top_instance {
 	uint8_t tls_handler_id;
 	uint8_t mirror_handler_id;
 	uint8_t wmdb_handler_id;
+	uint8_t dma_handler_id;
 
 	/*
 	 * Data/Message callbacks for various interfaces
 	 */
-	nss_if_rx_msg_callback_t if_rx_msg_callback[NSS_MAX_NET_INTERFACES];
-					/* All interfaces message callback functions */
 	nss_phys_if_msg_callback_t phys_if_msg_callback[NSS_MAX_PHYSICAL_INTERFACES];
 					/* Physical interface event callback functions */
 	nss_virt_if_msg_callback_t virt_if_msg_callback[NSS_MAX_VIRTUAL_INTERFACES];
@@ -909,7 +908,7 @@ static inline void nss_core_log_msg_fail
 	/*
 	 * TODO: Is it worth doing value to name on these values?
 	 */
-	nss_warning("%p: msg failure - interface: %d, type: %d, response: %d, error: %d",
+	nss_warning("%px: msg failure - interface: %d, type: %d, response: %d, error: %d",
 		nss_ctx, ncm->interface, ncm->type, ncm->response, ncm->error);
 }
 
--- a/nss_coredump.c
+++ b/nss_coredump.c
@@ -79,7 +79,7 @@ static int nss_panic_handler(struct noti
 			continue;
 		nss_ctx->state |= NSS_CORE_STATE_PANIC;
 		nss_hal_send_interrupt(nss_ctx, NSS_H2N_INTR_TRIGGER_COREDUMP);
-		nss_warning("panic call NSS FW %p to dump %x\n",
+		nss_warning("panic call NSS FW %px to dump %x\n",
 			nss_ctx->nmap, nss_ctx->state);
 	}
 
@@ -138,7 +138,7 @@ void nss_fw_coredump_notify(struct nss_c
 	dma_addr_t dma_addr;
 	uint32_t offset, index;
 
-	nss_warning("%p: COREDUMP %x Baddr %p stat %x",
+	nss_warning("%px: COREDUMP %x Baddr %px stat %x",
 			nss_own, intr, nss_own->nmap, nss_own->state);
 	nss_own->state |= NSS_CORE_STATE_FW_DEAD;
 	queue_delayed_work(coredump_workqueue, &coredump_queuewait,
@@ -161,7 +161,7 @@ void nss_fw_coredump_notify(struct nss_c
 	 * only print whatever is in the buffer. Otherwise, dump last NSS_LOG_COREDUMP_LINE_NUM
 	 * to the dmessage.
 	 */
-	nss_info_always("%p: Starting NSS-FW logbuffer dump for core %u\n",
+	nss_info_always("%px: Starting NSS-FW logbuffer dump for core %u\n",
 			nss_own, nss_own->id);
 	nle_init = nld->log_ring_buffer;
 	if (nld->current_entry <= NSS_LOG_COREDUMP_LINE_NUM) {
@@ -183,7 +183,7 @@ void nss_fw_coredump_notify(struct nss_c
 			+ offsetof(struct nss_log_descriptor, log_ring_buffer);
 		dma_sync_single_for_cpu(nss_own->dev, dma_addr + offset,
 				sizeof(struct nss_log_entry), DMA_FROM_DEVICE);
-		nss_info_always("%p: %s\n", nss_own, nle_print->message);
+		nss_info_always("%px: %s\n", nss_own, nle_print->message);
 		nle_print++;
 	}
 
@@ -223,7 +223,7 @@ void nss_fw_coredump_notify(struct nss_c
 		 * Notify any live core to dump.
 		 */
 		if (!(nss_ctx->state & NSS_CORE_STATE_FW_DEAD) && nss_ctx->nmap) {
-			nss_warning("notify NSS FW %p for coredump\n", nss_ctx->nmap);
+			nss_warning("notify NSS FW %px for coredump\n", nss_ctx->nmap);
 			nss_hal_send_interrupt(nss_ctx, NSS_H2N_INTR_TRIGGER_COREDUMP);
 			continue;
 		}
--- a/nss_crypto.c
+++ b/nss_crypto.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2013,2015-2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2013,2015-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -67,22 +67,22 @@ static void nss_crypto_msg_handler(struc
 	 * Sanity check the message type
 	 */
 	if (ncm->type > NSS_CRYPTO_MSG_TYPE_MAX) {
-		nss_warning("%p: rx message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: rx message type out of range: %d", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_crypto_msg)) {
-		nss_warning("%p: rx message length is invalid: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: rx message length is invalid: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
 	if (ncm->interface != NSS_CRYPTO_INTERFACE) {
-		nss_warning("%p: rx message request for another interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: rx message request for another interface: %d", nss_ctx, ncm->interface);
 		return;
 	}
 
 	if (ncm->response == NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: rx message response for if %d, type %d, is invalid: %d", nss_ctx, ncm->interface,
+		nss_warning("%px: rx message response for if %d, type %d, is invalid: %d", nss_ctx, ncm->interface,
 				ncm->type, ncm->response);
 		return;
 	}
@@ -92,7 +92,6 @@ static void nss_crypto_msg_handler(struc
 		ncm->app_data = (nss_ptr_t)crypto_ctx;
 	}
 
-
 	nss_core_log_msg_failures(nss_ctx, ncm);
 
 	/*
@@ -105,7 +104,7 @@ static void nss_crypto_msg_handler(struc
 	 */
 	cb = (nss_crypto_msg_callback_t)ncm->cb;
 	if (unlikely(!cb)) {
-		nss_trace("%p: rx handler has been unregistered for i/f: %d", nss_ctx, ncm->interface);
+		nss_trace("%px: rx handler has been unregistered for i/f: %d", nss_ctx, ncm->interface);
 		return;
 	}
 	cb((void *)ncm->app_data, nim);
@@ -124,20 +123,20 @@ nss_tx_status_t nss_crypto_tx_msg(struct
 {
 	struct nss_cmn_msg *ncm = &msg->cm;
 
-	nss_info("%p: tx message %d for if %d\n", nss_ctx, ncm->type, ncm->interface);
+	nss_info("%px: tx message %d for if %d\n", nss_ctx, ncm->type, ncm->interface);
 
 	BUILD_BUG_ON(NSS_NBUF_PAYLOAD_SIZE < sizeof(struct nss_crypto_msg));
 
 	if (ncm->interface != NSS_CRYPTO_INTERFACE) {
-		nss_warning("%p: tx message request for another interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: tx message request for another interface: %d", nss_ctx, ncm->interface);
 	}
 
 	if (ncm->type > NSS_CRYPTO_MSG_TYPE_MAX) {
-		nss_warning("%p: tx message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: tx message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
-	nss_info("msg params version:%d, interface:%d, type:%d, cb:%p, app_data:%p, len:%d\n",
+	nss_info("msg params version:%d, interface:%d, type:%d, cb:%px, app_data:%px, len:%d\n",
 			ncm->version, ncm->interface, ncm->type, (void *)ncm->cb, (void *)ncm->app_data, ncm->len);
 
 	/*
@@ -156,17 +155,17 @@ nss_tx_status_t nss_crypto_tx_buf(struct
 {
 	int32_t status;
 
-	nss_trace("%p: tx_data buf=%p", nss_ctx, skb);
+	nss_trace("%px: tx_data buf=%px", nss_ctx, skb);
 
 	NSS_VERIFY_CTX_MAGIC(nss_ctx);
 	if (unlikely(nss_ctx->state != NSS_CORE_STATE_INITIALIZED)) {
-		nss_warning("%p: tx_data packet dropped as core not ready", nss_ctx);
+		nss_warning("%px: tx_data packet dropped as core not ready", nss_ctx);
 		return NSS_TX_FAILURE_NOT_READY;
 	}
 
 	status = nss_core_send_buffer(nss_ctx, if_num, skb, NSS_IF_H2N_DATA_QUEUE, H2N_BUFFER_PACKET, H2N_BIT_FLAG_BUFFER_REUSABLE);
 	if (unlikely(status != NSS_CORE_STATUS_SUCCESS)) {
-		nss_warning("%p: tx_data Unable to enqueue packet", nss_ctx);
+		nss_warning("%px: tx_data Unable to enqueue packet", nss_ctx);
 		if (status == NSS_CORE_STATUS_FAILURE_QUEUE) {
 			return NSS_TX_FAILURE_QUEUE;
 		}
@@ -226,7 +225,7 @@ struct nss_ctx_instance *nss_crypto_data
 	nss_ctx = &nss_top_main.nss[nss_top_main.crypto_handler_id];
 
 	if ((if_num >= NSS_MAX_NET_INTERFACES) && (if_num < NSS_MAX_PHYSICAL_INTERFACES)) {
-		nss_warning("%p: data register received for invalid interface %d", nss_ctx, if_num);
+		nss_warning("%px: data register received for invalid interface %d", nss_ctx, if_num);
 		return NULL;
 	}
 
@@ -245,7 +244,7 @@ struct nss_ctx_instance *nss_crypto_data
 void nss_crypto_data_unregister(struct nss_ctx_instance *nss_ctx, uint32_t if_num)
 {
 	if ((if_num >= NSS_MAX_NET_INTERFACES) && (if_num < NSS_MAX_PHYSICAL_INTERFACES)) {
-		nss_warning("%p: data unregister received for invalid interface %d", nss_ctx, if_num);
+		nss_warning("%px: data unregister received for invalid interface %d", nss_ctx, if_num);
 		return;
 	}
 
--- a/nss_crypto_cmn.c
+++ b/nss_crypto_cmn.c
@@ -62,7 +62,7 @@ static void nss_crypto_cmn_msg_handler(s
 	 * Sanity check the message type
 	 */
 	if (ncm->type > NSS_CRYPTO_CMN_MSG_TYPE_MAX) {
-		nss_warning("%p: rx message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: rx message type out of range: %d", nss_ctx, ncm->type);
 		return;
 	}
 
@@ -72,12 +72,12 @@ static void nss_crypto_cmn_msg_handler(s
 	 * the intended interface.
 	 */
 	if (nss_cmn_get_msg_len(ncm) > sizeof(*nim)) {
-		nss_warning("%p: rx message length is invalid: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: rx message length is invalid: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
 	if (ncm->response == NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: rx message response for if %d, type %d, is invalid: %d", nss_ctx,
+		nss_warning("%px: rx message response for if %d, type %d, is invalid: %d", nss_ctx,
 				ncm->interface, ncm->type, ncm->response);
 		return;
 	}
@@ -99,7 +99,7 @@ static void nss_crypto_cmn_msg_handler(s
 	 */
 	cb = (nss_crypto_cmn_msg_callback_t)ncm->cb;
 	if (unlikely(!cb)) {
-		nss_warning("%p: rx handler has been unregistered for i/f: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: rx handler has been unregistered for i/f: %d", nss_ctx, ncm->interface);
 		return;
 	}
 
@@ -115,12 +115,12 @@ nss_tx_status_t nss_crypto_cmn_tx_msg(st
 	struct nss_cmn_msg *ncm = &msg->cm;
 	uint16_t msg_len = nss_cmn_get_msg_len(ncm);
 
-	nss_info("%p: tx message %d for if %d", nss_ctx, ncm->type, ncm->interface);
+	nss_info("%px: tx message %d for if %d", nss_ctx, ncm->type, ncm->interface);
 
 	BUILD_BUG_ON(NSS_NBUF_PAYLOAD_SIZE < sizeof(*msg));
 
 	if (ncm->type > NSS_CRYPTO_CMN_MSG_TYPE_MAX) {
-		nss_warning("%p: message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
@@ -129,11 +129,11 @@ nss_tx_status_t nss_crypto_cmn_tx_msg(st
 	 * the sender accidentally programmed a incorrect length into the message.
 	 */
 	if (msg_len != sizeof(*msg)) {
-		nss_warning("%p: message request len bad: %d", nss_ctx, msg_len);
+		nss_warning("%px: message request len bad: %d", nss_ctx, msg_len);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
-	nss_trace("%p: msg params version:%d, interface:%d, type:%d, cb:%p, app_data:%p, len:%d",
+	nss_trace("%px: msg params version:%d, interface:%d, type:%d, cb:%px, app_data:%px, len:%d",
 			nss_ctx, ncm->version, ncm->interface, ncm->type,
 			(void *)ncm->cb, (void *)ncm->app_data, ncm->len);
 
@@ -189,7 +189,7 @@ nss_tx_status_t nss_crypto_cmn_tx_msg_sy
 
 	status = nss_crypto_cmn_tx_msg(nss_ctx, msg);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: tx_msg failed", nss_ctx);
+		nss_warning("%px: tx_msg failed", nss_ctx);
 		up(&pvt->sem);
 		return status;
 	}
@@ -200,7 +200,7 @@ nss_tx_status_t nss_crypto_cmn_tx_msg_sy
 	ret = wait_for_completion_timeout(&pvt->complete, NSS_CRYPTO_CMN_TX_TIMEO_TICKS);
 	if (!ret) {
 		atomic_inc(&pvt->seq_no);
-		nss_warning("%p: tx_msg_sync timed out", nss_ctx);
+		nss_warning("%px: tx_msg_sync timed out", nss_ctx);
 		up(&pvt->sem);
 		return NSS_TX_FAILURE;
 	}
@@ -229,7 +229,7 @@ nss_tx_status_t nss_crypto_cmn_tx_buf(st
 
 	NSS_VERIFY_CTX_MAGIC(nss_ctx);
 	if (unlikely(nss_ctx->state != NSS_CORE_STATE_INITIALIZED)) {
-		nss_warning("%p: tx_data packet dropped as core not ready", nss_ctx);
+		nss_warning("%px: tx_data packet dropped as core not ready", nss_ctx);
 		return NSS_TX_FAILURE_NOT_READY;
 	}
 
@@ -239,11 +239,11 @@ nss_tx_status_t nss_crypto_cmn_tx_buf(st
 		break;
 
 	case NSS_CORE_STATUS_FAILURE_QUEUE: /* queue full condition */
-		nss_warning("%p: H2N queue full for tx_buf", nss_ctx);
+		nss_warning("%px: H2N queue full for tx_buf", nss_ctx);
 		return NSS_TX_FAILURE_QUEUE;
 
 	default:
-		nss_warning("%p: general failure for tx_buf", nss_ctx);
+		nss_warning("%px: general failure for tx_buf", nss_ctx);
 		return NSS_TX_FAILURE;
 	}
 
@@ -298,7 +298,7 @@ struct nss_ctx_instance *nss_crypto_cmn_
 	nss_ctx = &nss_top_main.nss[nss_top_main.crypto_handler_id];
 
 	if (if_num < NSS_SPECIAL_IF_START) {
-		nss_warning("%p: interface number is not special interface %d", nss_ctx, if_num);
+		nss_warning("%px: interface number is not special interface %d", nss_ctx, if_num);
 		return NULL;
 	}
 
@@ -325,7 +325,7 @@ EXPORT_SYMBOL(nss_crypto_cmn_data_regist
 void nss_crypto_cmn_data_unregister(struct nss_ctx_instance *nss_ctx, uint32_t if_num)
 {
 	if (if_num < NSS_SPECIAL_IF_START) {
-		nss_warning("%p: interface number is not special interface %d", nss_ctx, if_num);
+		nss_warning("%px: interface number is not special interface %d", nss_ctx, if_num);
 		return;
 	}
 
--- a/nss_crypto_cmn_log.c
+++ b/nss_crypto_cmn_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018-2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -65,7 +65,7 @@ static int8_t *nss_crypto_cmn_log_error_
 static void nss_crypto_cmn_node_msg(struct nss_crypto_cmn_msg *ncm)
 {
 	struct nss_crypto_cmn_node *ncnm __maybe_unused = &ncm->msg.node;
-	nss_trace("%p: NSS crypto common node message:\n"
+	nss_trace("%px: NSS crypto common node message:\n"
 		"Crypto Common Max DMA Rings: %d\n"
 		"Crypto Common Max Contex: %d\n"
 		"Crypto Common Max Context Size: %d\n",
@@ -80,8 +80,8 @@ static void nss_crypto_cmn_node_msg(stru
 static void nss_crypto_cmn_engine_msg(struct nss_crypto_cmn_msg *ncm)
 {
 	struct nss_crypto_cmn_engine *ncem __maybe_unused = &ncm->msg.eng;
-	nss_trace("%p: NSS crypto common engine message \n"
-		"Crypto Common Firmware Version: %p\n"
+	nss_trace("%px: NSS crypto common engine message \n"
+		"Crypto Common Firmware Version: %px\n"
 		"Crypto Common DMA Mask: %x\n"
 		"Crypto Common Token Count: %d\n",
 		ncem, &ncem->fw_ver,
@@ -95,7 +95,7 @@ static void nss_crypto_cmn_engine_msg(st
 static void nss_crypto_cmn_dma_msg(struct nss_crypto_cmn_msg *ncm)
 {
 	struct nss_crypto_cmn_dma *ncdm __maybe_unused = &ncm->msg.dma;
-	nss_trace("%p: NSS crypto common dma message \n"
+	nss_trace("%px: NSS crypto common dma message \n"
 		"Crypto Common DMA Pair ID: %d\n",
 		ncdm, ncdm->pair_id);
 }
@@ -107,13 +107,13 @@ static void nss_crypto_cmn_dma_msg(struc
 static void nss_crypto_cmn_ctx_msg(struct nss_crypto_cmn_msg *ncm)
 {
 	struct nss_crypto_cmn_ctx *nccm __maybe_unused = &ncm->msg.ctx;
-	nss_trace("%p: NSS crypto common context message \n"
-		"Crypto Common Context Spare Words: %p\n"
+	nss_trace("%px: NSS crypto common context message \n"
+		"Crypto Common Context Spare Words: %px\n"
 		"Crypto Common Index: %d\n"
 		"Crypto Common Secure Offset: %d\n"
-		"Crypto Common Cipher Key: %p\n"
-		"Crypto Common Authorization Key: %p\n"
-		"Crypto Common Nonce Value: %p\n"
+		"Crypto Common Cipher Key: %px\n"
+		"Crypto Common Authorization Key: %px\n"
+		"Crypto Common Nonce Value: %px\n"
 		"Crypto Common Algorithm: %x\n"
 		"Crypto Common Context Specific Flags: %x\n",
 		nccm, &nccm->spare,
@@ -154,7 +154,7 @@ static void nss_crypto_cmn_log_verbose(s
 		break;
 
 	default:
-		nss_warning("%p: Invalid message type\n", ncm);
+		nss_warning("%px: Invalid message type\n", ncm);
 		break;
 	}
 }
@@ -166,11 +166,11 @@ static void nss_crypto_cmn_log_verbose(s
 void nss_crypto_cmn_log_tx_msg(struct nss_crypto_cmn_msg *ncm)
 {
 	if (ncm->cm.type >= NSS_CRYPTO_CMN_MSG_TYPE_MAX) {
-		nss_warning("%p: Invalid message type\n", ncm);
+		nss_warning("%px: Invalid message type\n", ncm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", ncm, ncm->cm.type, nss_crypto_cmn_log_message_types_str[ncm->cm.type]);
+	nss_info("%px: type[%d]:%s\n", ncm, ncm->cm.type, nss_crypto_cmn_log_message_types_str[ncm->cm.type]);
 	nss_crypto_cmn_log_verbose(ncm);
 }
 
@@ -181,26 +181,26 @@ void nss_crypto_cmn_log_tx_msg(struct ns
 void nss_crypto_cmn_log_rx_msg(struct nss_crypto_cmn_msg *ncm)
 {
 	if (ncm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", ncm);
+		nss_warning("%px: Invalid response\n", ncm);
 		return;
 	}
 
 	if (ncm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (ncm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", ncm, ncm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", ncm, ncm->cm.type,
 			nss_crypto_cmn_log_message_types_str[ncm->cm.type],
 			ncm->cm.response, nss_cmn_response_str[ncm->cm.response]);
 		goto verbose;
 	}
 
 	if (ncm->cm.error >= NSS_CRYPTO_CMN_MSG_ERROR_MAX) {
-		nss_warning("%p: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
+		nss_warning("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
 			ncm, ncm->cm.type, nss_crypto_cmn_log_message_types_str[ncm->cm.type],
 			ncm->cm.response, nss_cmn_response_str[ncm->cm.response],
 			ncm->cm.error);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
 		ncm, ncm->cm.type, nss_crypto_cmn_log_message_types_str[ncm->cm.type],
 		ncm->cm.response, nss_cmn_response_str[ncm->cm.response],
 		ncm->cm.error, nss_crypto_cmn_log_error_response_types_str[ncm->cm.error]);
--- a/nss_crypto_log.c
+++ b/nss_crypto_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -53,12 +53,12 @@ static int8_t *nss_crypto_log_error_resp
 static void nss_crypto_config_eng_msg(struct nss_crypto_msg *ncm)
 {
 	struct nss_crypto_config_eng *nccem __maybe_unused = &ncm->msg.eng;
-	nss_trace("%p: NSS Crypto Config Engine Message:\n"
+	nss_trace("%px: NSS Crypto Config Engine Message:\n"
 		"Crypto Engine Number: %d\n"
 		"Crypto BAM Physical Base Address: %x\n"
 		"Crypto Physical Base Address: %x\n"
-		"Crypto Pipe Description Address: %p\n"
-		"Crypto Session Indices: %p\n",
+		"Crypto Pipe Description Address: %px\n"
+		"Crypto Session Indices: %px\n",
 		nccem, nccem->eng_id,
 		nccem->bam_pbase, nccem->crypto_pbase,
 		&nccem->desc_paddr, &nccem->idx);
@@ -71,7 +71,7 @@ static void nss_crypto_config_eng_msg(st
 static void nss_crypto_config_session_msg(struct nss_crypto_msg *ncm)
 {
 	struct nss_crypto_config_session *nccsm __maybe_unused = &ncm->msg.session;
-	nss_trace("%p: NSS Crypto Config Session message \n"
+	nss_trace("%px: NSS Crypto Config Session message \n"
 		"Crypto Session Index: %d\n"
 		"Crypto Session State: %d\n"
 		"Crypto Session Initialization Vector Length: %d\n",
@@ -95,7 +95,7 @@ static void nss_crypto_log_verbose(struc
 		break;
 
 	default:
-		nss_warning("%p: Invalid message type\n", ncm);
+		nss_warning("%px: Invalid message type\n", ncm);
 		break;
 	}
 }
@@ -107,11 +107,11 @@ static void nss_crypto_log_verbose(struc
 void nss_crypto_log_tx_msg(struct nss_crypto_msg *ncm)
 {
 	if (ncm->cm.type >= NSS_CRYPTO_MSG_TYPE_MAX) {
-		nss_warning("%p: Invalid message type\n", ncm);
+		nss_warning("%px: Invalid message type\n", ncm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", ncm, ncm->cm.type, nss_crypto_log_message_types_str[ncm->cm.type]);
+	nss_info("%px: type[%d]:%s\n", ncm, ncm->cm.type, nss_crypto_log_message_types_str[ncm->cm.type]);
 	nss_crypto_log_verbose(ncm);
 }
 
@@ -122,26 +122,26 @@ void nss_crypto_log_tx_msg(struct nss_cr
 void nss_crypto_log_rx_msg(struct nss_crypto_msg *ncm)
 {
 	if (ncm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", ncm);
+		nss_warning("%px: Invalid response\n", ncm);
 		return;
 	}
 
 	if (ncm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (ncm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", ncm, ncm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", ncm, ncm->cm.type,
 			nss_crypto_log_message_types_str[ncm->cm.type],
 			ncm->cm.response, nss_cmn_response_str[ncm->cm.response]);
 		goto verbose;
 	}
 
 	if (ncm->cm.error >= NSS_CRYPTO_MSG_ERROR_MAX) {
-		nss_warning("%p: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
+		nss_warning("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
 			ncm, ncm->cm.type, nss_crypto_log_message_types_str[ncm->cm.type],
 			ncm->cm.response, nss_cmn_response_str[ncm->cm.response],
 			ncm->cm.error);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
 		ncm, ncm->cm.type, nss_crypto_log_message_types_str[ncm->cm.type],
 		ncm->cm.response, nss_cmn_response_str[ncm->cm.response],
 		ncm->cm.error, nss_crypto_log_error_response_types_str[ncm->cm.error]);
--- /dev/null
+++ b/nss_data_plane/hal/include/nss_data_plane_hal.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2016-2020, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include "nss_phys_if.h"
+#include <nss_dp_api_if.h>
+
+/*
+ * nss_data_plane_param
+ */
+struct nss_data_plane_param {
+	struct nss_dp_data_plane_ctx dpc;	/* data plane ctx base class */
+	int if_num;				/* physical interface number */
+	struct nss_ctx_instance *nss_ctx;	/* which nss core */
+	struct nss_dp_gmac_stats gmac_stats;	/* SoC specific stats for GMAC */
+	int notify_open;			/* This data plane interface has been opened or not */
+	uint32_t features;			/* skb types supported by this interface */
+	uint32_t bypass_nw_process;		/* Do we want to bypass NW processing in NSS for this data plane? */
+};
+
+void nss_data_plane_hal_add_dp_ops(struct nss_dp_data_plane_ops *dp_ops);
+void nss_data_plane_hal_register(struct nss_ctx_instance *nss_ctx);
+void nss_data_plane_hal_unregister(struct nss_ctx_instance *nss_ctx);
+uint16_t nss_data_plane_hal_get_mtu_sz(uint16_t mtu);
+void nss_data_plane_hal_stats_sync(struct nss_data_plane_param *ndpp, struct nss_phys_if_stats *stats);
--- /dev/null
+++ b/nss_data_plane/hal/nss_ipq60xx.c
@@ -0,0 +1,106 @@
+/*
+ * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include "nss_core.h"
+#include "nss_data_plane_hal.h"
+
+/*
+ * nss_data_plane_hal_vsi_assign()
+ *	Called by nss-dp to assign vsi of a data plane
+ */
+static int nss_data_plane_hal_vsi_assign(struct nss_dp_data_plane_ctx *dpc, uint32_t vsi)
+{
+	struct nss_data_plane_param *dp = (struct nss_data_plane_param *)dpc;
+
+	return nss_phys_if_vsi_assign(dp->nss_ctx, vsi, dp->if_num);
+}
+
+/*
+ * nss_data_plane_hal_vsi_unassign()
+ *	Called by nss-dp to unassign vsi of a data plane
+ */
+static int nss_data_plane_hal_vsi_unassign(struct nss_dp_data_plane_ctx *dpc, uint32_t vsi)
+{
+	struct nss_data_plane_param *dp = (struct nss_data_plane_param *)dpc;
+
+	return nss_phys_if_vsi_unassign(dp->nss_ctx, vsi, dp->if_num);
+}
+
+/*
+ * nss_data_plane_hal_get_stats()
+ *	Called by nss-dp to get GMAC stats
+ */
+static void nss_data_plane_hal_get_stats(struct nss_dp_data_plane_ctx *dpc,
+						struct nss_dp_gmac_stats *stats)
+{
+	/*
+	 * EDMA doesn't send extended statistics.
+	 */
+}
+
+/*
+ * nss_data_plane_hal_add_dp_ops()
+ */
+void nss_data_plane_hal_add_dp_ops(struct nss_dp_data_plane_ops *dp_ops)
+{
+	dp_ops->vsi_assign = nss_data_plane_hal_vsi_assign;
+	dp_ops->vsi_unassign = nss_data_plane_hal_vsi_unassign;
+	dp_ops->get_stats = nss_data_plane_hal_get_stats;
+}
+
+/*
+ * nss_data_plane_hal_register()
+ */
+void nss_data_plane_hal_register(struct nss_ctx_instance *nss_ctx)
+{
+	/*
+	 * Packets with the ptp service code should be delivered to
+	 * PHY driver for timestamping.
+	 */
+	nss_cmn_register_service_code(nss_ctx, nss_phy_tstamp_rx_buf,
+					NSS_PTP_EVENT_SERVICE_CODE, nss_ctx);
+}
+
+/*
+ * nss_data_plane_hal_unregister()
+ */
+void nss_data_plane_hal_unregister(struct nss_ctx_instance *nss_ctx)
+{
+	nss_cmn_unregister_service_code(nss_ctx, nss_phy_tstamp_rx_buf,
+					NSS_PTP_EVENT_SERVICE_CODE);
+}
+
+/*
+ * nss_data_plane_hal_stats_sync()
+ */
+void nss_data_plane_hal_stats_sync(struct nss_data_plane_param *ndpp,
+					struct nss_phys_if_stats *stats)
+{
+	/*
+	 * EDMA does not pass sync interface stats through phys_if_stats
+	 */
+}
+
+/*
+ * nss_data_plane_hal_get_mtu_sz()
+ */
+uint16_t nss_data_plane_hal_get_mtu_sz(uint16_t mtu)
+{
+	/*
+	 * Reserve space for preheader
+	 */
+	return mtu + NSS_DP_PREHEADER_SIZE;
+}
--- /dev/null
+++ b/nss_data_plane/hal/nss_ipq807x.c
@@ -0,0 +1,106 @@
+/*
+ * Copyright (c) 2016-2020, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include "nss_core.h"
+#include "nss_data_plane_hal.h"
+
+/*
+ * nss_data_plane_hal_vsi_assign()
+ *	Called by nss-dp to assign vsi of a data plane
+ */
+static int nss_data_plane_hal_vsi_assign(struct nss_dp_data_plane_ctx *dpc, uint32_t vsi)
+{
+	struct nss_data_plane_param *dp = (struct nss_data_plane_param *)dpc;
+
+	return nss_phys_if_vsi_assign(dp->nss_ctx, vsi, dp->if_num);
+}
+
+/*
+ * nss_data_plane_hal_vsi_unassign()
+ *	Called by nss-dp to unassign vsi of a data plane
+ */
+static int nss_data_plane_hal_vsi_unassign(struct nss_dp_data_plane_ctx *dpc, uint32_t vsi)
+{
+	struct nss_data_plane_param *dp = (struct nss_data_plane_param *)dpc;
+
+	return nss_phys_if_vsi_unassign(dp->nss_ctx, vsi, dp->if_num);
+}
+
+/*
+ * nss_data_plane_hal_get_stats()
+ *	Called by nss-dp to get GMAC stats
+ */
+static void nss_data_plane_hal_get_stats(struct nss_dp_data_plane_ctx *dpc,
+						struct nss_dp_gmac_stats *stats)
+{
+	/*
+	 * EDMA doesn't send extended statistics.
+	 */
+}
+
+/*
+ * nss_data_plane_hal_add_dp_ops()
+ */
+void nss_data_plane_hal_add_dp_ops(struct nss_dp_data_plane_ops *dp_ops)
+{
+	dp_ops->vsi_assign = nss_data_plane_hal_vsi_assign;
+	dp_ops->vsi_unassign = nss_data_plane_hal_vsi_unassign;
+	dp_ops->get_stats = nss_data_plane_hal_get_stats;
+}
+
+/*
+ * nss_data_plane_hal_register()
+ */
+void nss_data_plane_hal_register(struct nss_ctx_instance *nss_ctx)
+{
+	/*
+	 * Packets with the ptp service code should be delivered to
+	 * PHY driver for timestamping.
+	 */
+	nss_cmn_register_service_code(nss_ctx, nss_phy_tstamp_rx_buf,
+					NSS_PTP_EVENT_SERVICE_CODE, nss_ctx);
+}
+
+/*
+ * nss_data_plane_hal_unregister()
+ */
+void nss_data_plane_hal_unregister(struct nss_ctx_instance *nss_ctx)
+{
+	nss_cmn_unregister_service_code(nss_ctx, nss_phy_tstamp_rx_buf,
+					NSS_PTP_EVENT_SERVICE_CODE);
+}
+
+/*
+ * nss_data_plane_hal_stats_sync()
+ */
+void nss_data_plane_hal_stats_sync(struct nss_data_plane_param *ndpp,
+					struct nss_phys_if_stats *stats)
+{
+	/*
+	 * EDMA does not pass sync interface stats through phys_if_stats
+	 */
+}
+
+/*
+ * nss_data_plane_hal_get_mtu_sz()
+ */
+uint16_t nss_data_plane_hal_get_mtu_sz(uint16_t mtu)
+{
+	/*
+	 * Reserve space for preheader
+	 */
+	return mtu + NSS_DP_PREHEADER_SIZE;
+}
--- a/nss_data_plane/include/nss_data_plane.h
+++ b/nss_data_plane/include/nss_data_plane.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2017, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2017,2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -54,7 +54,7 @@ struct nss_data_plane_ops {
 };
 
 extern struct nss_data_plane_ops nss_data_plane_gmac_ops;
-extern struct nss_data_plane_ops nss_data_plane_edma_ops;
+extern struct nss_data_plane_ops nss_data_plane_ops;
 
 extern int nss_skip_nw_process;
 #endif
--- a/nss_data_plane/nss_data_plane.c
+++ b/nss_data_plane/nss_data_plane.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014 - 2016, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -16,69 +16,390 @@
 
 #include "nss_data_plane.h"
 #include "nss_core.h"
+#include "nss_tx_rx_common.h"
+#include "nss_data_plane_hal.h"
 
-static struct delayed_work nss_data_plane_work;
-static struct workqueue_struct *nss_data_plane_workqueue;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 5, 0))
+#define NSS_DATA_PLANE_SUPPORTED_FEATURES (NETIF_F_HIGHDMA \
+					| NETIF_F_HW_CSUM \
+					| NETIF_F_RXCSUM \
+					| NETIF_F_SG \
+					| NETIF_F_FRAGLIST \
+					| (NETIF_F_TSO | NETIF_F_TSO6 | NETIF_F_UFO))
+#else
+#define NSS_DATA_PLANE_SUPPORTED_FEATURES (NETIF_F_HIGHDMA \
+					| NETIF_F_HW_CSUM \
+					| NETIF_F_RXCSUM \
+					| NETIF_F_SG \
+					| NETIF_F_FRAGLIST \
+					| (NETIF_F_TSO | NETIF_F_TSO6))
+#endif
 
-extern bool pn_mq_en;
-extern uint16_t pn_qlimits[NSS_MAX_NUM_PRI];
+/*
+ * nss_data_plane_param
+ */
+struct nss_data_plane_param nss_data_plane_params[NSS_DP_MAX_INTERFACES];
 
 /*
- * nss_data_plane_work_function()
- *	Work function that gets queued to "install" the data plane overlays
+ * __nss_data_plane_init()
  */
-static void nss_data_plane_work_function(struct work_struct *work)
+static int __nss_data_plane_init(struct nss_dp_data_plane_ctx *dpc)
 {
-	int ret;
-	struct nss_ctx_instance *nss_ctx = &nss_top_main.nss[NSS_CORE_0];
-	struct nss_top_instance *nss_top = nss_ctx->nss_top;
+	struct net_device *netdev = dpc->dev;
+	netdev->needed_headroom += 32;
+	return NSS_DP_SUCCESS;
+}
+
+/*
+ * __nss_data_plane_open()
+ *	Called by nss-dp to notify open to nss-fw
+ */
+static int __nss_data_plane_open(struct nss_dp_data_plane_ctx *dpc, uint32_t tx_desc_ring, uint32_t rx_desc_ring, uint32_t mode)
+{
+	struct nss_data_plane_param *dp = (struct nss_data_plane_param *)dpc;
+
+	if (dp->notify_open) {
+		return NSS_DP_SUCCESS;
+	}
+
+	if (nss_phys_if_open(dp->nss_ctx, tx_desc_ring, rx_desc_ring, mode, dp->if_num, dp->bypass_nw_process) == NSS_TX_SUCCESS) {
+		dp->notify_open = 1;
+		return NSS_DP_SUCCESS;
+	}
+	return NSS_DP_FAILURE;
+}
+
+/*
+ * __nss_data_plane_close()
+ *	Called by nss-dp to notify close to nss-fw
+ */
+static int __nss_data_plane_close(struct nss_dp_data_plane_ctx *dpc)
+{
+	struct nss_data_plane_param *dp = (struct nss_data_plane_param *)dpc;
+
+	if (!dp->notify_open) {
+		return NSS_DP_SUCCESS;
+	}
+
+	if (nss_phys_if_close(dp->nss_ctx, dp->if_num) == NSS_TX_SUCCESS) {
+		dp->notify_open = 0;
+		return NSS_DP_SUCCESS;
+	}
+	return NSS_DP_FAILURE;
+}
+
+/*
+ * __nss_data_plane_link_state()
+ *	Called by nss-dp to notify link state change to nss-fw
+ */
+static int __nss_data_plane_link_state(struct nss_dp_data_plane_ctx *dpc, uint32_t link_state)
+{
+	struct nss_data_plane_param *dp = (struct nss_data_plane_param *)dpc;
+
+	return nss_phys_if_link_state(dp->nss_ctx, link_state, dp->if_num);
+}
+
+/*
+ * __nss_data_plane_mac_addr()
+ *	Called by nss-dp to set mac address
+ */
+static int __nss_data_plane_mac_addr(struct nss_dp_data_plane_ctx *dpc, uint8_t *addr)
+{
+	struct nss_data_plane_param *dp = (struct nss_data_plane_param *)dpc;
 
+	return nss_phys_if_mac_addr(dp->nss_ctx, addr, dp->if_num);
+}
+
+/*
+ * __nss_data_plane_change_mtu()
+ *	Called by nss-dp to change mtu of a data plane
+ */
+static int __nss_data_plane_change_mtu(struct nss_dp_data_plane_ctx *dpc, uint32_t mtu)
+{
+	struct nss_data_plane_param *dp = (struct nss_data_plane_param *)dpc;
+
+	if (mtu > NSS_DP_MAX_MTU_SIZE) {
+		nss_warning("%px: MTU exceeds MAX size %d\n", dp, mtu);
+		return NSS_DP_FAILURE;
+	}
+
+	return nss_phys_if_change_mtu(dp->nss_ctx, mtu, dp->if_num);
+}
+
+/*
+ * __nss_data_plane_pause_on_off()
+ *	Called by nss-dp to enable/disable pause frames
+ */
+static int __nss_data_plane_pause_on_off(struct nss_dp_data_plane_ctx *dpc, uint32_t pause_on)
+{
+	struct nss_data_plane_param *dp = (struct nss_data_plane_param *)dpc;
+
+	return nss_phys_if_pause_on_off(dp->nss_ctx, pause_on, dp->if_num);
+}
+
+#ifdef NSS_DRV_QRFS_ENABLE
+/*
+ * __nss_data_plane_rx_flow_steer()
+ *	Called by nss-dp to set flow rule of a data plane
+ */
+static int __nss_data_plane_rx_flow_steer(struct nss_dp_data_plane_ctx *dpc, struct sk_buff *skb,
+						uint32_t cpu, bool is_add)
+{
+	if (is_add) {
+		return nss_qrfs_set_flow_rule(skb, cpu, NSS_QRFS_MSG_FLOW_ADD);
+	}
+
+	return nss_qrfs_set_flow_rule(skb, cpu, NSS_QRFS_MSG_FLOW_DELETE);
+}
+#endif
+
+/*
+ * __nss_data_plane_deinit()
+ *	Place holder for nss-dp ops to free NSS data plane resources
+ */
+static int __nss_data_plane_deinit(struct nss_dp_data_plane_ctx *dpc)
+{
 	/*
-	 * The queue config command is a synchronous command and needs to be issued
-	 * in process context, before NSS data plane switch.
+	 * TODO: Implement free up of NSS data plane resources
 	 */
-	ret = nss_n2h_update_queue_config_sync(nss_ctx, pn_mq_en, pn_qlimits);
-	if (ret != NSS_TX_SUCCESS) {
-		nss_warning("Failed to send pnode queue config to core 0\n");
+	return NSS_TX_SUCCESS;
+}
+
+/*
+ * __nss_data_plane_buf()
+ *	Called by nss-dp to pass a sk_buff for xmit
+ */
+static netdev_tx_t __nss_data_plane_buf(struct nss_dp_data_plane_ctx *dpc, struct sk_buff *skb)
+{
+	struct nss_data_plane_param *dp = (struct nss_data_plane_param *)dpc;
+	int extra_head = dpc->dev->needed_headroom - skb_headroom(skb);
+	int extra_tail = 0;
+	nss_tx_status_t status;
+	struct net_device *dev = dpc->dev;
+
+	if (skb->len < ETH_HLEN) {
+		nss_warning("skb->len ( %u ) < ETH_HLEN ( %u ) \n", skb->len, ETH_HLEN);
+		goto drop;
 	}
 
-	nss_top->data_plane_ops->data_plane_register(nss_ctx);
+	if (skb->len > NSS_DP_MAX_PACKET_LEN) {
+		nss_warning("skb->len ( %u ) > Maximum packet length ( %u ) \n", skb->len, NSS_DP_MAX_PACKET_LEN);
+		goto drop;
+	}
+
+	if (skb_cloned(skb) || extra_head > 0) {
+		/*
+		 * If it is a clone and headroom is already enough,
+		 * We just make a copy and clear the clone flag.
+		 */
+		if (extra_head <= 0)
+			extra_head = extra_tail = 0;
+		/*
+		 * If tailroom is enough to accommodate the added headroom,
+		 * then allocate a buffer of same size and do relocations.
+		 * It might help kmalloc_reserve() not double the size.
+		 */
+		if (skb->end - skb->tail >= extra_head)
+			extra_tail = -extra_head;
+
+		if (pskb_expand_head(skb, extra_head, extra_tail, GFP_ATOMIC)) {
+			nss_warning("%px: Unable to expand skb for headroom\n", dp);
+			goto drop;
+		}
+	}
+
+	status = nss_phys_if_buf(dp->nss_ctx, skb, dp->if_num);
+	if (likely(status == NSS_TX_SUCCESS)) {
+		return NETDEV_TX_OK;
+	} else if (status == NSS_TX_FAILURE_QUEUE) {
+		return NETDEV_TX_BUSY;
+	}
+
+drop:
+	dev_kfree_skb_any(skb);
+	dev->stats.tx_dropped++;
+
+	return NETDEV_TX_OK;
+}
+
+/*
+ * __nss_data_plane_set_features()
+ *	Called by nss-dp to allow data plane to modify the set of features it supports
+ */
+static void __nss_data_plane_set_features(struct nss_dp_data_plane_ctx *dpc)
+{
+	dpc->dev->features |= NSS_DATA_PLANE_SUPPORTED_FEATURES;
+	dpc->dev->hw_features |= NSS_DATA_PLANE_SUPPORTED_FEATURES;
+	dpc->dev->vlan_features |= NSS_DATA_PLANE_SUPPORTED_FEATURES;
+	dpc->dev->wanted_features |= NSS_DATA_PLANE_SUPPORTED_FEATURES;
 }
 
 /*
- * nss_data_plane_schedule_registration()
- *	Called from nss_init to schedule a work to do data_plane register to data plane host
+ * nss offload data plane ops
  */
-bool nss_data_plane_schedule_registration(void)
+static struct nss_dp_data_plane_ops dp_ops = {
+	.init		= __nss_data_plane_init,
+	.open		= __nss_data_plane_open,
+	.close		= __nss_data_plane_close,
+	.link_state	= __nss_data_plane_link_state,
+	.mac_addr	= __nss_data_plane_mac_addr,
+	.change_mtu	= __nss_data_plane_change_mtu,
+	.xmit		= __nss_data_plane_buf,
+	.set_features	= __nss_data_plane_set_features,
+	.pause_on_off	= __nss_data_plane_pause_on_off,
+#ifdef NSS_DRV_QRFS_ENABLE
+	.rx_flow_steer	= __nss_data_plane_rx_flow_steer,
+#endif
+	.deinit		= __nss_data_plane_deinit,
+};
+
+/*
+ * nss_data_plane_register_to_nss_dp()
+ */
+static bool nss_data_plane_register_to_nss_dp(struct nss_ctx_instance *nss_ctx, int if_num)
 {
-	if (!queue_work_on(1, nss_data_plane_workqueue, &nss_data_plane_work.work)) {
-		nss_warning("Failed to register data plane workqueue on core 1\n");
+	struct nss_data_plane_param *ndpp = &nss_data_plane_params[if_num];
+	struct nss_top_instance *nss_top = nss_ctx->nss_top;
+	struct net_device *netdev;
+	bool is_open;
+	int core;
+
+	netdev = nss_dp_get_netdev_by_nss_if_num(if_num);
+	if (!netdev) {
+		nss_info("%px: Platform don't have data plane%d enabled, \
+				don't bring up nss_phys_if and don't register to nss-dp\n",
+				nss_ctx, if_num);
 		return false;
 	}
 
-	nss_info("Register data plane workqueue on core 1\n");
+	is_open = nss_dp_is_in_open_state(netdev);
+	ndpp->dpc.dev = netdev;
+	ndpp->nss_ctx = nss_ctx;
+	ndpp->if_num = if_num;
+	ndpp->notify_open = 0;
+	ndpp->features = 0;
+
+	/*
+	 * Add data plane ops applicable to this SoC.
+	 */
+	nss_data_plane_hal_add_dp_ops(&dp_ops);
+
+	/*
+	 * Check if NSS NW processing to be bypassed for this data plane
+	 */
+	if (nss_skip_nw_process) {
+		ndpp->bypass_nw_process = 1;
+	} else {
+		ndpp->bypass_nw_process = 0;
+	}
+
+	if (nss_dp_override_data_plane(netdev, &dp_ops, (struct nss_dp_data_plane_ctx *)ndpp) != NSS_DP_SUCCESS) {
+		nss_info("%px: Override nss-dp data plane for port %dfailed\n", nss_ctx, if_num);
+		return false;
+	}
+
+	/*
+	 * Setup the receive callback so that data pkts received form NSS-FW will
+	 * be redirected to the nss-dp driver as we are overriding the data plane
+	 */
+	nss_top->phys_if_handler_id[if_num] = nss_ctx->id;
+	nss_phys_if_register_handler(nss_ctx, if_num);
+
+	/*
+	 * Packets recieved on physical interface can be exceptioned to HLOS
+	 * from any NSS core so we need to register data plane for all
+	 */
+	for (core = 0; core < nss_top->num_nss; core++) {
+		nss_core_register_subsys_dp(&nss_top->nss[core], if_num, nss_dp_receive, NULL, NULL, netdev, ndpp->features);
+	}
+
+	/*
+	 * Now we are registered and our side is ready, if the data plane was opened, ask it to start again
+	 */
+	if (is_open) {
+		nss_dp_start_data_plane(netdev, (struct nss_dp_data_plane_ctx *)ndpp);
+	}
 	return true;
 }
 
 /*
- * nss_data_plane_init_delay_work()
+ * nss_data_plane_unregister_from_nss_dp()
+ */
+static void nss_data_plane_unregister_from_nss_dp(int if_num)
+{
+	/*
+	 * Do any SoC specific un-registrations.
+	 */
+	nss_data_plane_hal_unregister(nss_data_plane_params[if_num].nss_ctx);
+
+	nss_dp_restore_data_plane(nss_data_plane_params[if_num].dpc.dev);
+	nss_data_plane_params[if_num].dpc.dev = NULL;
+	nss_data_plane_params[if_num].nss_ctx = NULL;
+	nss_data_plane_params[if_num].if_num = 0;
+	nss_data_plane_params[if_num].notify_open = 0;
+	nss_data_plane_params[if_num].bypass_nw_process = 0;
+}
+
+/*
+ * __nss_data_plane_register()
  */
-int nss_data_plane_init_delay_work(void)
+static void __nss_data_plane_register(struct nss_ctx_instance *nss_ctx)
 {
-	nss_data_plane_workqueue = create_singlethread_workqueue("nss_data_plane_workqueue");
-	if (!nss_data_plane_workqueue) {
-		nss_warning("Can't allocate workqueue\n");
-		return -ENOMEM;
+	int i;
+
+	for (i = NSS_DP_START_IFNUM; i < NSS_DP_MAX_INTERFACES; i++) {
+		if (!nss_data_plane_register_to_nss_dp(nss_ctx, i)) {
+			nss_warning("%px: Register data plane failed for data plane %d\n", nss_ctx, i);
+		} else {
+			nss_info("%px: Register data plan to data plane %d success\n", nss_ctx, i);
+		}
 	}
 
-	INIT_DELAYED_WORK(&nss_data_plane_work, nss_data_plane_work_function);
-	return 0;
+	/*
+	 * Do any SoC specific registrations.
+	 */
+	nss_data_plane_hal_register(nss_ctx);
 }
 
 /*
- * nss_data_plane_destroy_delay_work()
+ * __nss_data_plane_unregister()
  */
-void nss_data_plane_destroy_delay_work(void)
+static void __nss_data_plane_unregister(void)
 {
-	destroy_workqueue(nss_data_plane_workqueue);
+	int i, core;
+
+	for (core = 0; core < nss_top_main.num_nss; core++) {
+		for (i = NSS_DP_START_IFNUM; i < NSS_DP_MAX_INTERFACES; i++) {
+			if (nss_top_main.nss[core].subsys_dp_register[i].ndev) {
+				nss_data_plane_unregister_from_nss_dp(i);
+				nss_core_unregister_subsys_dp(&nss_top_main.nss[core], i);
+			}
+		}
+	}
+}
+
+/*
+ * __nss_data_plane_stats_sync()
+ */
+static void __nss_data_plane_stats_sync(struct nss_phys_if_stats *stats, uint16_t interface)
+{
+	nss_data_plane_hal_stats_sync(&nss_data_plane_params[interface], stats);
 }
+
+/*
+ * __nss_data_plane_get_mtu_sz()
+ */
+static uint16_t __nss_data_plane_get_mtu_sz(uint16_t mtu)
+{
+	return nss_data_plane_hal_get_mtu_sz(mtu);
+}
+
+/*
+ * nss_data_plane_ops
+ */
+struct nss_data_plane_ops nss_data_plane_ops = {
+	.data_plane_register = &__nss_data_plane_register,
+	.data_plane_unregister = &__nss_data_plane_unregister,
+	.data_plane_stats_sync = &__nss_data_plane_stats_sync,
+	.data_plane_get_mtu_sz = &__nss_data_plane_get_mtu_sz,
+};
--- /dev/null
+++ b/nss_data_plane/nss_data_plane_common.c
@@ -0,0 +1,84 @@
+/*
+ **************************************************************************
+ * Copyright (c) 2014-2016,2020 The Linux Foundation. All rights reserved.
+ * Permission to use, copy, modify, and/or distribute this software for
+ * any purpose with or without fee is hereby granted, provided that the
+ * above copyright notice and this permission notice appear in all copies.
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ **************************************************************************
+ */
+
+#include "nss_data_plane.h"
+#include "nss_core.h"
+
+static struct delayed_work nss_data_plane_work;
+static struct workqueue_struct *nss_data_plane_workqueue;
+
+extern bool pn_mq_en;
+extern uint16_t pn_qlimits[NSS_MAX_NUM_PRI];
+
+/*
+ * nss_data_plane_work_function()
+ *	Work function that gets queued to "install" the data plane overlays
+ */
+static void nss_data_plane_work_function(struct work_struct *work)
+{
+	int ret;
+	struct nss_ctx_instance *nss_ctx = &nss_top_main.nss[NSS_CORE_0];
+	struct nss_top_instance *nss_top = nss_ctx->nss_top;
+
+	/*
+	 * The queue config command is a synchronous command and needs to be issued
+	 * in process context, before NSS data plane switch.
+	 */
+	ret = nss_n2h_update_queue_config_sync(nss_ctx, pn_mq_en, pn_qlimits);
+	if (ret != NSS_TX_SUCCESS) {
+		nss_warning("Failed to send pnode queue config to core 0\n");
+	}
+
+	nss_top->data_plane_ops->data_plane_register(nss_ctx);
+}
+
+/*
+ * nss_data_plane_schedule_registration()
+ *	Called from nss_init to schedule a work to do data_plane register to data plane host
+ */
+bool nss_data_plane_schedule_registration(void)
+{
+	if (!queue_work_on(1, nss_data_plane_workqueue, &nss_data_plane_work.work)) {
+		nss_warning("Failed to register data plane workqueue on core 1\n");
+		return false;
+	}
+
+	nss_info("Register data plane workqueue on core 1\n");
+	return true;
+}
+
+/*
+ * nss_data_plane_init_delay_work()
+ */
+int nss_data_plane_init_delay_work(void)
+{
+	nss_data_plane_workqueue = create_singlethread_workqueue("nss_data_plane_workqueue");
+	if (!nss_data_plane_workqueue) {
+		nss_warning("Can't allocate workqueue\n");
+		return -ENOMEM;
+	}
+
+	INIT_DELAYED_WORK(&nss_data_plane_work, nss_data_plane_work_function);
+	return 0;
+}
+
+/*
+ * nss_data_plane_destroy_delay_work()
+ */
+void nss_data_plane_destroy_delay_work(void)
+{
+	destroy_workqueue(nss_data_plane_workqueue);
+}
--- a/nss_data_plane/nss_data_plane_edma.c
+++ /dev/null
@@ -1,425 +0,0 @@
-/*
- **************************************************************************
- * Copyright (c) 2016-2020, The Linux Foundation. All rights reserved.
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- **************************************************************************
- */
-
-#include "nss_data_plane.h"
-#include "nss_core.h"
-#include "nss_tx_rx_common.h"
-#include <nss_dp_api_if.h>
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 5, 0))
-#define NSS_DP_EDMA_SUPPORTED_FEATURES (NETIF_F_HIGHDMA | NETIF_F_HW_CSUM | NETIF_F_RXCSUM | NETIF_F_SG | NETIF_F_FRAGLIST | (NETIF_F_TSO | NETIF_F_TSO6 | NETIF_F_UFO))
-#else
-#define NSS_DP_EDMA_SUPPORTED_FEATURES (NETIF_F_HIGHDMA | NETIF_F_HW_CSUM | NETIF_F_RXCSUM | NETIF_F_SG | NETIF_F_FRAGLIST | (NETIF_F_TSO | NETIF_F_TSO6))
-#endif
-#define NSS_DATA_PLANE_EDMA_MAX_INTERFACES 6
-#define NSS_DATA_PLANE_EDMA_MAX_MTU_SIZE 9216
-#define NSS_DATA_PLANE_EDMA_PREHEADER_SIZE 32
-#define NSS_DATA_PLANE_EDMA_MAX_PACKET_LEN 65535
-
-/*
- * nss_data_plane_edma_param
- */
-struct nss_data_plane_edma_param {
-	struct nss_dp_data_plane_ctx dpc;	/* data plane ctx base class */
-	int if_num;				/* physical interface number */
-	struct nss_ctx_instance *nss_ctx;	/* which nss core */
-	int notify_open;			/* This data plane interface has been opened or not */
-	uint32_t features;			/* skb types supported by this interface */
-	uint32_t bypass_nw_process;		/* Do we want to bypass NW processing in NSS for this data plane? */
-} nss_data_plane_edma_params[NSS_DATA_PLANE_EDMA_MAX_INTERFACES + 1];
-
-/*
- * __nss_data_plane_init()
- */
-static int __nss_data_plane_init(struct nss_dp_data_plane_ctx *dpc)
-{
-	struct net_device *netdev = dpc->dev;
-	netdev->needed_headroom += 32;
-	return NSS_DP_SUCCESS;
-}
-
-/*
- * __nss_data_plane_open()
- *	Called by nss-dp to notify open to nss-fw
- */
-static int __nss_data_plane_open(struct nss_dp_data_plane_ctx *dpc, uint32_t tx_desc_ring, uint32_t rx_desc_ring, uint32_t mode)
-{
-	struct nss_data_plane_edma_param *dp = (struct nss_data_plane_edma_param *)dpc;
-
-	if (dp->notify_open) {
-		return NSS_DP_SUCCESS;
-	}
-	if (nss_phys_if_open(dp->nss_ctx, tx_desc_ring, rx_desc_ring, mode, dp->if_num, dp->bypass_nw_process) == NSS_TX_SUCCESS) {
-		dp->notify_open = 1;
-		return NSS_DP_SUCCESS;
-	}
-	return NSS_DP_FAILURE;
-}
-
-/*
- * __nss_data_plane_close()
- *	Called by nss-dp to notify close to nss-fw
- */
-static int __nss_data_plane_close(struct nss_dp_data_plane_ctx *dpc)
-{
-	struct nss_data_plane_edma_param *dp = (struct nss_data_plane_edma_param *)dpc;
-
-	if (!dp->notify_open) {
-		return NSS_DP_SUCCESS;
-	}
-	if (nss_phys_if_close(dp->nss_ctx, dp->if_num) == NSS_TX_SUCCESS) {
-		dp->notify_open = 0;
-		return NSS_DP_SUCCESS;
-	}
-	return NSS_DP_FAILURE;
-}
-
-/*
- * __nss_data_plane_link_state()
- *	Called by nss-dp to notify link state change to nss-fw
- */
-static int __nss_data_plane_link_state(struct nss_dp_data_plane_ctx *dpc, uint32_t link_state)
-{
-	struct nss_data_plane_edma_param *dp = (struct nss_data_plane_edma_param *)dpc;
-
-	return nss_phys_if_link_state(dp->nss_ctx, link_state, dp->if_num);
-}
-
-/*
- * __nss_data_plane_mac_addr()
- *	Called by nss-dp to set mac address
- */
-static int __nss_data_plane_mac_addr(struct nss_dp_data_plane_ctx *dpc, uint8_t *addr)
-{
-	struct nss_data_plane_edma_param *dp = (struct nss_data_plane_edma_param *)dpc;
-
-	return nss_phys_if_mac_addr(dp->nss_ctx, addr, dp->if_num);
-}
-
-/*
- * __nss_data_plane_change_mtu()
- *	Called by nss-dp to change mtu of a data plane
- */
-static int __nss_data_plane_change_mtu(struct nss_dp_data_plane_ctx *dpc, uint32_t mtu)
-{
-	struct nss_data_plane_edma_param *dp = (struct nss_data_plane_edma_param *)dpc;
-
-	if (mtu > NSS_DATA_PLANE_EDMA_MAX_MTU_SIZE) {
-		nss_warning("%p: MTU exceeds MAX size %d\n", dp, mtu);
-		return NSS_DP_FAILURE;
-	}
-
-	return nss_phys_if_change_mtu(dp->nss_ctx, mtu, dp->if_num);
-}
-
-/*
- * __nss_data_plane_pause_on_off()
- *	Called by nss-dp to enable/disable pause frames
- */
-static int __nss_data_plane_pause_on_off(struct nss_dp_data_plane_ctx *dpc, uint32_t pause_on)
-{
-	struct nss_data_plane_edma_param *dp = (struct nss_data_plane_edma_param *)dpc;
-
-	return nss_phys_if_pause_on_off(dp->nss_ctx, pause_on, dp->if_num);
-}
-
-/*
- * __nss_data_plane_vsi_assign()
- *	Called by nss-dp to assign vsi of a data plane
- */
-static int __nss_data_plane_vsi_assign(struct nss_dp_data_plane_ctx *dpc, uint32_t vsi)
-{
-	struct nss_data_plane_edma_param *dp = (struct nss_data_plane_edma_param *)dpc;
-
-	return nss_phys_if_vsi_assign(dp->nss_ctx, vsi, dp->if_num);
-}
-
-/*
- * __nss_data_plane_vsi_unassign()
- *	Called by nss-dp to unassign vsi of a data plane
- */
-static int __nss_data_plane_vsi_unassign(struct nss_dp_data_plane_ctx *dpc, uint32_t vsi)
-{
-	struct nss_data_plane_edma_param *dp = (struct nss_data_plane_edma_param *)dpc;
-
-	return nss_phys_if_vsi_unassign(dp->nss_ctx, vsi, dp->if_num);
-}
-
-#ifdef NSS_DRV_QRFS_ENABLE
-/*
- * __nss_data_plane_rx_flow_steer()
- *	Called by nss-dp to set flow rule of a data plane
- */
-static int __nss_data_plane_rx_flow_steer(struct nss_dp_data_plane_ctx *dpc, struct sk_buff *skb,
-						uint32_t cpu, bool is_add)
-{
-	if (is_add) {
-		return nss_qrfs_set_flow_rule(skb, cpu, NSS_QRFS_MSG_FLOW_ADD);
-	}
-
-	return nss_qrfs_set_flow_rule(skb, cpu, NSS_QRFS_MSG_FLOW_DELETE);
-}
-#endif
-
-/*
- * __nss_data_plane_deinit()
- *	Place holder for nss-dp ops to free NSS data plane resources
- */
-static int __nss_data_plane_deinit(struct nss_dp_data_plane_ctx *dpc)
-{
-	/*
-	 * TODO: Implement free up of NSS data plane resources
-	 */
-	return NSS_TX_SUCCESS;
-}
-
-/*
- * __nss_data_plane_buf()
- *	Called by nss-dp to pass a sk_buff for xmit
- */
-static netdev_tx_t __nss_data_plane_buf(struct nss_dp_data_plane_ctx *dpc, struct sk_buff *skb)
-{
-	struct nss_data_plane_edma_param *dp = (struct nss_data_plane_edma_param *)dpc;
-	int extra_head = dpc->dev->needed_headroom - skb_headroom(skb);
-	int extra_tail = 0;
-	nss_tx_status_t status;
-	struct net_device *dev = dpc->dev;
-
-	if (skb->len < ETH_HLEN) {
-		nss_warning("skb->len ( %u ) < ETH_HLEN ( %u ) \n", skb->len, ETH_HLEN);
-		goto drop;
-	}
-
-	if (skb->len > NSS_DATA_PLANE_EDMA_MAX_PACKET_LEN) {
-		nss_warning("skb->len ( %u ) > Maximum packet length ( %u ) \n", skb->len, NSS_DATA_PLANE_EDMA_MAX_PACKET_LEN);
-		goto drop;
-	}
-
-	if (skb_cloned(skb) || extra_head > 0) {
-		/*
-		 * If it is a clone and headroom is already enough,
-		 * We just make a copy and clear the clone flag.
-		 */
-		if (extra_head <= 0)
-			extra_head = extra_tail = 0;
-		/*
-		 * If tailroom is enough to accommodate the added headroom,
-		 * then allocate a buffer of same size and do relocations.
-		 * It might help kmalloc_reserve() not double the size.
-		 */
-		if (skb->end - skb->tail >= extra_head)
-			extra_tail = -extra_head;
-
-		if (pskb_expand_head(skb, extra_head, extra_tail, GFP_ATOMIC)) {
-			nss_warning("%p: Unable to expand skb for headroom\n", dp);
-			goto drop;
-		}
-	}
-
-	status = nss_phys_if_buf(dp->nss_ctx, skb, dp->if_num);
-	if (likely(status == NSS_TX_SUCCESS)) {
-		return NETDEV_TX_OK;
-	} else if (status == NSS_TX_FAILURE_QUEUE) {
-		return NETDEV_TX_BUSY;
-	}
-
-drop:
-	dev_kfree_skb_any(skb);
-	dev->stats.tx_dropped++;
-
-	return NETDEV_TX_OK;
-}
-
-/*
- * __nss_data_plane_set_features()
- *	Called by nss-dp to allow data plane to modify the set of features it supports
-*/
-static void __nss_data_plane_set_features(struct nss_dp_data_plane_ctx *dpc)
-{
-	dpc->dev->features |= NSS_DP_EDMA_SUPPORTED_FEATURES;
-	dpc->dev->hw_features |= NSS_DP_EDMA_SUPPORTED_FEATURES;
-	dpc->dev->vlan_features |= NSS_DP_EDMA_SUPPORTED_FEATURES;
-	dpc->dev->wanted_features |= NSS_DP_EDMA_SUPPORTED_FEATURES;
-}
-
-/*
- * nss offload data plane ops
- */
-static struct nss_dp_data_plane_ops dp_ops = {
-	.init		= __nss_data_plane_init,
-	.open		= __nss_data_plane_open,
-	.close		= __nss_data_plane_close,
-	.link_state	= __nss_data_plane_link_state,
-	.mac_addr	= __nss_data_plane_mac_addr,
-	.change_mtu	= __nss_data_plane_change_mtu,
-	.xmit		= __nss_data_plane_buf,
-	.set_features	= __nss_data_plane_set_features,
-	.pause_on_off	= __nss_data_plane_pause_on_off,
-	.vsi_assign	= __nss_data_plane_vsi_assign,
-	.vsi_unassign	= __nss_data_plane_vsi_unassign,
-#ifdef NSS_DRV_QRFS_ENABLE
-	.rx_flow_steer	= __nss_data_plane_rx_flow_steer,
-#endif
-	.deinit		= __nss_data_plane_deinit,
-};
-
-/*
- * nss_data_plane_register_to_nss_dp()
- */
-static bool nss_data_plane_register_to_nss_dp(struct nss_ctx_instance *nss_ctx, int if_num)
-{
-	struct nss_data_plane_edma_param *ndpp = &nss_data_plane_edma_params[if_num];
-	struct nss_top_instance *nss_top = nss_ctx->nss_top;
-	struct net_device *netdev;
-	bool is_open;
-	int core;
-
-	netdev = nss_dp_get_netdev_by_macid(if_num);
-	if (!netdev) {
-		nss_info("%p: Platform don't have data plane%d enabled, don't bring up nss_phys_if and don't register to nss-dp\n", nss_ctx, if_num);
-		return false;
-	}
-
-	is_open = nss_dp_is_in_open_state(netdev);
-	ndpp->dpc.dev = netdev;
-	ndpp->nss_ctx = nss_ctx;
-	ndpp->if_num = if_num;
-	ndpp->notify_open = 0;
-	ndpp->features = 0;
-
-	/*
-	 * Check if NSS NW processing to be bypassed for this data plane
-	 */
-	if (nss_skip_nw_process) {
-		ndpp->bypass_nw_process = 1;
-	} else {
-		ndpp->bypass_nw_process = 0;
-	}
-
-	if (nss_dp_override_data_plane(netdev, &dp_ops, (struct nss_dp_data_plane_ctx *)ndpp) != NSS_DP_SUCCESS) {
-		nss_info("%p: Override nss-dp data plane for port %dfailed\n", nss_ctx, if_num);
-		return false;
-	}
-
-	/*
-	 * Setup the receive callback so that data pkts received form NSS-FW will
-	 * be redirected to the nss-dp driver as we are overriding the data plane
-	 */
-	nss_top->phys_if_handler_id[if_num] = nss_ctx->id;
-	nss_phys_if_register_handler(nss_ctx, if_num);
-
-	/*
-	 * Packets recieved on physical interface can be exceptioned to HLOS
-	 * from any NSS core so we need to register data plane for all
-	 */
-	for (core = 0; core < nss_top->num_nss; core++) {
-		nss_core_register_subsys_dp(&nss_top->nss[core], if_num, nss_dp_receive, NULL, NULL, netdev, ndpp->features);
-	}
-
-	/*
-	 * Now we are registered and our side is ready, if the data plane was opened, ask it to start again
-	 */
-	if (is_open) {
-		nss_dp_start_data_plane(netdev, (struct nss_dp_data_plane_ctx *)ndpp);
-	}
-	return true;
-}
-
-/*
- * nss_data_plane_unregister_from_nss_dp()
- */
-static void nss_data_plane_unregister_from_nss_dp(int if_num)
-{
-	nss_cmn_unregister_service_code(nss_data_plane_edma_params[if_num].nss_ctx,
-			nss_phy_tstamp_rx_buf, NSS_PTP_EVENT_SERVICE_CODE);
-	nss_dp_restore_data_plane(nss_data_plane_edma_params[if_num].dpc.dev);
-	nss_data_plane_edma_params[if_num].dpc.dev = NULL;
-	nss_data_plane_edma_params[if_num].nss_ctx = NULL;
-	nss_data_plane_edma_params[if_num].if_num = 0;
-	nss_data_plane_edma_params[if_num].notify_open = 0;
-	nss_data_plane_edma_params[if_num].bypass_nw_process = 0;
-}
-
-/*
- * __nss_data_plane_register()
- */
-static void __nss_data_plane_register(struct nss_ctx_instance *nss_ctx)
-{
-	int i;
-
-	for (i = 1; i < NSS_DATA_PLANE_EDMA_MAX_INTERFACES + 1; i++) {
-		if (!nss_data_plane_register_to_nss_dp(nss_ctx, i)) {
-			nss_warning("%p: Register data plane failed for data plane %d\n", nss_ctx, i);
-		} else {
-			nss_info("%p: Register data plan to data plane %d success\n", nss_ctx, i);
-		}
-	}
-
-	/*
-	 * Packets with the ptp service code should be delivered to PHY driver for timestamping
-	 */
-	nss_cmn_register_service_code(nss_ctx, nss_phy_tstamp_rx_buf,
-			NSS_PTP_EVENT_SERVICE_CODE, nss_ctx);
-
-}
-
-/*
- * __nss_data_plane_unregister()
- */
-static void __nss_data_plane_unregister(void)
-{
-	int i, core;
-
-	for (core = 0; core < nss_top_main.num_nss; core++) {
-		for (i = 1; i < NSS_DATA_PLANE_EDMA_MAX_INTERFACES + 1; i++) {
-			if (nss_top_main.nss[core].subsys_dp_register[i].ndev) {
-				nss_data_plane_unregister_from_nss_dp(i);
-				nss_core_unregister_subsys_dp(&nss_top_main.nss[core], i);
-			}
-		}
-	}
-}
-
-/*
- * __nss_data_plane_stats_sync()
- */
-static void __nss_data_plane_stats_sync(struct nss_phys_if_stats *stats, uint16_t interface)
-{
-	/*
-	 * EDMA does not pass sync interface stats through phys_if_stats
-	 */
-}
-
-/*
- * __nss_data_plane_get_mtu_sz()
- */
-static uint16_t __nss_data_plane_get_mtu_sz(uint16_t mtu)
-{
-	/*
-	 * Reserve space for preheader
-	 */
-	return mtu + NSS_DATA_PLANE_EDMA_PREHEADER_SIZE;
-}
-
-/*
- * nss_data_plane_edma_ops
- */
-struct nss_data_plane_ops nss_data_plane_edma_ops = {
-	.data_plane_register = &__nss_data_plane_register,
-	.data_plane_unregister = &__nss_data_plane_unregister,
-	.data_plane_stats_sync = &__nss_data_plane_stats_sync,
-	.data_plane_get_mtu_sz = &__nss_data_plane_get_mtu_sz,
-};
--- a/nss_data_plane/nss_data_plane_gmac.c
+++ b/nss_data_plane/nss_data_plane_gmac.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -250,9 +250,9 @@ static void __nss_data_plane_register(st
 
 	for (i = 0; i < NSS_DATA_PLANE_GMAC_MAX_INTERFACES; i++) {
 		if (!nss_data_plane_register_to_nss_gmac(nss_ctx, i)) {
-			nss_warning("%p: Register data plane failed for gmac:%d\n", nss_ctx, i);
+			nss_warning("%px: Register data plane failed for gmac:%d\n", nss_ctx, i);
 		} else {
-			nss_info("%p: Register data plan to gmac:%d success\n", nss_ctx, i);
+			nss_info("%px: Register data plan to gmac:%d success\n", nss_ctx, i);
 		}
 	}
 }
--- /dev/null
+++ b/nss_dma.c
@@ -0,0 +1,501 @@
+/*
+ **************************************************************************
+ * Copyright (c) 2020, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for
+ * any purpose with or without fee is hereby granted, provided that the
+ * above copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ **************************************************************************
+ */
+
+/*
+ * nss_dma.c
+ *	NSS DMA APIs
+ */
+
+#include <nss_hal.h>
+#include "nss_dma_stats.h"
+#include "nss_dma_log.h"
+#include "nss_dma_strings.h"
+
+/*
+ * Test configuration value
+ */
+struct nss_dma_test_cfg_val {
+	int val;			/* field value */
+	int min;			/* Minimum value */
+	int max;			/* Maximum value */
+};
+
+/*
+ * Test configuration for user
+ */
+struct nss_dma_test_cfg_user {
+	struct nss_dma_test_cfg_val run;	/* test run state */
+	struct nss_dma_test_cfg_val code;	/* test run code */
+	struct nss_dma_test_cfg_val type;	/* test type code */
+	struct nss_dma_test_cfg_val packets;	/* packet count per loop */
+	int result_tx_packets;			/* test results TX packets */
+	int result_rx_packets;			/* test result RX packets */
+	int result_time;			/* test time */
+};
+
+static struct nss_dma_test_cfg_user test_cfg = {
+	.run = {.val = 0, .min = 0 /* stopped */, .max = 1 /* running */},
+	.code = {.val = 1, .min = 1 /* linearize */, .max = 2 /* split */},
+	.type = {.val = NSS_DMA_TEST_TYPE_DEFAULT, .min = NSS_DMA_TEST_TYPE_DEFAULT, .max = NSS_DMA_TEST_TYPE_MAX},
+	.packets = {.val = 1, .min = 1, .max = 65536},
+};
+
+/*
+ * Private data structure.
+ */
+struct nss_dma_pvt {
+	struct semaphore sem;		/* Semaphore structure. */
+	struct completion complete;	/* Completion structure. */
+	int response;			/* Response from FW. */
+	void *cb;			/* Original cb for sync msgs. */
+	void *app_data;			/* Original app_data for sync msgs. */
+};
+
+static struct nss_dma_pvt nss_dma_cfg_pvt;
+
+/*
+ * nss_dma_verify_if_num()
+ *	Verify if_num passed to us.
+ */
+static inline bool nss_dma_verify_if_num(uint32_t if_num)
+{
+	return if_num == NSS_DMA_INTERFACE;
+}
+
+/*
+ * nss_dma_interface_handler()
+ *	Handle NSS -> HLOS messages for DMA Statistics
+ */
+static void nss_dma_msg_handler(struct nss_ctx_instance *nss_ctx, struct nss_cmn_msg *ncm,
+				 __attribute__((unused))void *app_data)
+{
+	struct nss_dma_msg *ndm = (struct nss_dma_msg *)ncm;
+	nss_dma_msg_callback_t cb;
+
+	if (!nss_dma_verify_if_num(ncm->interface)) {
+		nss_warning("%px: invalid interface %d for dma\n", nss_ctx, ncm->interface);
+		return;
+	}
+
+	/*
+	 * Is this a valid request/response packet?
+	 */
+	if (ncm->type >= NSS_DMA_MSG_TYPE_MAX) {
+		nss_warning("%px: received invalid message %d for dma", nss_ctx, ncm->type);
+		return;
+	}
+
+	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_dma_msg)) {
+		nss_warning("%px: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		return;
+	}
+
+	/*
+	 * Trace messages.
+	 */
+	nss_dma_log_rx_msg(ndm);
+
+	/*
+	 * Log failures
+	 */
+	nss_core_log_msg_failures(nss_ctx, ncm);
+
+	/*
+	 * Update driver statistics and send statistics notifications to the registered modules.
+	 */
+	if (ndm->cm.type == NSS_DMA_MSG_TYPE_SYNC_STATS) {
+		nss_dma_stats_sync(nss_ctx, &ndm->msg.stats);
+
+	}
+
+	/*
+	 * Update the callback and app_data for NOTIFY messages
+	 */
+	if (ncm->response == NSS_CMN_RESPONSE_NOTIFY) {
+		ncm->cb = (nss_ptr_t)nss_core_get_msg_handler(nss_ctx, ncm->interface);
+		ncm->app_data = (nss_ptr_t)nss_ctx->nss_rx_interface_handlers[nss_ctx->id][ncm->interface].app_data;
+	}
+
+	/*
+	 * Do we have a callback?
+	 */
+	if (!ncm->cb) {
+		return;
+	}
+
+	/*
+	 * callback
+	 */
+	cb = (nss_dma_msg_callback_t)ncm->cb;
+	cb((void *)ncm->app_data, ncm);
+}
+
+/*
+ * nss_dma_register_handler()
+ *	Register handler for messaging
+ */
+void nss_dma_register_handler(void)
+{
+	struct nss_ctx_instance *nss_ctx = nss_dma_get_context();
+
+	nss_info("%px: nss_dma_register_handler", nss_ctx);
+	nss_core_register_handler(nss_ctx, NSS_DMA_INTERFACE, nss_dma_msg_handler, NULL);
+
+	nss_dma_stats_dentry_create();
+	nss_dma_strings_dentry_create();
+}
+EXPORT_SYMBOL(nss_dma_register_handler);
+
+/*
+ * nss_dma_tx_msg()
+ *	Transmit an dma message to the FW with a specified size.
+ */
+nss_tx_status_t nss_dma_tx_msg(struct nss_ctx_instance *nss_ctx, struct nss_dma_msg *ndm)
+{
+	struct nss_cmn_msg *ncm = &ndm->cm;
+
+	/*
+	 * Sanity check the message
+	 */
+	if (!nss_dma_verify_if_num(ncm->interface)) {
+		nss_warning("%px: tx request for another interface: %d", nss_ctx, ncm->interface);
+		return NSS_TX_FAILURE;
+	}
+
+	if (ncm->type >= NSS_DMA_MSG_TYPE_MAX) {
+		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
+		return NSS_TX_FAILURE;
+	}
+
+	/*
+	 * Trace messages.
+	 */
+	nss_dma_log_tx_msg(ndm);
+
+	return nss_core_send_cmd(nss_ctx, ndm, sizeof(*ndm), NSS_NBUF_PAYLOAD_SIZE);
+}
+EXPORT_SYMBOL(nss_dma_tx_msg);
+
+/*
+ * nss_dma_msg_test_callback()
+ *	Callback function for dma test start configuration
+ */
+static void nss_dma_msg_test_callback(void *app_data, struct nss_cmn_msg *ncm)
+{
+	struct nss_ctx_instance *nss_ctx __attribute__((unused)) = (struct nss_ctx_instance *)app_data;
+	struct nss_dma_msg *ndm = (struct nss_dma_msg *)ncm;
+	struct nss_dma_test_cfg *ndtc = &ndm->msg.test_cfg;
+	struct nss_cmn_node_stats *ncns = &ndtc->node_stats;
+
+	test_cfg.run.val = 0; /* test completed */
+
+	/*
+	 * Test start has been failed. Restore the value to initial state.
+	 */
+	if (ndm->cm.response != NSS_CMN_RESPONSE_ACK) {
+		nss_warning("%px: nss dma test failed: %d \n", nss_ctx, ndm->cm.error);
+		test_cfg.result_tx_packets = 0;
+		test_cfg.result_rx_packets = 0;
+		test_cfg.result_time = 0;
+		return;
+	}
+
+	test_cfg.result_tx_packets = ncns->tx_packets;
+	test_cfg.result_rx_packets = ncns->rx_packets;
+	test_cfg.result_time = ndtc->time_delta;
+
+	nss_info("%px: nss dma test complete\n", nss_ctx);
+	nss_info("%px: results tx=%u, rx=%u, time=%u\n", ndm, ncns->tx_packets, ncns->rx_packets, ndtc->time_delta);
+}
+
+/*
+ * nss_dma_msg_test()
+ *	Send NSS DMA test start message.
+ */
+static nss_tx_status_t nss_dma_msg_test(struct nss_ctx_instance *nss_ctx)
+{
+	struct nss_dma_msg ndm;
+	uint32_t flags = 0;
+	int32_t status;
+	size_t len;
+
+	len = sizeof(struct nss_cmn_msg) + sizeof(struct nss_dma_test_cfg);
+
+	nss_info("%px: DMA test message:%x\n", nss_ctx, test_cfg.run.val);
+	if (test_cfg.code.val == 1) {
+		flags = NSS_DMA_TEST_FLAGS_LINEARIZE;
+	}
+
+	nss_dma_msg_init(&ndm, NSS_DMA_INTERFACE, NSS_DMA_MSG_TYPE_TEST_PERF, len, nss_dma_msg_test_callback, nss_ctx);
+
+	ndm.msg.test_cfg.packet_count = test_cfg.packets.val;
+	ndm.msg.test_cfg.type = test_cfg.type.val;
+	ndm.msg.test_cfg.flags = flags;
+
+	status = nss_dma_tx_msg(nss_ctx, &ndm);
+	if (unlikely(status != NSS_TX_SUCCESS)) {
+		return status;
+	}
+
+	/*
+	 * Test is now running
+	 */
+	test_cfg.run.val = 1;
+	return NSS_TX_SUCCESS;
+}
+
+/*
+ * nss_dma_msg_init()
+ *	Initialize DMA message.
+ */
+void nss_dma_msg_init(struct nss_dma_msg *ndm, uint16_t if_num, uint32_t type, uint32_t len, nss_dma_msg_callback_t cb,
+			void *app_data)
+{
+	nss_cmn_msg_init(&ndm->cm, if_num, type, len, (void *)cb, app_data);
+}
+EXPORT_SYMBOL(nss_dma_msg_init);
+
+/*
+ * nss_crypto_cmn_get_context()
+ *	get NSS context instance for crypto handle
+ */
+struct nss_ctx_instance *nss_dma_get_context(void)
+{
+	return (struct nss_ctx_instance *)&nss_top_main.nss[nss_top_main.dma_handler_id];
+}
+EXPORT_SYMBOL(nss_dma_get_context);
+
+/*
+ * nss_dma_test_handler()
+ *	Handles the performance test.
+ */
+static int nss_dma_test_handler(struct ctl_table *ctl, int write, void __user *buffer, size_t *lenp, loff_t *ppos)
+{
+	struct nss_ctx_instance *nss_ctx = nss_dma_get_context();
+	int cur_state = test_cfg.run.val;
+	int ret;
+
+	ret = proc_dointvec(ctl, write, buffer, lenp, ppos);
+	if (ret != NSS_SUCCESS) {
+		return ret;
+	}
+
+	if (!write) {
+		return ret;
+	}
+
+	/*
+	 * Check any tests are already scheduled
+	 */
+	if (cur_state > 0) {
+		nss_info("%px: Test is already running, stopping it.\n", nss_ctx);
+	} else {
+		nss_info("%px: Test is not running, starting it.\n", nss_ctx);
+	}
+
+	ret = nss_dma_msg_test(nss_ctx);
+	if (ret != NSS_SUCCESS) {
+		nss_warning("%px: Test configuration has failed.\n", nss_ctx);
+		test_cfg.run.val = 0;
+	}
+
+	return ret;
+}
+
+static struct ctl_table nss_dma_table[] = {
+	{
+		.procname	= "test_run",
+		.data		= &test_cfg.run.val,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= nss_dma_test_handler,
+		.extra1		= &test_cfg.run.min,
+		.extra2		= &test_cfg.run.max,
+	},
+	{
+		.procname	= "test_code",
+		.data		= &test_cfg.code.val,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec_minmax,
+		.extra1		= &test_cfg.code.min,
+		.extra2		= &test_cfg.code.max,
+	},
+	{
+		.procname	= "test_type",
+		.data		= &test_cfg.type.val,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec_minmax,
+		.extra1		= &test_cfg.type.min,
+		.extra2		= &test_cfg.type.max,
+	},
+	{
+		.procname	= "test_packets",
+		.data		= &test_cfg.packets.val,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec_minmax,
+		.extra1		= &test_cfg.packets.min,
+		.extra2		= &test_cfg.packets.max,
+	},
+	{
+		.procname	= "result_tx",
+		.data		= &test_cfg.result_tx_packets,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+	{
+		.procname	= "result_rx",
+		.data		= &test_cfg.result_rx_packets,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+	{
+		.procname	= "result_time",
+		.data		= &test_cfg.result_time,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+	{ }
+};
+
+static struct ctl_table nss_dma_dir[] = {
+	{
+		.procname		= "dma",
+		.mode			= 0555,
+		.child			= nss_dma_table,
+	},
+	{ }
+};
+
+static struct ctl_table nss_dma_root_dir[] = {
+	{
+		.procname		= "nss",
+		.mode			= 0555,
+		.child			= nss_dma_dir,
+	},
+	{ }
+};
+
+static struct ctl_table nss_dma_root[] = {
+	{
+		.procname		= "dev",
+		.mode			= 0555,
+		.child			= nss_dma_root_dir,
+	},
+	{ }
+};
+
+static struct ctl_table_header *nss_dma_header;
+
+/*
+ * nss_dma_register_sysctl()
+ */
+void nss_dma_register_sysctl(void)
+{
+
+	/*
+	 * dma sema init.
+	 */
+	sema_init(&nss_dma_cfg_pvt.sem, 1);
+	init_completion(&nss_dma_cfg_pvt.complete);
+
+	/*
+	 * Register sysctl table.
+	 */
+	nss_dma_header = register_sysctl_table(nss_dma_root);
+}
+
+/*
+ * nss_dma_unregister_sysctl()
+ *      Unregister sysctl specific to dma
+ */
+void nss_dma_unregister_sysctl(void)
+{
+	/*
+	 * Unregister sysctl table.
+	 */
+	if (nss_dma_header) {
+		unregister_sysctl_table(nss_dma_header);
+	}
+}
+
+/*
+ * nss_dma_notify_register()
+ *	Register to receive dma notify messages.
+ */
+struct nss_ctx_instance *nss_dma_notify_register(int core, nss_dma_msg_callback_t cb, void *app_data)
+{
+	struct nss_ctx_instance *nss_ctx = nss_dma_get_context();
+	uint32_t ret;
+
+	ret = nss_core_register_handler(nss_ctx, NSS_DMA_INTERFACE, nss_dma_msg_handler, app_data);
+	if (ret != NSS_CORE_STATUS_SUCCESS) {
+		nss_warning("%px: unable to register event handler for DMA interface", nss_ctx);
+		return NULL;
+	}
+
+	ret = nss_core_register_msg_handler(nss_ctx, NSS_DMA_INTERFACE, cb);
+	if (ret != NSS_CORE_STATUS_SUCCESS) {
+		nss_core_unregister_handler(nss_ctx, NSS_DMA_INTERFACE);
+		nss_warning("%px: unable to register event handler for DMA interface", nss_ctx);
+		return NULL;
+	}
+
+	return nss_ctx;
+}
+EXPORT_SYMBOL(nss_dma_notify_register);
+
+/*
+ * nss_dma_notify_unregister()
+ *	Unregister to receive dma notify messages.
+ */
+void nss_dma_notify_unregister(int core)
+{
+	struct nss_ctx_instance *nss_ctx = nss_dma_get_context();
+	uint32_t ret;
+
+	BUG_ON(!nss_ctx);
+
+	ret = nss_core_unregister_msg_handler(nss_ctx, NSS_DMA_INTERFACE);
+	if (ret != NSS_CORE_STATUS_SUCCESS) {
+		nss_warning("%px: unable to unregister event handler for DMA interface", nss_ctx);
+		return;
+	}
+
+	ret = nss_core_unregister_handler(nss_ctx, NSS_DMA_INTERFACE);
+	if (ret != NSS_CORE_STATUS_SUCCESS) {
+		nss_warning("%px: unable to unregister event handler for DMA interface", nss_ctx);
+		return;
+	}
+
+	return;
+}
+EXPORT_SYMBOL(nss_dma_notify_unregister);
+
+/*
+ * nss_dma_init()
+ */
+void nss_dma_init(void)
+{
+	nss_dma_register_sysctl();
+}
--- /dev/null
+++ b/nss_dma_log.c
@@ -0,0 +1,140 @@
+/*
+ **************************************************************************
+ * Copyright (c) 2020, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for
+ * any purpose with or without fee is hereby granted, provided that the
+ * above copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ **************************************************************************
+ */
+
+/*
+ * nss_dma_log.c
+ *	NSS DMA logger file.
+ */
+
+#include "nss_core.h"
+
+/*
+ * nss_dma_log_message_types_str
+ *	DMA message strings
+ */
+static int8_t *nss_dma_log_message_types_str[NSS_DMA_MSG_TYPE_MAX] __maybe_unused = {
+	"DMA invalid message",
+	"DMA Configure message",
+	"DMA Statistics sync message",
+	"DMA Test linearization performance",
+};
+
+/*
+ * nss_dma_log_error_response_types_str
+ *	Strings for error types for DMA messages
+ */
+static int8_t *nss_dma_log_error_response_types_str[NSS_DMA_MSG_ERROR_MAX] __maybe_unused = {
+	"No error",
+	"HW initialization failed",
+	"Unhandled message type for node",
+	"Error performing the test",
+};
+
+/*
+ * nss_dma_map_msg()
+ *	Log NSS DMA configure message.
+ */
+static void nss_dma_configure_msg(struct nss_dma_msg *ndm)
+{
+	nss_trace("%px: NSS DMA configure message: \n",ndm);
+}
+
+/*
+ * nss_dma_test_perf_msg()
+ *	Log NSS DMA performace test message.
+ */
+static void nss_dma_test_perf_msg(struct nss_dma_msg *ndm)
+{
+	struct nss_dma_test_cfg *ndtc = &ndm->msg.test_cfg;
+	struct nss_cmn_node_stats *ncns = &ndtc->node_stats;
+
+	nss_trace("%px: NSS DMA test perf message: \n",ndm);
+	nss_trace("%px: processed (TX: %u, RX:%u, time:%u)\n", ndm, ncns->tx_packets, ncns->rx_packets, ndtc->time_delta);
+	nss_trace("%px: test parameters (type:%u, packet_cnt:%u)\n", ndm, ndtc->type, ndtc->packet_count);
+}
+
+/*
+ * nss_dma_log_verbose()
+ *	Log message contents.
+ */
+static void nss_dma_log_verbose(struct nss_dma_msg *ndm)
+{
+	switch (ndm->cm.type) {
+	case NSS_DMA_MSG_TYPE_CONFIGURE:
+		nss_dma_configure_msg(ndm);
+		break;
+
+	case NSS_DMA_MSG_TYPE_TEST_PERF:
+		nss_dma_test_perf_msg(ndm);
+		break;
+
+	default:
+		nss_trace("%px: Invalid message type\n", ndm);
+		break;
+	}
+}
+
+/*
+ * nss_dma_log_tx_msg()
+ *	Log messages transmitted to FW.
+ */
+void nss_dma_log_tx_msg(struct nss_dma_msg *ndm)
+{
+	if (ndm->cm.type >= NSS_DMA_MSG_TYPE_MAX) {
+		nss_info("%px: Invalid message type\n", ndm);
+		return;
+	}
+
+	nss_info("%px: type[%d]:%s\n", ndm, ndm->cm.type, nss_dma_log_message_types_str[ndm->cm.type]);
+	nss_dma_log_verbose(ndm);
+}
+
+/*
+ * nss_dma_log_rx_msg()
+ *	Log messages received from FW.
+ */
+void nss_dma_log_rx_msg(struct nss_dma_msg *ndm)
+{
+	if (ndm->cm.response >= NSS_CMN_RESPONSE_LAST) {
+		nss_warning("%px: Invalid response\n", ndm);
+		return;
+	}
+
+	if (ndm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (ndm->cm.response == NSS_CMN_RESPONSE_ACK)) {
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", ndm, ndm->cm.type,
+			nss_dma_log_message_types_str[ndm->cm.type],
+			ndm->cm.response, nss_cmn_response_str[ndm->cm.response]);
+		goto verbose;
+	}
+
+	if (ndm->cm.error >= NSS_DMA_MSG_ERROR_MAX) {
+		nss_warning("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
+			ndm, ndm->cm.type, nss_dma_log_message_types_str[ndm->cm.type],
+			ndm->cm.response, nss_cmn_response_str[ndm->cm.response],
+			ndm->cm.error);
+		goto verbose;
+	}
+
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
+		ndm, ndm->cm.type, nss_dma_log_message_types_str[ndm->cm.type],
+		ndm->cm.response, nss_cmn_response_str[ndm->cm.response],
+		ndm->cm.error, nss_dma_log_error_response_types_str[ndm->cm.error]);
+
+verbose:
+	nss_dma_log_verbose(ndm);
+}
--- /dev/null
+++ b/nss_dma_log.h
@@ -0,0 +1,38 @@
+/*
+ ******************************************************************************
+ * Copyright (c) 2020, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for
+ * any purpose with or without fee is hereby granted, provided that the
+ * above copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * ****************************************************************************
+ */
+
+#ifndef __NSS_DMA_LOG_H
+#define __NSS_DMA_LOG_H
+/*
+ * nss_dma_log.h
+ *	NSS DMA Log Header File
+ */
+
+/*
+ * nss_dma_log_tx_msg
+ *	Logs an DMA message that is sent to the NSS firmware.
+ */
+void nss_dma_log_tx_msg(struct nss_dma_msg *ndm);
+
+/*
+ * nss_dma_log_rx_msg
+ *	Logs an DMA message that is received from the NSS firmware.
+ */
+void nss_dma_log_rx_msg(struct nss_dma_msg *ndm);
+
+#endif /* __NSS_DMA_LOG_H */
--- /dev/null
+++ b/nss_dma_stats.c
@@ -0,0 +1,119 @@
+/*
+ **************************************************************************
+ * Copyright (c) 2020, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for
+ * any purpose with or without fee is hereby granted, provided that the
+ * above copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ **************************************************************************
+ */
+
+#include "nss_core.h"
+#include "nss_dma_stats.h"
+#include "nss_dma_strings.h"
+
+/*
+ * Spinlock to protect DMA statistics update/read
+ */
+DEFINE_SPINLOCK(nss_dma_stats_lock);
+
+/*
+ * nss_dma_stats
+ *	DMA statistics
+ */
+uint64_t nss_dma_stats[NSS_DMA_STATS_MAX];
+
+/*
+ * nss_dma_stats_read()
+ *	Read DMA statistics
+ */
+static ssize_t nss_dma_stats_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
+{
+	/*
+	 * Max output lines = #stats * NSS_MAX_CORES  +
+	 * few blank lines for banner printing + Number of Extra outputlines for future reference to add new stats
+	 */
+	uint32_t max_output_lines = NSS_DMA_STATS_MAX  + NSS_STATS_EXTRA_OUTPUT_LINES;
+	size_t size_al = NSS_STATS_MAX_STR_LENGTH * max_output_lines;
+	uint64_t *stats_shadow;
+	ssize_t bytes_read = 0;
+	size_t size_wr = 0;
+	char *lbuf;
+	int32_t i;
+
+	lbuf = vzalloc(size_al);
+	if (!lbuf) {
+		nss_warning("Could not allocate memory for local statistics buffer");
+		return -ENOMEM;
+	}
+
+	stats_shadow = vzalloc(NSS_DMA_STATS_MAX * 8);
+	if (!stats_shadow) {
+		nss_warning("Could not allocate memory for local shadow buffer");
+		vfree(lbuf);
+		return -ENOMEM;
+	}
+
+	/*
+	 * DMA statistics
+	 */
+	spin_lock_bh(&nss_dma_stats_lock);
+	for (i = 0; i < NSS_DMA_STATS_MAX; i++) {
+		stats_shadow[i] = nss_dma_stats[i];
+	}
+	spin_unlock_bh(&nss_dma_stats_lock);
+
+	size_wr += nss_stats_banner(lbuf, size_wr, size_al, "dma", nss_top_main.dma_handler_id);
+	size_wr += nss_stats_print("dma", NULL, NSS_STATS_SINGLE_INSTANCE, nss_dma_strings_stats,
+				stats_shadow, NSS_DMA_STATS_MAX, lbuf, size_wr, size_al);
+
+	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, strlen(lbuf));
+
+	vfree(lbuf);
+	vfree(stats_shadow);
+	return bytes_read;
+}
+
+/*
+ * nss_dma_stats_ops
+ */
+NSS_STATS_DECLARE_FILE_OPERATIONS(dma);
+
+/*
+ * nss_dma_stats_dentry_create()
+ *	Create DMA statistics debug entry.
+ */
+void nss_dma_stats_dentry_create(void)
+{
+	nss_stats_create_dentry("dma", &nss_dma_stats_ops);
+}
+
+/*
+ * nss_dma_stats_sync()
+ *	Handle the syncing of NSS DMA statistics.
+ */
+void nss_dma_stats_sync(struct nss_ctx_instance *nss_ctx, struct nss_dma_stats *nds)
+{
+	uint64_t *dma_stats;
+	uint32_t *msg_stats;
+	uint16_t i = 0;
+
+	spin_lock_bh(&nss_dma_stats_lock);
+
+	msg_stats = (uint32_t *)nds;
+	dma_stats = nss_dma_stats;
+
+	for (i = 0; i < NSS_DMA_STATS_MAX; i++, dma_stats++, msg_stats++) {
+		*dma_stats += *msg_stats;
+	}
+
+	spin_unlock_bh(&nss_dma_stats_lock);
+}
--- /dev/null
+++ b/nss_dma_stats.h
@@ -0,0 +1,65 @@
+/*
+ ******************************************************************************
+ * Copyright (c) 2020, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for
+ * any purpose with or without fee is hereby granted, provided that the
+ * above copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * ****************************************************************************
+ */
+
+#ifndef __NSS_DMA_STATS_H
+#define __NSS_DMA_STATS_H
+
+#include <nss_cmn.h>
+
+/**
+ * nss_dma_stats_types
+ *	DMA node statistics.
+ */
+enum nss_dma_stats_types {
+	NSS_DMA_STATS_NO_REQ = NSS_STATS_NODE_MAX,	/**< Request descriptor not available. */
+	NSS_DMA_STATS_NO_DESC,				/**< DMA descriptors not available. */
+	NSS_DMA_STATS_NEXTHOP,				/**< Failed to retrive next hop. */
+	NSS_DMA_STATS_FAIL_NEXTHOP_QUEUE,		/**< Failed to queue next hop. */
+	NSS_DMA_STATS_FAIL_LINEAR_SZ,			/**< Failed to get memory for linearization. */
+	NSS_DMA_STATS_FAIL_LINEAR_ALLOC,		/**< Failed to allocate buffer for linearization. */
+	NSS_DMA_STATS_FAIL_LINEAR_NO_SG,		/**< Skip linearization due to non-SG packet. */
+	NSS_DMA_STATS_FAIL_SPLIT_SZ,			/**< Failed to spliting buffer into multiple buffers. */
+	NSS_DMA_STATS_FAIL_SPLIT_ALLOC,			/**< Failed to allocate buffer for split. */
+	NSS_DMA_STATS_FAIL_SYNC_ALLOC,			/**< Failed to allocate buffer for sending statistics. */
+	NSS_DMA_STATS_FAIL_CTX_ACTIVE,			/**< Failed to queue as the node is not active. */
+	NSS_DMA_STATS_FAIL_HW_E0,			/**< Failed to process in HW, error code E0. */
+	NSS_DMA_STATS_FAIL_HW_E1,			/**< Failed to process in HW, error code E1. */
+	NSS_DMA_STATS_FAIL_HW_E2,			/**< Failed to process in HW, error code E2. */
+	NSS_DMA_STATS_FAIL_HW_E3,			/**< Failed to process in HW, error code E3. */
+	NSS_DMA_STATS_FAIL_HW_E4,			/**< Failed to process in HW, error code E4. */
+	NSS_DMA_STATS_FAIL_HW_E5,			/**< Failed to process in HW, error code E5. */
+	NSS_DMA_STATS_FAIL_HW_E6,			/**< Failed to process in HW, error code E6. */
+	NSS_DMA_STATS_FAIL_HW_E7,			/**< Failed to process in HW, error code E7. */
+	NSS_DMA_STATS_FAIL_HW_E8,			/**< Failed to process in HW, error code E8. */
+	NSS_DMA_STATS_FAIL_HW_E9,			/**< Failed to process in HW, error code E9. */
+	NSS_DMA_STATS_FAIL_HW_E10,			/**< Failed to process in HW, error code E10. */
+	NSS_DMA_STATS_FAIL_HW_E11,			/**< Failed to process in HW, error code E11. */
+	NSS_DMA_STATS_FAIL_HW_E12,			/**< Failed to process in HW, error code E12. */
+	NSS_DMA_STATS_FAIL_HW_E13,			/**< Failed to process in HW, error code E13. */
+	NSS_DMA_STATS_FAIL_HW_E14,			/**< Failed to process in HW, error code E14. */
+	NSS_DMA_STATS_FAIL_HW_E15,			/**< Failed to process in HW, error code E15. */
+	NSS_DMA_STATS_MAX,				/**< Maximum message type. */
+};
+
+/*
+ * DMA statistics APIs
+ */
+extern void nss_dma_stats_sync(struct nss_ctx_instance *nss_ctx, struct nss_dma_stats *nds);
+extern void nss_dma_stats_dentry_create(void);
+
+#endif /* __NSS_DMA_STATS_H */
--- /dev/null
+++ b/nss_dma_strings.c
@@ -0,0 +1,88 @@
+/*
+ **************************************************************************
+ * Copyright (c) 2020, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for
+ * any purpose with or without fee is hereby granted, provided that the
+ * above copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ **************************************************************************
+ */
+
+#include "nss_stats.h"
+#include "nss_core.h"
+#include "nss_strings.h"
+#include "nss_dma_stats.h"
+
+/*
+ * nss_dma_strings_stats
+ *	DMA statistics strings.
+ */
+struct nss_stats_info nss_dma_strings_stats[NSS_DMA_STATS_MAX] = {
+	{"rx_pkts"		, NSS_STATS_TYPE_COMMON},
+	{"rx_byts"		, NSS_STATS_TYPE_COMMON},
+	{"tx_pkts"		, NSS_STATS_TYPE_COMMON},
+	{"tx_byts"		, NSS_STATS_TYPE_COMMON},
+	{"rx_queue[0]_drops"	, NSS_STATS_TYPE_DROP},
+	{"rx_queue[1]_drops"	, NSS_STATS_TYPE_DROP},
+	{"rx_queue[2]_drops"	, NSS_STATS_TYPE_DROP},
+	{"rx_queue[3]_drops"	, NSS_STATS_TYPE_DROP},
+	{"no_req"		, NSS_STATS_TYPE_SPECIAL},
+	{"no_desc"		, NSS_STATS_TYPE_SPECIAL},
+	{"fail_nexthop"		, NSS_STATS_TYPE_SPECIAL},
+	{"fail_nexthop_queue"	, NSS_STATS_TYPE_SPECIAL},
+	{"fail_linear_sz"	, NSS_STATS_TYPE_SPECIAL},
+	{"fail_linear_alloc"	, NSS_STATS_TYPE_SPECIAL},
+	{"fail_linear_no_sg"	, NSS_STATS_TYPE_SPECIAL},
+	{"fail_split_sz"	, NSS_STATS_TYPE_SPECIAL},
+	{"fail_split_alloc"	, NSS_STATS_TYPE_SPECIAL},
+	{"fail_sync_alloc"	, NSS_STATS_TYPE_SPECIAL},
+	{"fail_ctx_active"	, NSS_STATS_TYPE_SPECIAL},
+	{"fail_hw[0]"		, NSS_STATS_TYPE_SPECIAL},
+	{"fail_hw[1]"		, NSS_STATS_TYPE_SPECIAL},
+	{"fail_hw[2]"		, NSS_STATS_TYPE_SPECIAL},
+	{"fail_hw[3]"		, NSS_STATS_TYPE_SPECIAL},
+	{"fail_hw[4]"		, NSS_STATS_TYPE_SPECIAL},
+	{"fail_hw[5]"		, NSS_STATS_TYPE_SPECIAL},
+	{"fail_hw[6]"		, NSS_STATS_TYPE_SPECIAL},
+	{"fail_hw[7]"		, NSS_STATS_TYPE_SPECIAL},
+	{"fail_hw[8]"		, NSS_STATS_TYPE_SPECIAL},
+	{"fail_hw[9]"		, NSS_STATS_TYPE_SPECIAL},
+	{"fail_hw[10]"		, NSS_STATS_TYPE_SPECIAL},
+	{"fail_hw[11]"		, NSS_STATS_TYPE_SPECIAL},
+	{"fail_hw[12]"		, NSS_STATS_TYPE_SPECIAL},
+	{"fail_hw[13]"		, NSS_STATS_TYPE_SPECIAL},
+	{"fail_hw[14]"		, NSS_STATS_TYPE_SPECIAL},
+	{"fail_hw[15]"		, NSS_STATS_TYPE_SPECIAL},
+};
+
+
+/*
+ * nss_dma_strings_read()
+ *	Read DMA node statistics names
+ */
+static ssize_t nss_dma_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
+{
+	return nss_strings_print(ubuf, sz, ppos, nss_dma_strings_stats, NSS_DMA_STATS_MAX);
+}
+
+/*
+ * nss_dma_strings_ops
+ */
+NSS_STRINGS_DECLARE_FILE_OPERATIONS(dma);
+
+/*
+ * nss_dma_strings_dentry_create()
+ *	Create DMA statistics strings debug entry.
+ */
+void nss_dma_strings_dentry_create(void)
+{
+	nss_strings_create_dentry("dma", &nss_dma_strings_ops);
+}
--- /dev/null
+++ b/nss_dma_strings.h
@@ -0,0 +1,25 @@
+/*
+ **************************************************************************
+ * Copyright (c) 2020, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for
+ * any purpose with or without fee is hereby granted, provided that the
+ * above copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ **************************************************************************
+ */
+
+#ifndef __NSS_DMA_STRINGS_H
+#define __NSS_DMA_STRINGS_H
+
+extern struct nss_stats_info nss_dma_strings_stats[NSS_DMA_STATS_MAX];
+extern void nss_dma_strings_dentry_create(void);
+
+#endif /* __NSS_DMA_STRINGS_H */
--- a/nss_dtls.c
+++ b/nss_dtls.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2016-2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -163,14 +163,14 @@ static void nss_dtls_handler(struct nss_
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >= NSS_DTLS_MSG_MAX) {
-		nss_warning("%p: received invalid message %d "
+		nss_warning("%px: received invalid message %d "
 			    "for DTLS interface %d",
 			    nss_ctx, ncm->type, ncm->interface);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_dtls_msg)) {
-		nss_warning("%p: dtls message length is invalid: %d",
+		nss_warning("%px: dtls message length is invalid: %d",
 			    nss_ctx, ncm->len);
 		return;
 	}
@@ -211,7 +211,7 @@ static void nss_dtls_handler(struct nss_
 	 * call dtls session callback
 	 */
 	if (!cb) {
-		nss_warning("%p: No callback for dtls session interface %d",
+		nss_warning("%px: No callback for dtls session interface %d",
 			    nss_ctx, ncm->interface);
 		return;
 	}
@@ -279,7 +279,7 @@ nss_tx_status_t nss_dtls_tx_msg(struct n
 	BUG_ON(!nss_dtls_verify_if_num(ncm->interface));
 
 	if (ncm->type > NSS_DTLS_MSG_MAX) {
-		nss_warning("%p: dtls message type out of range: %d",
+		nss_warning("%px: dtls message type out of range: %d",
 			    nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
@@ -312,7 +312,7 @@ nss_tx_status_t nss_dtls_tx_msg_sync(str
 
 	status = nss_dtls_tx_msg(nss_ctx, msg);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: dtls_tx_msg failed\n", nss_ctx);
+		nss_warning("%px: dtls_tx_msg failed\n", nss_ctx);
 		up(&dtls_pvt.sem);
 		return status;
 	}
@@ -320,7 +320,7 @@ nss_tx_status_t nss_dtls_tx_msg_sync(str
 	ret = wait_for_completion_timeout(&dtls_pvt.complete, msecs_to_jiffies(NSS_DTLS_TX_TIMEOUT));
 
 	if (!ret) {
-		nss_warning("%p: DTLS msg tx failed due to timeout\n", nss_ctx);
+		nss_warning("%px: DTLS msg tx failed due to timeout\n", nss_ctx);
 		dtls_pvt.response = NSS_TX_FAILURE;
 	}
 
@@ -364,13 +364,13 @@ struct nss_ctx_instance *nss_dtls_regist
 	spin_unlock_bh(&nss_dtls_session_stats_lock);
 
 	if (i == NSS_MAX_DTLS_SESSIONS) {
-		nss_warning("%p: Cannot find free slot for "
+		nss_warning("%px: Cannot find free slot for "
 			    "DTLS session stats, I/F:%u\n", nss_ctx, if_num);
 		return NULL;
 	}
 
 	if (nss_ctx->subsys_dp_register[if_num].ndev) {
-		nss_warning("%p: Cannot find free slot for "
+		nss_warning("%px: Cannot find free slot for "
 			    "DTLS NSS I/F:%u\n", nss_ctx, if_num);
 
 		return NULL;
@@ -407,12 +407,12 @@ void nss_dtls_unregister_if(uint32_t if_
 	spin_unlock_bh(&nss_dtls_session_stats_lock);
 
 	if (i == NSS_MAX_DTLS_SESSIONS) {
-		nss_warning("%p: Cannot find debug stats for DTLS session %d\n", nss_ctx, if_num);
+		nss_warning("%px: Cannot find debug stats for DTLS session %d\n", nss_ctx, if_num);
 		return;
 	}
 
 	if (!nss_ctx->subsys_dp_register[if_num].ndev) {
-		nss_warning("%p: Cannot find registered netdev for DTLS NSS I/F:%u\n", nss_ctx, if_num);
+		nss_warning("%px: Cannot find registered netdev for DTLS NSS I/F:%u\n", nss_ctx, if_num);
 
 		return;
 	}
--- a/nss_dtls_cmn.c
+++ b/nss_dtls_cmn.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -147,18 +147,18 @@ static void nss_dtls_cmn_handler(struct
 
 	NSS_VERIFY_CTX_MAGIC(nss_ctx);
 
-	nss_trace("%p: handle event for interface num :%u", nss_ctx, ncm->interface);
+	nss_trace("%px: handle event for interface num :%u", nss_ctx, ncm->interface);
 
 	/*
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >= NSS_DTLS_CMN_MSG_MAX) {
-		nss_warning("%p:Bad message type(%d) for DTLS interface %d", nss_ctx, ncm->type, ncm->interface);
+		nss_warning("%px:Bad message type(%d) for DTLS interface %d", nss_ctx, ncm->type, ncm->interface);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_dtls_cmn_msg)) {
-		nss_warning("%p:Bad message length(%d)", nss_ctx, ncm->len);
+		nss_warning("%px:Bad message length(%d)", nss_ctx, ncm->len);
 		return;
 	}
 
@@ -169,7 +169,7 @@ static void nss_dtls_cmn_handler(struct
 	 * Update the callback and app_data for NOTIFY messages.
 	 */
 	if (ncm->response == NSS_CMN_RESPONSE_NOTIFY) {
-		ncm->cb = (nss_ptr_t)nss_top_main.if_rx_msg_callback[ncm->interface];
+		ncm->cb = (nss_ptr_t)nss_core_get_msg_handler(nss_ctx, ncm->interface);
 		ncm->app_data = (nss_ptr_t)nss_ctx->nss_rx_interface_handlers[nss_ctx->id][ncm->interface].app_data;
 	}
 
@@ -193,11 +193,11 @@ static void nss_dtls_cmn_handler(struct
 	 * Call DTLS session callback.
 	 */
 	if (!cb) {
-		nss_warning("%p: No callback for dtls session interface %d", nss_ctx, ncm->interface);
+		nss_warning("%px: No callback for dtls session interface %d", nss_ctx, ncm->interface);
 		return;
 	}
 
-	nss_trace("%p: calling dtlsmgr event handler(%u)", nss_ctx, ncm->interface);
+	nss_trace("%px: calling dtlsmgr event handler(%u)", nss_ctx, ncm->interface);
 	cb(app_data, ncm);
 }
 
@@ -242,12 +242,12 @@ nss_tx_status_t nss_dtls_cmn_tx_msg(stru
 	struct nss_cmn_msg *ncm = &msg->cm;
 
 	if (ncm->type >= NSS_DTLS_CMN_MSG_MAX) {
-		nss_warning("%p: dtls message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: dtls message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
 	if (!nss_dtls_cmn_verify_ifnum(nss_ctx, ncm->interface)) {
-		nss_warning("%p: dtls message interface is bad: %u", nss_ctx, ncm->interface);
+		nss_warning("%px: dtls message interface is bad: %u", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
@@ -276,7 +276,7 @@ nss_tx_status_t nss_dtls_cmn_tx_msg_sync
 	 * Length of the message should be the based on type.
 	 */
 	if (len > sizeof(ndcm_local.msg)) {
-		nss_warning("%p: (%u)Bad message length(%u) for type (%d)", nss_ctx, if_num, len, type);
+		nss_warning("%px: (%u)Bad message length(%u) for type (%d)", nss_ctx, if_num, len, type);
 		return NSS_TX_FAILURE_TOO_LARGE;
 	}
 
@@ -284,7 +284,7 @@ nss_tx_status_t nss_dtls_cmn_tx_msg_sync
 	 * Response buffer is a required for copying the response for message.
 	 */
 	if (!resp) {
-		nss_warning("%p: (%u)Response buffer is empty, type(%d)", nss_ctx, if_num, type);
+		nss_warning("%px: (%u)Response buffer is empty, type(%d)", nss_ctx, if_num, type);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
@@ -306,13 +306,13 @@ nss_tx_status_t nss_dtls_cmn_tx_msg_sync
 
 	status = nss_dtls_cmn_tx_msg(nss_ctx, &ndcm_local);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: dtls_tx_msg failed", nss_ctx);
+		nss_warning("%px: dtls_tx_msg failed", nss_ctx);
 		goto done;
 	}
 
 	ret = wait_for_completion_timeout(&dtls_cmn_pvt.complete, msecs_to_jiffies(NSS_DTLS_CMN_TX_TIMEOUT));
 	if (!ret) {
-		nss_warning("%p: DTLS msg tx failed due to timeout", nss_ctx);
+		nss_warning("%px: DTLS msg tx failed due to timeout", nss_ctx);
 		status = NSS_TX_FAILURE_NOT_READY;
 		goto done;
 	}
@@ -354,11 +354,16 @@ struct nss_ctx_instance *nss_dtls_cmn_no
 
 	ret = nss_core_register_handler(nss_ctx, if_num, nss_dtls_cmn_handler, app_data);
 	if (ret != NSS_CORE_STATUS_SUCCESS) {
-		nss_warning("%p: unable to register event handler for interface(%u)", nss_ctx, if_num);
+		nss_warning("%px: unable to register event handler for interface(%u)", nss_ctx, if_num);
 		return NULL;
 	}
 
-	nss_top_main.if_rx_msg_callback[if_num] = ev_cb;
+	ret = nss_core_register_msg_handler(nss_ctx, if_num, ev_cb);
+	if (ret != NSS_CORE_STATUS_SUCCESS) {
+		nss_core_unregister_handler(nss_ctx, if_num);
+		nss_warning("%px: unable to register event handler for interface(%u)", nss_ctx, if_num);
+		return NULL;
+	}
 
 	return nss_ctx;
 }
@@ -375,13 +380,17 @@ void nss_dtls_cmn_notify_unregister(uint
 
 	BUG_ON(!nss_ctx);
 
-	ret = nss_core_unregister_handler(nss_ctx, if_num);
+	ret = nss_core_unregister_msg_handler(nss_ctx, if_num);
 	if (ret != NSS_CORE_STATUS_SUCCESS) {
-		nss_warning("%p: unable to un register event handler for interface(%u)", nss_ctx, if_num);
+		nss_warning("%px: unable to unregister event handler for interface(%u)", nss_ctx, if_num);
 		return;
 	}
 
-	nss_top_main.if_rx_msg_callback[if_num] = NULL;
+	ret = nss_core_unregister_handler(nss_ctx, if_num);
+	if (ret != NSS_CORE_STATUS_SUCCESS) {
+		nss_warning("%px: unable to unregister event handler for interface(%u)", nss_ctx, if_num);
+		return;
+	}
 
 	return;
 }
@@ -403,12 +412,12 @@ struct nss_ctx_instance *nss_dtls_cmn_re
 	uint32_t ret;
 
 	if (!nss_dtls_cmn_verify_ifnum(nss_ctx, if_num)) {
-		nss_warning("%p: DTLS Interface is not dynamic:%u", nss_ctx, if_num);
+		nss_warning("%px: DTLS Interface is not dynamic:%u", nss_ctx, if_num);
 		return NULL;
 	}
 
 	if (nss_ctx->subsys_dp_register[if_num].ndev) {
-		nss_warning("%p: Cannot find free slot for DTLS NSS I/F:%u", nss_ctx, if_num);
+		nss_warning("%px: Cannot find free slot for DTLS NSS I/F:%u", nss_ctx, if_num);
 		return NULL;
 	}
 
@@ -417,11 +426,16 @@ struct nss_ctx_instance *nss_dtls_cmn_re
 
 	ret = nss_core_register_handler(nss_ctx, if_num, nss_dtls_cmn_handler, app_data);
 	if (ret != NSS_CORE_STATUS_SUCCESS) {
-		nss_warning("%p: unable to register event handler for interface(%u)", nss_ctx, if_num);
+		nss_warning("%px: unable to register event handler for interface(%u)", nss_ctx, if_num);
 		return NULL;
 	}
 
-	nss_top_main.if_rx_msg_callback[if_num] = ev_cb;
+	ret = nss_core_register_msg_handler(nss_ctx, if_num, ev_cb);
+	if (ret != NSS_CORE_STATUS_SUCCESS) {
+		nss_core_unregister_handler(nss_ctx, if_num);
+		nss_warning("%px: unable to register event handler for interface(%u)", nss_ctx, if_num);
+		return NULL;
+	}
 
 	/*
 	 * Atomically set the bitmap for the interface number.
@@ -438,9 +452,10 @@ EXPORT_SYMBOL(nss_dtls_cmn_register_if);
 void nss_dtls_cmn_unregister_if(uint32_t if_num)
 {
 	struct nss_ctx_instance *nss_ctx = nss_dtls_cmn_get_context();
+	uint32_t ret;
 
 	if (!nss_ctx->subsys_dp_register[if_num].ndev) {
-		nss_warning("%p: Cannot find registered netdev for DTLS NSS I/F:%u", nss_ctx, if_num);
+		nss_warning("%px: Cannot find registered netdev for DTLS NSS I/F:%u", nss_ctx, if_num);
 		return;
 	}
 
@@ -449,8 +464,13 @@ void nss_dtls_cmn_unregister_if(uint32_t
 	 */
 	clear_bit(if_num, dtls_cmn_pvt.if_map);
 
+	ret = nss_core_unregister_msg_handler(nss_ctx, if_num);
+	if (ret != NSS_CORE_STATUS_SUCCESS) {
+		nss_warning("%px: unable to unregister event handler for interface(%u)", nss_ctx, if_num);
+		return;
+	}
+
 	nss_core_unregister_handler(nss_ctx, if_num);
-	nss_top_main.if_rx_msg_callback[if_num] = NULL;
 
 	nss_core_unregister_subsys_dp(nss_ctx, if_num);
 	nss_ctx->subsys_dp_register[if_num].type = 0;
--- a/nss_dtls_cmn_log.c
+++ b/nss_dtls_cmn_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -63,12 +63,12 @@ static int8_t *nss_dtls_cmn_log_error_re
 static void nss_dtls_cmn_hdr_config_msg(struct nss_dtls_cmn_msg *ndm)
 {
 	struct nss_dtls_cmn_ctx_config_hdr *ndchm __maybe_unused = &ndm->msg.hdr_cfg;
-	nss_trace("%p: NSS DTLS_CMN Header Configure Message:\n"
+	nss_trace("%px: NSS DTLS_CMN Header Configure Message:\n"
 		"DTLS_CMN flags: %x\n"
 		"DTLS_CMN destination interface number: %d\n"
 		"DTLS_CMN source interface number: %d\n"
-		"DTLS_CMN source ip: %p\n"
-		"DTLS_CMN destination ip: %p\n"
+		"DTLS_CMN source ip: %px\n"
+		"DTLS_CMN destination ip: %px\n"
 		"DTLS_CMN source port: %d\n"
 		"DTLS_CMN destination port: %d\n"
 		"DTLS_CMN time to live: %d\n"
@@ -90,7 +90,7 @@ static void nss_dtls_cmn_hdr_config_msg(
 static void nss_dtls_cmn_dtls_config_msg(struct nss_dtls_cmn_msg *ndm)
 {
 	struct nss_dtls_cmn_ctx_config_dtls *ndcdm __maybe_unused = &ndm->msg.dtls_cfg;
-	nss_trace("%p: NSS DTLS_CMN DTLS Configure Message:\n"
+	nss_trace("%px: NSS DTLS_CMN DTLS Configure Message:\n"
 		"DTLS_CMN version: %d\n"
 		"DTLS_CMN crypto Index: %d\n"
 		"DTLS_CMN window size: %d\n"
@@ -122,7 +122,7 @@ static void nss_dtls_cmn_log_verbose(str
 		break;
 
 	default:
-		nss_warning("%p: Invalid message type\n", ndm);
+		nss_warning("%px: Invalid message type\n", ndm);
 		break;
 	}
 }
@@ -134,11 +134,11 @@ static void nss_dtls_cmn_log_verbose(str
 void nss_dtls_cmn_log_tx_msg(struct nss_dtls_cmn_msg *ndm)
 {
 	if (ndm->cm.type >= NSS_DTLS_CMN_MSG_MAX) {
-		nss_warning("%p: Invalid message type\n", ndm);
+		nss_warning("%px: Invalid message type\n", ndm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", ndm, ndm->cm.type, nss_dtls_cmn_log_message_types_str[ndm->cm.type]);
+	nss_info("%px: type[%d]:%s\n", ndm, ndm->cm.type, nss_dtls_cmn_log_message_types_str[ndm->cm.type]);
 	nss_dtls_cmn_log_verbose(ndm);
 }
 
@@ -149,26 +149,26 @@ void nss_dtls_cmn_log_tx_msg(struct nss_
 void nss_dtls_cmn_log_rx_msg(struct nss_dtls_cmn_msg *ndm)
 {
 	if (ndm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", ndm);
+		nss_warning("%px: Invalid response\n", ndm);
 		return;
 	}
 
 	if (ndm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (ndm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", ndm, ndm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", ndm, ndm->cm.type,
 			nss_dtls_cmn_log_message_types_str[ndm->cm.type],
 			ndm->cm.response, nss_cmn_response_str[ndm->cm.response]);
 		goto verbose;
 	}
 
 	if (ndm->cm.error >= NSS_DTLS_CMN_ERROR_MAX) {
-		nss_warning("%p: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
+		nss_warning("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
 			ndm, ndm->cm.type, nss_dtls_cmn_log_message_types_str[ndm->cm.type],
 			ndm->cm.response, nss_cmn_response_str[ndm->cm.response],
 			ndm->cm.error);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
 		ndm, ndm->cm.type, nss_dtls_cmn_log_message_types_str[ndm->cm.type],
 		ndm->cm.response, nss_cmn_response_str[ndm->cm.response],
 		ndm->cm.error, nss_dtls_cmn_log_error_response_types_str[ndm->cm.error]);
--- a/nss_dtls_log.c
+++ b/nss_dtls_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -54,7 +54,7 @@ static int8_t *nss_dtls_log_error_respon
 static void nss_dtls_session_config_msg(struct nss_dtls_msg *ndm)
 {
 	struct nss_dtls_session_configure *ndscm __maybe_unused = &ndm->msg.cfg;
-	nss_trace("%p: NSS DTLS Session Configure Message:\n"
+	nss_trace("%px: NSS DTLS Session Configure Message:\n"
 		"DTLS Version: %d\n"
 		"DTLS Flags: %x\n"
 		"DTLS crypto index encap: %d\n"
@@ -70,8 +70,8 @@ static void nss_dtls_session_config_msg(
 		"DTLS NSS interface: %x\n"
 		"DTLS source port: %d\n"
 		"DTLS destination port: %d\n"
-		"DTLS source ip: %p\n"
-		"DTLS destination ip: %p\n"
+		"DTLS source ip: %px\n"
+		"DTLS destination ip: %px\n"
 		"DTLS window size: %d\n"
 		"DTLS epoch: %d\n"
 		"DTLS outer IP TTL: %d\n"
@@ -98,7 +98,7 @@ static void nss_dtls_session_config_msg(
 static void nss_dtls_session_cipher_update_msg(struct nss_dtls_msg *ndm)
 {
 	struct nss_dtls_session_cipher_update *ndscum __maybe_unused = &ndm->msg.cipher_update;
-	nss_trace("%p: NSS DTLS Session Cipher Update message\n"
+	nss_trace("%px: NSS DTLS Session Cipher Update message\n"
 		"DTLS crypto index: %d\n"
 		"DTLS hash length: %d\n"
 		"DTLS crypto IV length for encapsulation: %d\n"
@@ -129,7 +129,7 @@ static void nss_dtls_log_verbose(struct
 		break;
 
 	default:
-		nss_warning("%p: Invalid message type\n", ndm);
+		nss_warning("%px: Invalid message type\n", ndm);
 		break;
 	}
 }
@@ -141,11 +141,11 @@ static void nss_dtls_log_verbose(struct
 void nss_dtls_log_tx_msg(struct nss_dtls_msg *ndm)
 {
 	if (ndm->cm.type >= NSS_DTLS_MSG_MAX) {
-		nss_warning("%p: Invalid message type\n", ndm);
+		nss_warning("%px: Invalid message type\n", ndm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", ndm, ndm->cm.type, nss_dtls_log_message_types_str[ndm->cm.type]);
+	nss_info("%px: type[%d]:%s\n", ndm, ndm->cm.type, nss_dtls_log_message_types_str[ndm->cm.type]);
 	nss_dtls_log_verbose(ndm);
 }
 
@@ -156,26 +156,26 @@ void nss_dtls_log_tx_msg(struct nss_dtls
 void nss_dtls_log_rx_msg(struct nss_dtls_msg *ndm)
 {
 	if (ndm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", ndm);
+		nss_warning("%px: Invalid response\n", ndm);
 		return;
 	}
 
 	if (ndm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (ndm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", ndm, ndm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", ndm, ndm->cm.type,
 			nss_dtls_log_message_types_str[ndm->cm.type],
 			ndm->cm.response, nss_cmn_response_str[ndm->cm.response]);
 		goto verbose;
 	}
 
 	if (ndm->cm.error >= NSS_DTLS_ERR_MAX) {
-		nss_warning("%p: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
+		nss_warning("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
 			ndm, ndm->cm.type, nss_dtls_log_message_types_str[ndm->cm.type],
 			ndm->cm.response, nss_cmn_response_str[ndm->cm.response],
 			ndm->cm.error);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
 		ndm, ndm->cm.type, nss_dtls_log_message_types_str[ndm->cm.type],
 		ndm->cm.response, nss_cmn_response_str[ndm->cm.response],
 		ndm->cm.error, nss_dtls_log_error_response_types_str[ndm->cm.error]);
--- a/nss_dynamic_interface.c
+++ b/nss_dynamic_interface.c
@@ -54,12 +54,12 @@ static void nss_dynamic_interface_handle
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >= NSS_DYNAMIC_INTERFACE_MAX) {
-		nss_warning("%p: received invalid message %d for dynamic interface", nss_ctx, ncm->type);
+		nss_warning("%px: received invalid message %d for dynamic interface", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_dynamic_interface_msg)) {
-		nss_warning("%p: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
@@ -79,12 +79,12 @@ static void nss_dynamic_interface_handle
 	switch (ndim->cm.type) {
 	case NSS_DYNAMIC_INTERFACE_ALLOC_NODE:
 		if (ncm->response == NSS_CMN_RESPONSE_ACK) {
-			nss_info("%p alloc_node response ack if_num %d\n", nss_ctx, ndim->msg.alloc_node.if_num);
+			nss_info("%px alloc_node response ack if_num %d\n", nss_ctx, ndim->msg.alloc_node.if_num);
 			if_num = ndim->msg.alloc_node.if_num;
 			if (if_num > 0) {
 				nss_dynamic_interface_assigned_types[nss_ctx->id][if_num - NSS_DYNAMIC_IF_START] = ndim->msg.alloc_node.type;
 			} else {
-				nss_warning("%p: if_num < 0\n", nss_ctx);
+				nss_warning("%px: if_num < 0\n", nss_ctx);
 			}
 		}
 
@@ -92,7 +92,7 @@ static void nss_dynamic_interface_handle
 
 	case NSS_DYNAMIC_INTERFACE_DEALLOC_NODE:
 		if (ncm->response == NSS_CMN_RESPONSE_ACK) {
-			nss_info("%p dealloc_node response ack if_num %d\n", nss_ctx, ndim->msg.dealloc_node.if_num);
+			nss_info("%px dealloc_node response ack if_num %d\n", nss_ctx, ndim->msg.dealloc_node.if_num);
 			if_num = ndim->msg.dealloc_node.if_num;
 			nss_dynamic_interface_assigned_types[nss_ctx->id][if_num - NSS_DYNAMIC_IF_START] = NSS_DYNAMIC_INTERFACE_TYPE_NONE;
 			/*
@@ -104,7 +104,7 @@ static void nss_dynamic_interface_handle
 		break;
 
 	default:
-		nss_warning("%p: Received response %d for type %d, interface %d",
+		nss_warning("%px: Received response %d for type %d, interface %d",
 				nss_ctx, ncm->response, ncm->type, ncm->interface);
 		return;
 	}
@@ -113,7 +113,7 @@ static void nss_dynamic_interface_handle
 	 * Do we have a callback?
 	 */
 	if (!ncm->cb) {
-		nss_warning("%p: nss_dynamic_interface_handler cb is NULL\n", nss_ctx);
+		nss_warning("%px: nss_dynamic_interface_handler cb is NULL\n", nss_ctx);
 		return;
 	}
 
@@ -154,12 +154,12 @@ nss_tx_status_t nss_dynamic_interface_tx
 	 * Sanity check the message
 	 */
 	if (ncm->interface != NSS_DYNAMIC_INTERFACE) {
-		nss_warning("%p: tx request for another interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: tx request for another interface: %d", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
 	if (ncm->type > NSS_DYNAMIC_INTERFACE_MAX) {
-		nss_warning("%p: message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
@@ -183,7 +183,7 @@ static nss_tx_status_t nss_dynamic_inter
 
 	status = nss_dynamic_interface_tx(nss_ctx, ndim);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: not able to transmit msg successfully\n", nss_ctx);
+		nss_warning("%px: not able to transmit msg successfully\n", nss_ctx);
 		return status;
 	}
 
@@ -192,7 +192,7 @@ static nss_tx_status_t nss_dynamic_inter
 	 */
 	ret = wait_for_completion_timeout(&di_data->complete, msecs_to_jiffies(NSS_DYNAMIC_INTERFACE_COMP_TIMEOUT));
 	if (ret == 0) {
-		nss_warning("%p: Waiting for ack timed out\n", nss_ctx);
+		nss_warning("%px: Waiting for ack timed out\n", nss_ctx);
 		return NSS_TX_FAILURE;
 	}
 
@@ -243,7 +243,7 @@ int nss_dynamic_interface_alloc_node(enu
 	 */
 	status = nss_dynamic_interface_tx_sync(nss_ctx, &di_data, &ndim);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p not able to transmit alloc node msg\n", nss_ctx);
+		nss_warning("%px not able to transmit alloc node msg\n", nss_ctx);
 		return -1;
 	}
 
@@ -251,7 +251,7 @@ int nss_dynamic_interface_alloc_node(enu
 	 * Check response and return -1 if its a NACK else proceed.
 	 */
 	if (di_data.response != NSS_CMN_RESPONSE_ACK) {
-		nss_warning("%p Received NACK from NSS - Response:%d\n", nss_ctx, di_data.response);
+		nss_warning("%px Received NACK from NSS - Response:%d\n", nss_ctx, di_data.response);
 		return -1;
 	}
 
@@ -286,7 +286,7 @@ nss_tx_status_t nss_dynamic_interface_de
 	init_completion(&di_data.complete);
 
 	if (nss_is_dynamic_interface(if_num) == false) {
-		nss_warning("%p: nss_dynamic_interface if_num is not in range %d\n", nss_ctx, if_num);
+		nss_warning("%px: nss_dynamic_interface if_num is not in range %d\n", nss_ctx, if_num);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
@@ -302,12 +302,12 @@ nss_tx_status_t nss_dynamic_interface_de
 	 */
 	status = nss_dynamic_interface_tx_sync(nss_ctx, &di_data, &ndim);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p not able to transmit alloc node msg\n", nss_ctx);
+		nss_warning("%px not able to transmit alloc node msg\n", nss_ctx);
 		return status;
 	}
 
 	if (di_data.response != NSS_CMN_RESPONSE_ACK) {
-		nss_warning("%p Received NACK from NSS\n", nss_ctx);
+		nss_warning("%px Received NACK from NSS\n", nss_ctx);
 		return -1;
 	}
 
--- a/nss_dynamic_interface_log.c
+++ b/nss_dynamic_interface_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -52,7 +52,7 @@ static int8_t *nss_dynamic_interface_log
 static void nss_dynamic_interface_alloc_node_log_msg(struct nss_dynamic_interface_msg *ndm)
 {
 	struct nss_dynamic_interface_alloc_node_msg *ndanm __maybe_unused = &ndm->msg.alloc_node;
-	nss_trace("%p: NSS Dynamic Interface Alloc Node Message:\n"
+	nss_trace("%px: NSS Dynamic Interface Alloc Node Message:\n"
 		"Dynamic Interface Type: %d\n"
 		"Dynamic Interface Number: %d\n",
 		ndanm, ndanm->type,
@@ -66,7 +66,7 @@ static void nss_dynamic_interface_alloc_
 static void nss_dynamic_interface_dealloc_node_log_msg(struct nss_dynamic_interface_msg *ndm)
 {
 	struct nss_dynamic_interface_dealloc_node_msg *nddnm __maybe_unused = &ndm->msg.dealloc_node;
-	nss_trace("%p: NSS Dynamic Interface Alloc Node Message:\n"
+	nss_trace("%px: NSS Dynamic Interface Alloc Node Message:\n"
 		"Dynamic Interface Type: %d\n"
 		"Dynamic Interface Number: %d\n",
 		nddnm, nddnm->type,
@@ -89,7 +89,7 @@ static void nss_dynamic_interface_log_ve
 		break;
 
 	default:
-		nss_warning("%p: Invalid message type\n", ndm);
+		nss_warning("%px: Invalid message type\n", ndm);
 		break;
 	}
 }
@@ -101,11 +101,11 @@ static void nss_dynamic_interface_log_ve
 void nss_dynamic_interface_log_tx_msg(struct nss_dynamic_interface_msg *ndm)
 {
 	if (ndm->cm.type >= NSS_DYNAMIC_INTERFACE_MAX) {
-		nss_warning("%p: Invalid message type\n", ndm);
+		nss_warning("%px: Invalid message type\n", ndm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", ndm, ndm->cm.type, nss_dynamic_interface_log_message_types_str[ndm->cm.type]);
+	nss_info("%px: type[%d]:%s\n", ndm, ndm->cm.type, nss_dynamic_interface_log_message_types_str[ndm->cm.type]);
 	nss_dynamic_interface_log_verbose(ndm);
 }
 
@@ -116,26 +116,26 @@ void nss_dynamic_interface_log_tx_msg(st
 void nss_dynamic_interface_log_rx_msg(struct nss_dynamic_interface_msg *ndm)
 {
 	if (ndm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", ndm);
+		nss_warning("%px: Invalid response\n", ndm);
 		return;
 	}
 
 	if (ndm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (ndm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", ndm, ndm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", ndm, ndm->cm.type,
 			nss_dynamic_interface_log_message_types_str[ndm->cm.type],
 			ndm->cm.response, nss_cmn_response_str[ndm->cm.response]);
 		goto verbose;
 	}
 
 	if (ndm->cm.error >= NSS_DYNAMIC_INTERFACE_ERR_MAX) {
-		nss_warning("%p: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
+		nss_warning("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
 			ndm, ndm->cm.type, nss_dynamic_interface_log_message_types_str[ndm->cm.type],
 			ndm->cm.response, nss_cmn_response_str[ndm->cm.response],
 			ndm->cm.error);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s\n, error[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s\n, error[%d]:%s\n",
 		ndm, ndm->cm.type, nss_dynamic_interface_log_message_types_str[ndm->cm.type],
 		ndm->cm.response, nss_cmn_response_str[ndm->cm.response],
 		ndm->cm.error, nss_dynamic_interface_log_error_response_types_str[ndm->cm.error]);
--- a/nss_edma.c
+++ b/nss_edma.c
@@ -40,7 +40,7 @@ static void nss_edma_interface_handler(s
 	 * Is this a valid request/response packet?
 	 */
 	if (nem->cm.type >= NSS_METADATA_TYPE_EDMA_MAX) {
-		nss_warning("%p: received invalid message %d for edma interface", nss_ctx, nem->cm.type);
+		nss_warning("%px: received invalid message %d for edma interface", nss_ctx, nem->cm.type);
 		return;
 	}
 
@@ -67,7 +67,7 @@ static void nss_edma_interface_handler(s
 			/*
 			 * Check response
 			 */
-			nss_info("%p: Received response %d for type %d, interface %d",
+			nss_info("%px: Received response %d for type %d, interface %d",
 						nss_ctx, ncm->response, ncm->type, ncm->interface);
 		}
 	}
--- a/nss_eth_rx.c
+++ b/nss_eth_rx.c
@@ -41,7 +41,7 @@ static void nss_eth_rx_interface_handler
 	 * Is this a valid request/response packet?
 	 */
 	if (nem->cm.type >= NSS_METADATA_TYPE_ETH_RX_MAX) {
-		nss_warning("%p: received invalid message %d for eth_rx interface", nss_ctx, nem->cm.type);
+		nss_warning("%px: received invalid message %d for eth_rx interface", nss_ctx, nem->cm.type);
 		return;
 	}
 
@@ -59,7 +59,7 @@ static void nss_eth_rx_interface_handler
 			/*
 			 * Check response
 			 */
-			nss_info("%p: Received response %d for type %d, interface %d",
+			nss_info("%px: Received response %d for type %d, interface %d",
 						nss_ctx, ncm->response, ncm->type, ncm->interface);
 		}
 	}
--- a/nss_freq.c
+++ b/nss_freq.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2013, 2015-2019 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2013, 2015-2020 The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -66,7 +66,7 @@ static void nss_freq_handle_ack(struct n
 		/*
 		 * NSS finished start noficiation - HW change clocks and send end notification
 		 */
-		nss_info("%p: NSS ACK Received: %d - Change HW CLK/Send Finish to NSS\n", nss_ctx, nfa->ack);
+		nss_info("%px: NSS ACK Received: %d - Change HW CLK/Send Finish to NSS\n", nss_ctx, nfa->ack);
 
 		return;
 	}
@@ -75,12 +75,12 @@ static void nss_freq_handle_ack(struct n
 		/*
 		 * NSS finished end notification - Done
 		 */
-		nss_info("%p: NSS ACK Received: %d - End Notification ACK - Running: %dmhz\n", nss_ctx, nfa->ack, nfa->freq_current);
+		nss_info("%px: NSS ACK Received: %d - End Notification ACK - Running: %dmhz\n", nss_ctx, nfa->ack, nfa->freq_current);
 		nss_runtime_samples.freq_scale_ready = 1;
 		return;
 	}
 
-	nss_info("%p: NSS had an error - Running: %dmhz\n", nss_ctx, nfa->freq_current);
+	nss_info("%px: NSS had an error - Running: %dmhz\n", nss_ctx, nfa->freq_current);
 }
 
 /*
@@ -185,7 +185,7 @@ static void nss_freq_compute_cpu_usage(s
 			nss_freq_cpu_status.min = nss_freq_cpu_status.used;
 		}
 
-		nss_trace("%p: max_instructions:%d cpu_usage:%d max_usage:%d min_usage:%d\n", nss_ctx,
+		nss_trace("%px: max_instructions:%d cpu_usage:%d max_usage:%d min_usage:%d\n", nss_ctx,
 				nss_freq_cpu_status.max_ins, nss_freq_cpu_status.used, nss_freq_cpu_status.max, nss_freq_cpu_status.min);
 
 		nss_freq_cpu_status.total = 0;
@@ -249,10 +249,10 @@ void nss_freq_scale_frequency(struct nss
 	 * Print out statistics every 10 samples
 	 */
 	if (nss_runtime_samples.message_rate_limit++ >= NSS_MESSAGE_RATE_LIMIT) {
-		nss_trace("%p: Running AVG:%x Sample:%x Divider:%d\n", nss_ctx, nss_runtime_samples.average, inst_cnt, nss_runtime_samples.sample_count);
-		nss_trace("%p: Current Frequency Index:%d\n", nss_ctx, index);
-		nss_trace("%p: Auto Scale Ready:%d Auto Scale:%d\n", nss_ctx, nss_runtime_samples.freq_scale_ready, nss_cmd_buf.auto_scale);
-		nss_trace("%p: Current Rate:%x\n", nss_ctx, nss_runtime_samples.average);
+		nss_trace("%px: Running AVG:%x Sample:%x Divider:%d\n", nss_ctx, nss_runtime_samples.average, inst_cnt, nss_runtime_samples.sample_count);
+		nss_trace("%px: Current Frequency Index:%d\n", nss_ctx, index);
+		nss_trace("%px: Auto Scale Ready:%d Auto Scale:%d\n", nss_ctx, nss_runtime_samples.freq_scale_ready, nss_cmd_buf.auto_scale);
+		nss_trace("%px: Current Rate:%x\n", nss_ctx, nss_runtime_samples.average);
 
 		nss_runtime_samples.message_rate_limit = 0;
 	}
@@ -361,7 +361,7 @@ static void nss_freq_interface_handler(s
 			/*
 			 * Check response
 			 */
-			nss_info("%p: Received response %d for type %d, interface %d", nss_ctx, ncm->response, ncm->type, ncm->interface);
+			nss_info("%px: Received response %d for type %d, interface %d", nss_ctx, ncm->response, ncm->type, ncm->interface);
 		}
 	}
 }
@@ -375,7 +375,7 @@ nss_tx_status_t nss_freq_change(struct n
 	struct nss_corefreq_msg ncm;
 	struct nss_freq_msg *nfc;
 
-	nss_info("%p: frequency changing to: %d\n", nss_ctx, eng);
+	nss_info("%px: frequency changing to: %d\n", nss_ctx, eng);
 
 	/*
 	 * Update the max instruction count for a frequency during down scaling.
@@ -459,4 +459,4 @@ void nss_freq_init_cpu_usage(void)
 	nss_freq_cpu_status.avg_ctr = 0;
 
 	nss_freq_stats_dentry_create();
-}
\ No newline at end of file
+}
--- a/nss_freq_log.c
+++ b/nss_freq_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -39,7 +39,7 @@ static int8_t *nss_freq_log_message_type
 static void nss_freq_log_msg(struct nss_corefreq_msg *ncm)
 {
 	struct nss_freq_msg *nfm __maybe_unused = &ncm->msg.nfc;
-	nss_trace("%p: NSS Freq Message:\n"
+	nss_trace("%px: NSS Freq Message:\n"
 		"Frequency request: %d\n"
 		"Frequency start/end: %d\n"
 		"Frequency stats enable: %d\n"
@@ -69,7 +69,7 @@ static void nss_freq_log_verbose(struct
 		break;
 
 	default:
-		nss_warning("%p: Invalid message type\n", ncm);
+		nss_warning("%px: Invalid message type\n", ncm);
 		break;
 	}
 }
@@ -81,17 +81,17 @@ static void nss_freq_log_verbose(struct
 void nss_freq_log_rx_msg(struct nss_corefreq_msg *ncm)
 {
 	if (ncm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", ncm);
+		nss_warning("%px: Invalid response\n", ncm);
 		return;
 	}
 
 	if (ncm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (ncm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d], response[%d]:%s\n", ncm, ncm->cm.type,
+		nss_info("%px: type[%d], response[%d]:%s\n", ncm, ncm->cm.type,
 			ncm->cm.response, nss_cmn_response_str[ncm->cm.response]);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s\n",
 		ncm, ncm->cm.type, nss_freq_log_message_types_str[ncm->cm.type],
 		ncm->cm.response, nss_cmn_response_str[ncm->cm.response]);
 
--- a/nss_gre.c
+++ b/nss_gre.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -101,12 +101,12 @@ static void nss_gre_msg_handler(struct n
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >= NSS_GRE_MSG_MAX) {
-		nss_warning("%p: received invalid message %d for GRE STD interface", nss_ctx, ncm->type);
+		nss_warning("%px: received invalid message %d for GRE STD interface", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_gre_msg)) {
-		nss_warning("%p: tx request for another interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: tx request for another interface: %d", nss_ctx, ncm->interface);
 		return;
 	}
 
@@ -151,7 +151,7 @@ static void nss_gre_msg_handler(struct n
 	 * call gre-std callback
 	 */
 	if (!cb) {
-		nss_warning("%p: No callback for gre-std interface %d",
+		nss_warning("%px: No callback for gre-std interface %d",
 			    nss_ctx, ncm->interface);
 		return;
 	}
@@ -217,12 +217,12 @@ nss_tx_status_t nss_gre_tx_msg(struct ns
 	 * Sanity check the message
 	 */
 	if (!nss_is_dynamic_interface(ncm->interface)) {
-		nss_warning("%p: tx request for non dynamic interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: tx request for non dynamic interface: %d", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
 	if (ncm->type > NSS_GRE_MSG_MAX) {
-		nss_warning("%p: message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
@@ -253,14 +253,14 @@ nss_tx_status_t nss_gre_tx_msg_sync(stru
 
 	status = nss_gre_tx_msg(nss_ctx, msg);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: gre_tx_msg failed\n", nss_ctx);
+		nss_warning("%px: gre_tx_msg failed\n", nss_ctx);
 		up(&nss_gre_pvt.sem);
 		return status;
 	}
 	ret = wait_for_completion_timeout(&nss_gre_pvt.complete, msecs_to_jiffies(NSS_GRE_TX_TIMEOUT));
 
 	if (!ret) {
-		nss_warning("%p: GRE STD tx sync failed due to timeout\n", nss_ctx);
+		nss_warning("%px: GRE STD tx sync failed due to timeout\n", nss_ctx);
 		nss_gre_pvt.response = NSS_TX_FAILURE;
 	}
 
@@ -310,7 +310,7 @@ struct nss_ctx_instance *nss_gre_registe
 		break;
 
 	default:
-		nss_warning("%p: Unable to register. Wrong interface type %d\n", nss_ctx, type);
+		nss_warning("%px: Unable to register. Wrong interface type %d\n", nss_ctx, type);
 		return NULL;
 	}
 
@@ -340,7 +340,7 @@ void nss_gre_unregister_if(uint32_t if_n
 
 	dev = nss_cmn_get_interface_dev(nss_ctx, if_num);
 	if (!dev) {
-		nss_warning("%p: Unable to find net device for the interface %d\n", nss_ctx, if_num);
+		nss_warning("%px: Unable to find net device for the interface %d\n", nss_ctx, if_num);
 		return;
 	}
 
@@ -373,7 +373,7 @@ int nss_gre_ifnum_with_core_id(int if_nu
 
 	NSS_VERIFY_CTX_MAGIC(nss_ctx);
 	if (!nss_is_dynamic_interface(if_num)) {
-		nss_warning("%p: Invalid if_num: %d, must be a dynamic interface\n", nss_ctx, if_num);
+		nss_warning("%px: Invalid if_num: %d, must be a dynamic interface\n", nss_ctx, if_num);
 		return 0;
 	}
 
--- a/nss_gre_log.c
+++ b/nss_gre_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -41,7 +41,7 @@ static int8_t *nss_gre_log_message_types
 static void nss_gre_log_config_msg(struct nss_gre_msg *ngm)
 {
 	struct nss_gre_config_msg *ngcm __maybe_unused = &ngm->msg.cmsg;
-	nss_trace("%p: NSS GRE Config message\n"
+	nss_trace("%px: NSS GRE Config message\n"
 		"GRE flags: %d\n"
 		"GRE ikey: %d\n"
 		"GRE okey: %d\n"
@@ -78,7 +78,7 @@ static void nss_gre_log_config_msg(struc
 static void nss_gre_log_deconfig_msg(struct nss_gre_msg *ngm)
 {
 	struct nss_gre_deconfig_msg *ngdm __maybe_unused = &ngm->msg.dmsg;
-	nss_trace("%p: NSS GRE deconfig message\n"
+	nss_trace("%px: NSS GRE deconfig message\n"
 		"GRE interface number: %d\n",
 		ngdm, ngdm->if_number);
 }
@@ -90,7 +90,7 @@ static void nss_gre_log_deconfig_msg(str
 static void nss_gre_log_linkup_msg(struct nss_gre_msg *ngm)
 {
 	struct nss_gre_linkup_msg *nglm __maybe_unused = &ngm->msg.linkup;
-	nss_trace("%p: NSS GRE linkup message\n"
+	nss_trace("%px: NSS GRE linkup message\n"
 		"GRE interface number: %d\n",
 		nglm, nglm->if_number);
 }
@@ -102,7 +102,7 @@ static void nss_gre_log_linkup_msg(struc
 static void nss_gre_log_linkdown_msg(struct nss_gre_msg *ngm)
 {
 	struct nss_gre_linkdown_msg *ngdm __maybe_unused = &ngm->msg.linkdown;
-	nss_trace("%p: NSS GRE linkdown message\n"
+	nss_trace("%px: NSS GRE linkdown message\n"
 		"GRE interface number: %d\n",
 		ngdm, ngdm->if_number);
 }
@@ -140,7 +140,7 @@ static void nss_gre_log_verbose(struct n
 		break;
 
 	default:
-		nss_trace("%p: Invalid message type\n", ngm);
+		nss_trace("%px: Invalid message type\n", ngm);
 		break;
 	}
 }
@@ -152,11 +152,11 @@ static void nss_gre_log_verbose(struct n
 void nss_gre_log_tx_msg(struct nss_gre_msg *ngm)
 {
 	if (ngm->cm.type >= NSS_GRE_MSG_MAX) {
-		nss_warning("%p: Invalid message type\n", ngm);
+		nss_warning("%px: Invalid message type\n", ngm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", ngm, ngm->cm.type, nss_gre_log_message_types_str[NSS_GRE_LOG_MESSAGE_TYPE_INDEX(ngm->cm.type)]);
+	nss_info("%px: type[%d]:%s\n", ngm, ngm->cm.type, nss_gre_log_message_types_str[NSS_GRE_LOG_MESSAGE_TYPE_INDEX(ngm->cm.type)]);
 	nss_gre_log_verbose(ngm);
 }
 
@@ -167,18 +167,18 @@ void nss_gre_log_tx_msg(struct nss_gre_m
 void nss_gre_log_rx_msg(struct nss_gre_msg *ngm)
 {
 	if (ngm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", ngm);
+		nss_warning("%px: Invalid response\n", ngm);
 		return;
 	}
 
 	if (ngm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (ngm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", ngm, ngm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", ngm, ngm->cm.type,
 			nss_gre_log_message_types_str[NSS_GRE_LOG_MESSAGE_TYPE_INDEX(ngm->cm.type)],
 			ngm->cm.response, nss_cmn_response_str[ngm->cm.response]);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s\n",
 		ngm, ngm->cm.type, nss_gre_log_message_types_str[NSS_GRE_LOG_MESSAGE_TYPE_INDEX(ngm->cm.type)],
 		ngm->cm.response, nss_cmn_response_str[ngm->cm.response]);
 
--- a/nss_gre_redir.c
+++ b/nss_gre_redir.c
@@ -85,12 +85,12 @@ static void nss_gre_redir_tunnel_update_
 	type = nss_dynamic_interface_get_type(nss_ctx, if_num);
 	dev = nss_cmn_get_interface_dev(nss_ctx, if_num);
 	if (!dev) {
-		nss_warning("%p: Unable to find net device for the interface %d\n", nss_ctx, if_num);
+		nss_warning("%px: Unable to find net device for the interface %d\n", nss_ctx, if_num);
 		return;
 	}
 
 	if (!nss_gre_redir_verify_ifnum(if_num)) {
-		nss_warning("%p: Unknown type for interface %d\n", nss_ctx, if_num);
+		nss_warning("%px: Unknown type for interface %d\n", nss_ctx, if_num);
 		return;
 	}
 
@@ -102,7 +102,7 @@ static void nss_gre_redir_tunnel_update_
 	}
 
 	if (i == NSS_GRE_REDIR_MAX_INTERFACES) {
-		nss_warning("%p: Unable to find tunnel stats instance for interface %d\n", nss_ctx, if_num);
+		nss_warning("%px: Unable to find tunnel stats instance for interface %d\n", nss_ctx, if_num);
 		return;
 	}
 
@@ -184,12 +184,12 @@ static void nss_gre_redir_msg_handler(st
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >=  NSS_GRE_REDIR_MAX_MSG_TYPES) {
-		nss_warning("%p: Received invalid message %d for gre interface", nss_ctx, ncm->type);
+		nss_warning("%px: Received invalid message %d for gre interface", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_gre_redir_msg)) {
-		nss_warning("%p: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
@@ -198,7 +198,7 @@ static void nss_gre_redir_msg_handler(st
 	 * to the same callback/app_data.
 	 */
 	if (ncm->response == NSS_CMN_RESPONSE_NOTIFY) {
-		ncm->cb = (nss_ptr_t)nss_ctx->nss_top->if_rx_msg_callback[ncm->interface];
+		ncm->cb = (nss_ptr_t)nss_core_get_msg_handler(nss_ctx, ncm->interface);
 		ncm->app_data = (nss_ptr_t)nss_ctx->nss_rx_interface_handlers[nss_ctx->id][ncm->interface].app_data;
 	}
 
@@ -261,7 +261,7 @@ static struct nss_ctx_instance *nss_gre_
 
 	if (idx == -1) {
 		spin_unlock_bh(&nss_gre_redir_stats_lock);
-		nss_warning("%p: Maximum number of gre_redir tunnel_stats instances are already allocated\n", nss_ctx);
+		nss_warning("%px: Maximum number of gre_redir tunnel_stats instances are already allocated\n", nss_ctx);
 		return NULL;
 	}
 
@@ -284,13 +284,29 @@ static struct nss_ctx_instance *nss_gre_
 		}
 		spin_unlock_bh(&nss_gre_redir_stats_lock);
 
-		nss_warning("%p: Not able to register handler for gre_redir interface %d with NSS core\n", nss_ctx, if_num);
+		nss_warning("%px: Not able to register handler for gre_redir interface %d with NSS core\n", nss_ctx, if_num);
+		return NULL;
+	}
+
+	/*
+	 * Registering handler for sending tunnel interface msgs to NSS.
+	 */
+	status = nss_core_register_msg_handler(nss_ctx, if_num, cb_func_msg);
+	if (status != NSS_CORE_STATUS_SUCCESS) {
+		nss_core_unregister_handler(nss_ctx, if_num);
+		spin_lock_bh(&nss_gre_redir_stats_lock);
+		tun_stats[idx].ref_count--;
+		if (!tun_stats[idx].ref_count) {
+			tun_stats[idx].dev = NULL;
+		}
+		spin_unlock_bh(&nss_gre_redir_stats_lock);
+
+		nss_warning("%px: Not able to register handler for gre_redir interface %d with NSS core\n", nss_ctx, if_num);
 		return NULL;
 	}
 
 	nss_core_register_subsys_dp(nss_ctx, if_num, cb_func_data, NULL, NULL, netdev, features);
 	nss_core_set_subsys_dp_type(nss_ctx, netdev, if_num, type);
-	nss_top_main.if_rx_msg_callback[if_num] = cb_func_msg;
 	return nss_ctx;
 }
 
@@ -324,13 +340,13 @@ int nss_gre_redir_alloc_and_register_nod
 			(type != NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_EXCEPTION_US) &&
 			(type != NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_EXCEPTION_DS)) {
 
-		nss_warning("%p: Unknown type %u\n", dev, type);
+		nss_warning("%px: Unknown type %u\n", dev, type);
 		return -1;
 	}
 
 	ifnum = nss_dynamic_interface_alloc_node(type);
 	if (ifnum == -1) {
-		nss_warning("%p: Unable to allocate GRE_REDIR node of type = %u\n", dev, type);
+		nss_warning("%px: Unable to allocate GRE_REDIR node of type = %u\n", dev, type);
 		return -1;
 	}
 
@@ -369,12 +385,12 @@ nss_tx_status_t nss_gre_redir_configure_
 
 	if (ngrcm->ip_hdr_type != NSS_GRE_REDIR_IP_HDR_TYPE_IPV4 &&
 			ngrcm->ip_hdr_type != NSS_GRE_REDIR_IP_HDR_TYPE_IPV6) {
-		nss_warning("%p: Unknown IP header type %u\n", nss_ctx, ngrcm->ip_hdr_type);
+		nss_warning("%px: Unknown IP header type %u\n", nss_ctx, ngrcm->ip_hdr_type);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
 	if (ngrcm->gre_version != NSS_GRE_REDIR_HEADER_VERSION) {
-		nss_warning("%p: Incorrect header version %u\n", nss_ctx, ngrcm->gre_version);
+		nss_warning("%px: Incorrect header version %u\n", nss_ctx, ngrcm->gre_version);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
@@ -383,13 +399,13 @@ nss_tx_status_t nss_gre_redir_configure_
 			(iftype == NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_WIFI_OFFL_INNER) ||
 			(iftype == NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_SJACK_INNER))) {
 
-		nss_warning("%p: Incorrect interface type %u\n", nss_ctx, iftype);
+		nss_warning("%px: Incorrect interface type %u\n", nss_ctx, iftype);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
 	outerif_type = nss_dynamic_interface_get_type(nss_ctx, ngrcm->except_outerif);
 	if (outerif_type != NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_OUTER) {
-		nss_warning("%p: Incorrect type for exception interface %u\n", nss_ctx, outerif_type);
+		nss_warning("%px: Incorrect type for exception interface %u\n", nss_ctx, outerif_type);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
@@ -409,7 +425,7 @@ nss_tx_status_t nss_gre_redir_configure_
 
 	status = nss_gre_redir_tx_msg_sync(nss_ctx, &config);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: Unable to configure inner node %d.\n", nss_ctx, ifnum);
+		nss_warning("%px: Unable to configure inner node %d.\n", nss_ctx, ifnum);
 	}
 
 	return status;
@@ -436,13 +452,13 @@ nss_tx_status_t nss_gre_redir_exception_
 
 	iftype = nss_dynamic_interface_get_type(nss_ctx, ifnum);
 	if (iftype != NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_EXCEPTION_DS) {
-		nss_warning("%p: Incorrect interface type %u\n", nss_ctx, iftype);
+		nss_warning("%px: Incorrect interface type %u\n", nss_ctx, iftype);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
 	vap_type = nss_dynamic_interface_get_type(nss_ctx, ngrcm->dst_vap_nssif);
 	if ((vap_type != NSS_DYNAMIC_INTERFACE_TYPE_VAP)) {
-		nss_warning("%p: Incorrect type for vap interface type = %u", nss_ctx, vap_type);
+		nss_warning("%px: Incorrect type for vap interface type = %u", nss_ctx, vap_type);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
@@ -454,7 +470,7 @@ nss_tx_status_t nss_gre_redir_exception_
 
 	status = nss_gre_redir_tx_msg_sync(nss_ctx, &config);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: Unable to register callback from gre redir exception ds %d\n", nss_ctx, ifnum);
+		nss_warning("%px: Unable to register callback from gre redir exception ds %d\n", nss_ctx, ifnum);
 	}
 
 	return status;
@@ -481,13 +497,13 @@ nss_tx_status_t nss_gre_redir_configure_
 
 	if (ngrcm->ip_hdr_type != NSS_GRE_REDIR_IP_HDR_TYPE_IPV4 &&
 			ngrcm->ip_hdr_type != NSS_GRE_REDIR_IP_HDR_TYPE_IPV6) {
-		nss_warning("%p: Unknown IP header type %u\n", nss_ctx, ngrcm->ip_hdr_type);
+		nss_warning("%px: Unknown IP header type %u\n", nss_ctx, ngrcm->ip_hdr_type);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
 	iftype = nss_dynamic_interface_get_type(nss_ctx, ifnum);
 	if (iftype != NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_OUTER) {
-		nss_warning("%p: Incorrect interface type %u\n", nss_ctx, iftype);
+		nss_warning("%px: Incorrect interface type %u\n", nss_ctx, iftype);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
@@ -499,7 +515,7 @@ nss_tx_status_t nss_gre_redir_configure_
 			(ngrcm->except_sjackif
 			 && sjackif_type != NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_SJACK_INNER)) {
 
-		nss_warning("%p: Incorrect type for exception interface hostif_type = %u"
+		nss_warning("%px: Incorrect type for exception interface hostif_type = %u"
 				"offlif_type = %u sjackif_type = %u\n", nss_ctx, hostif_type,
 				offlif_type, sjackif_type);
 		return NSS_TX_FAILURE_BAD_PARAM;
@@ -517,7 +533,7 @@ nss_tx_status_t nss_gre_redir_configure_
 
 	status = nss_gre_redir_tx_msg_sync(nss_ctx, &config);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: Unable to configure outer node %d\n", nss_ctx, ifnum);
+		nss_warning("%px: Unable to configure outer node %d\n", nss_ctx, ifnum);
 	}
 
 	return status;
@@ -565,12 +581,12 @@ nss_tx_status_t nss_gre_redir_tx_msg(str
 	 */
 	if (((ncm->interface < NSS_DYNAMIC_IF_START) || (ncm->interface >= (NSS_DYNAMIC_IF_START + NSS_MAX_DYNAMIC_INTERFACES))) &&
 		ncm->interface != NSS_GRE_REDIR_INTERFACE) {
-		nss_warning("%p: tx request for another interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: tx request for another interface: %d", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
 	if (ncm->type >= NSS_GRE_REDIR_MAX_MSG_TYPES) {
-		nss_warning("%p: message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
@@ -592,14 +608,14 @@ nss_tx_status_t nss_gre_redir_tx_msg_syn
 	ngrm->cm.app_data = (nss_ptr_t)NULL;
 	status = nss_gre_redir_tx_msg(nss_ctx, ngrm);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: gre_tx_msg failed\n", nss_ctx);
+		nss_warning("%px: gre_tx_msg failed\n", nss_ctx);
 		up(&nss_gre_redir_pvt.sem);
 		return status;
 	}
 
 	ret = wait_for_completion_timeout(&nss_gre_redir_pvt.complete, msecs_to_jiffies(NSS_GRE_REDIR_TX_TIMEOUT));
 	if (!ret) {
-		nss_warning("%p: GRE tx sync failed due to timeout\n", nss_ctx);
+		nss_warning("%px: GRE tx sync failed due to timeout\n", nss_ctx);
 		nss_gre_redir_pvt.response = NSS_TX_FAILURE;
 	}
 
@@ -617,7 +633,7 @@ nss_tx_status_t nss_gre_redir_tx_buf(str
 {
 	uint32_t type;
 
-	nss_trace("%p: gre_redir If Tx packet, id:%d, data=%p", nss_ctx, if_num, os_buf->data);
+	nss_trace("%px: gre_redir If Tx packet, id:%d, data=%px", nss_ctx, if_num, os_buf->data);
 
 	/*
 	 * We expect Tx packets to the tunnel only from an interface of
@@ -626,7 +642,7 @@ nss_tx_status_t nss_gre_redir_tx_buf(str
 	type = nss_dynamic_interface_get_type(nss_ctx, if_num);
 	if (!((type == NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_WIFI_HOST_INNER)
 		|| (type == NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_EXCEPTION_DS))) {
-		nss_warning("%p: Unknown type for interface %u\n", nss_ctx, type);
+		nss_warning("%px: Unknown type for interface %u\n", nss_ctx, type);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
@@ -642,7 +658,7 @@ nss_tx_status_t nss_gre_redir_tx_buf_nor
 {
 	uint32_t type;
 
-	nss_trace("%p: gre_redir If Tx packet, id:%d, data=%p", nss_ctx, if_num, os_buf->data);
+	nss_trace("%px: gre_redir If Tx packet, id:%d, data=%px", nss_ctx, if_num, os_buf->data);
 
 	/*
 	 * We expect Tx packets to the tunnel only from an interface of
@@ -651,7 +667,7 @@ nss_tx_status_t nss_gre_redir_tx_buf_nor
 	type = nss_dynamic_interface_get_type(nss_ctx, if_num);
 	if (!((type == NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_WIFI_HOST_INNER)
 		|| (type == NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_EXCEPTION_DS))) {
-		nss_warning("%p: Unknown type for interface %u\n", nss_ctx, type);
+		nss_warning("%px: Unknown type for interface %u\n", nss_ctx, type);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
@@ -675,19 +691,24 @@ bool nss_gre_redir_unregister_if(uint32_
 
 	dev = nss_cmn_get_interface_dev(nss_ctx, if_num);
 	if (!dev) {
-		nss_warning("%p: Unable to find net device for the interface %d\n", nss_ctx, if_num);
+		nss_warning("%px: Unable to find net device for the interface %d\n", nss_ctx, if_num);
+		return false;
+	}
+
+	status = nss_core_unregister_msg_handler(nss_ctx, if_num);
+	if (status != NSS_CORE_STATUS_SUCCESS) {
+		nss_warning("%px: Not able to unregister handler for gre_redir interface %d with NSS core\n", nss_ctx, if_num);
 		return false;
 	}
 
 	status = nss_core_unregister_handler(nss_ctx, if_num);
 	if (status != NSS_CORE_STATUS_SUCCESS) {
-		nss_warning("%p: Not able to unregister handler for gre_redir interface %d with NSS core\n", nss_ctx, if_num);
+		nss_warning("%px: Not able to unregister handler for gre_redir interface %d with NSS core\n", nss_ctx, if_num);
 		return false;
 	}
 
 	nss_core_set_subsys_dp_type(nss_ctx, dev, if_num, NSS_DYNAMIC_INTERFACE_TYPE_NONE);
 	nss_core_unregister_subsys_dp(nss_ctx, if_num);
-	nss_top_main.if_rx_msg_callback[if_num] = NULL;
 	spin_lock_bh(&nss_gre_redir_stats_lock);
 
 	/*
@@ -740,7 +761,7 @@ void nss_gre_redir_register_handler(void
 
 	gre_redir_dentry = nss_gre_redir_stats_dentry_create();
 	if (!gre_redir_dentry) {
-		nss_warning("%p: Not able to create debugfs entry\n", nss_ctx);
+		nss_warning("%px: Not able to create debugfs entry\n", nss_ctx);
 		return;
 	}
 
@@ -751,7 +772,7 @@ void nss_gre_redir_register_handler(void
 	if (status != NSS_CORE_STATUS_SUCCESS) {
 		debugfs_remove_recursive(gre_redir_dentry);
 		gre_redir_dentry = NULL;
-		nss_warning("%p: Not able to register handler for gre_redir base interface with NSS core\n", nss_ctx);
+		nss_warning("%px: Not able to register handler for gre_redir base interface with NSS core\n", nss_ctx);
 		return;
 	}
 }
--- a/nss_gre_redir_lag_ds.c
+++ b/nss_gre_redir_lag_ds.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -88,7 +88,7 @@ static void nss_gre_redir_lag_ds_update_
 	spin_lock_bh(&nss_gre_redir_lag_ds_stats_lock);
 	if (!nss_gre_redir_lag_ds_get_node_idx(ifnum, &idx)) {
 		spin_unlock_bh(&nss_gre_redir_lag_ds_stats_lock);
-		nss_warning("%p: Unable to update hash stats msg. Stats context not found.\n", nss_ctx);
+		nss_warning("%px: Unable to update hash stats msg. Stats context not found.\n", nss_ctx);
 		return;
 	}
 
@@ -132,12 +132,12 @@ static void nss_gre_redir_lag_ds_msg_han
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >=  NSS_GRE_REDIR_LAG_DS_MAX_MSG_TYPES) {
-		nss_warning("%p: received invalid message %d for gre interface\n", nss_ctx, ncm->type);
+		nss_warning("%px: received invalid message %d for gre interface\n", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_gre_redir_lag_ds_msg)) {
-		nss_warning("%p: Length of message is greater than required: %d\n", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: Length of message is greater than required: %d\n", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
@@ -146,7 +146,7 @@ static void nss_gre_redir_lag_ds_msg_han
 	 * to the same callback/app_data.
 	 */
 	if (ncm->response == NSS_CMN_RESPONSE_NOTIFY) {
-		ncm->cb = (nss_ptr_t)nss_ctx->nss_top->if_rx_msg_callback[ncm->interface];
+		ncm->cb = (nss_ptr_t)nss_core_get_msg_handler(nss_ctx, ncm->interface);
 		ncm->app_data = (nss_ptr_t)nss_ctx->nss_rx_interface_handlers[nss_ctx->id][ncm->interface].app_data;
 	}
 
@@ -197,18 +197,23 @@ static enum nss_gre_redir_lag_err_types
 	nss_assert(nss_ctx);
 	nss_assert(!nss_gre_redir_lag_ds_verify_ifnum(if_num));
 
+	status = nss_core_unregister_msg_handler(nss_ctx, if_num);
+	if (status != NSS_CORE_STATUS_SUCCESS) {
+		nss_warning("%px: Not able to unregister handler for gre_lag interface %d with NSS core\n", nss_ctx, if_num);
+		return NSS_GRE_REDIR_LAG_ERR_CORE_UNREGISTER_FAILED;
+	}
+
 	status = nss_core_unregister_handler(nss_ctx, if_num);
 	if (status != NSS_CORE_STATUS_SUCCESS) {
-		nss_warning("%p: Not able to unregister handler for gre_lag interface %d with NSS core\n", nss_ctx, if_num);
+		nss_warning("%px: Not able to unregister handler for gre_lag interface %d with NSS core\n", nss_ctx, if_num);
 		return NSS_GRE_REDIR_LAG_ERR_CORE_UNREGISTER_FAILED;
 	}
 
 	nss_core_unregister_subsys_dp(nss_ctx, if_num);
-	nss_top_main.if_rx_msg_callback[if_num] = NULL;
 	spin_lock_bh(&nss_gre_redir_lag_ds_stats_lock);
 	if (!nss_gre_redir_lag_ds_get_node_idx(if_num, &idx)) {
 		spin_unlock_bh(&nss_gre_redir_lag_ds_stats_lock);
-		nss_warning("%p: Stats context not found.\n", nss_ctx);
+		nss_warning("%px: Stats context not found.\n", nss_ctx);
 		return NSS_GRE_REDIR_LAG_ERR_STATS_INDEX_NOT_FOUND;
 	}
 
@@ -235,13 +240,22 @@ static struct nss_ctx_instance *nss_gre_
 	 */
 	status = nss_core_register_handler(nss_ctx, if_num, nss_gre_redir_lag_ds_msg_handler, app_ctx);
 	if (status != NSS_CORE_STATUS_SUCCESS) {
-		nss_warning("%p: Not able to register handler for gre_lag interface %d with NSS core\n", nss_ctx, if_num);
+		nss_warning("%px: Not able to register handler for gre_lag interface %d with NSS core\n", nss_ctx, if_num);
+		return NULL;
+	}
+
+	/*
+	 * Registering handler for sending tunnel interface msgs to NSS.
+	 */
+	status = nss_core_register_msg_handler(nss_ctx, if_num, cb_func_msg);
+	if (status != NSS_CORE_STATUS_SUCCESS) {
+		nss_core_unregister_handler(nss_ctx, if_num);
+		nss_warning("%px: Not able to register handler for gre_lag interface %d with NSS core\n", nss_ctx, if_num);
 		return NULL;
 	}
 
 	nss_core_register_subsys_dp(nss_ctx, if_num, cb_func_data, NULL, NULL, netdev, features);
 	nss_core_set_subsys_dp_type(nss_ctx, netdev, if_num, type);
-	nss_top_main.if_rx_msg_callback[if_num] = cb_func_msg;
 	spin_lock_bh(&nss_gre_redir_lag_ds_stats_lock);
 	for (i = 0; i < NSS_GRE_REDIR_LAG_MAX_NODE; i++) {
 		if (!tun_stats[i].valid) {
@@ -304,12 +318,12 @@ nss_tx_status_t nss_gre_redir_lag_ds_tx_
 	 * of type NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_LAG_DS.
 	 */
 	if (!nss_gre_redir_lag_ds_verify_ifnum(ncm->interface)) {
-		nss_warning("%p: tx request for another interface: %d\n", nss_ctx, ncm->interface);
+		nss_warning("%px: tx request for another interface: %d\n", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
 	if (ncm->type >= NSS_GRE_REDIR_LAG_DS_MAX_MSG_TYPES) {
-		nss_warning("%p: message type out of range: %d\n", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d\n", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
@@ -334,14 +348,14 @@ nss_tx_status_t nss_gre_redir_lag_ds_tx_
 
 	status = nss_gre_redir_lag_ds_tx_msg(nss_ctx, ngrm);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: GRE LAG DS msg tx failed\n", nss_ctx);
+		nss_warning("%px: GRE LAG DS msg tx failed\n", nss_ctx);
 		up(&nss_gre_redir_lag_ds_pvt.sem);
 		return status;
 	}
 
 	ret = wait_for_completion_timeout(&nss_gre_redir_lag_ds_pvt.complete, msecs_to_jiffies(NSS_GRE_REDIR_LAG_DS_TX_TIMEOUT));
 	if (!ret) {
-		nss_warning("%p: GRE LAG DS tx sync failed due to timeout\n", nss_ctx);
+		nss_warning("%px: GRE LAG DS tx sync failed due to timeout\n", nss_ctx);
 		nss_gre_redir_lag_ds_pvt.response = NSS_TX_FAILURE;
 	}
 
@@ -362,19 +376,19 @@ enum nss_gre_redir_lag_err_types nss_gre
 	nss_tx_status_t status;
 
 	if (!nss_gre_redir_lag_ds_verify_ifnum(ifnum)) {
-		nss_warning("%p: Unknown interface type %u.\n", nss_ctx, ifnum);
+		nss_warning("%px: Unknown interface type %u.\n", nss_ctx, ifnum);
 		return NSS_GRE_REDIR_LAG_ERR_INCORRECT_IFNUM;
 	}
 
 	ret = nss_gre_redir_lag_ds_unregister_if(ifnum);
 	if (ret) {
-		nss_warning("%p: Unable to unregister interface %u.\n", nss_ctx, ifnum);
+		nss_warning("%px: Unable to unregister interface %u.\n", nss_ctx, ifnum);
 		return ret;
 	}
 
 	status = nss_dynamic_interface_dealloc_node(ifnum, NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_LAG_DS);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: Unable to deallocate node %u\n", nss_ctx, ifnum);
+		nss_warning("%px: Unable to deallocate node %u\n", nss_ctx, ifnum);
 		return NSS_GRE_REDIR_LAG_ERR_DEALLOC_FAILED;
 	}
 
@@ -396,17 +410,17 @@ int nss_gre_redir_lag_ds_alloc_and_regis
 
 	ifnum = nss_dynamic_interface_alloc_node(NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_LAG_DS);
 	if (ifnum == -1) {
-		nss_warning("%p: Unable to allocate GRE_LAG node of type = %u\n", dev, NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_LAG_DS);
+		nss_warning("%px: Unable to allocate GRE_LAG node of type = %u\n", dev, NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_LAG_DS);
 		return -1;
 	}
 
 	nss_ctx = nss_gre_redir_lag_ds_register_if(ifnum, dev, cb_func_data,
 			cb_func_msg, 0, NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_LAG_DS, app_ctx);
 	if (!nss_ctx) {
-		nss_warning("%p: Unable to register GRE_LAG node of type = %u\n", dev, NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_LAG_DS);
+		nss_warning("%px: Unable to register GRE_LAG node of type = %u\n", dev, NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_LAG_DS);
 		status = nss_dynamic_interface_dealloc_node(ifnum, NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_LAG_DS);
 		if (status != NSS_TX_SUCCESS) {
-			nss_warning("%p: Unable to deallocate node of type = %u.\n", dev, NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_LAG_DS);
+			nss_warning("%px: Unable to deallocate node of type = %u.\n", dev, NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_LAG_DS);
 		}
 
 		return -1;
--- a/nss_gre_redir_lag_ds_log.c
+++ b/nss_gre_redir_lag_ds_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -51,8 +51,8 @@ static int8_t *nss_gre_redir_lag_ds_log_
 static void nss_gre_redir_lag_ds_log_add_sta_msg(struct nss_gre_redir_lag_ds_msg *ngm)
 {
 	struct nss_gre_redir_lag_ds_add_sta_msg *ngasm __maybe_unused = &ngm->msg.add_sta;
-	nss_trace("%p: NSS GRE REDIR LAG DS Add STA Message:\n"
-		"GRE REDIR LAG DS Station MAC Address: %p\n"
+	nss_trace("%px: NSS GRE REDIR LAG DS Add STA Message:\n"
+		"GRE REDIR LAG DS Station MAC Address: %px\n"
 		"GRE REDIR LAG DS Reorder Type: %d\n",
 		ngasm, ngasm->mac, ngasm->reorder_type);
 }
@@ -64,8 +64,8 @@ static void nss_gre_redir_lag_ds_log_add
 static void nss_gre_redir_lag_ds_log_del_sta_msg(struct nss_gre_redir_lag_ds_msg *ngm)
 {
 	struct nss_gre_redir_lag_ds_delete_sta_msg *ngdsm __maybe_unused = &ngm->msg.del_sta;
-	nss_trace("%p: NSS GRE REDIR LAG DS Del STA Message:\n"
-		"GRE REDIR LAG DS Station MAC Address: %p\n",
+	nss_trace("%px: NSS GRE REDIR LAG DS Del STA Message:\n"
+		"GRE REDIR LAG DS Station MAC Address: %px\n",
 		ngdsm, ngdsm->mac);
 }
 
@@ -76,8 +76,8 @@ static void nss_gre_redir_lag_ds_log_del
 static void nss_gre_redir_lag_ds_log_update_sta_msg(struct nss_gre_redir_lag_ds_msg *ngm)
 {
 	struct nss_gre_redir_lag_ds_update_sta_msg *ngusm __maybe_unused = &ngm->msg.update_sta;
-	nss_trace("%p: NSS GRE REDIR LAG DS Update STA Message:\n"
-		"GRE REDIR LAG DS Station MAC Address: %p\n"
+	nss_trace("%px: NSS GRE REDIR LAG DS Update STA Message:\n"
+		"GRE REDIR LAG DS Station MAC Address: %px\n"
 		"GRE REDIR LAG DS Reorder Type: %d\n",
 		ngusm, ngusm->mac, ngusm->reorder_type);
 }
@@ -108,7 +108,7 @@ static void nss_gre_redir_lag_ds_log_ver
 		break;
 
 	default:
-		nss_warning("%p: Invalid message type\n", ngm);
+		nss_warning("%px: Invalid message type\n", ngm);
 		break;
 	}
 }
@@ -120,11 +120,11 @@ static void nss_gre_redir_lag_ds_log_ver
 void nss_gre_redir_lag_ds_log_tx_msg(struct nss_gre_redir_lag_ds_msg *ngm)
 {
 	if (ngm->cm.type >= NSS_GRE_REDIR_LAG_DS_MAX_MSG_TYPES) {
-		nss_warning("%p: Invalid message type\n", ngm);
+		nss_warning("%px: Invalid message type\n", ngm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", ngm, ngm->cm.type, nss_gre_redir_lag_ds_log_message_types_str[ngm->cm.type]);
+	nss_info("%px: type[%d]:%s\n", ngm, ngm->cm.type, nss_gre_redir_lag_ds_log_message_types_str[ngm->cm.type]);
 	nss_gre_redir_lag_ds_log_verbose(ngm);
 }
 
@@ -135,26 +135,26 @@ void nss_gre_redir_lag_ds_log_tx_msg(str
 void nss_gre_redir_lag_ds_log_rx_msg(struct nss_gre_redir_lag_ds_msg *ngm)
 {
 	if (ngm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", ngm);
+		nss_warning("%px: Invalid response\n", ngm);
 		return;
 	}
 
 	if (ngm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (ngm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", ngm, ngm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", ngm, ngm->cm.type,
 			nss_gre_redir_lag_ds_log_message_types_str[ngm->cm.type],
 			ngm->cm.response, nss_cmn_response_str[ngm->cm.response]);
 		goto verbose;
 	}
 
 	if (ngm->cm.error >= NSS_GRE_REDIR_LAG_ERR_MAX) {
-		nss_warning("%p: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
+		nss_warning("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
 			ngm, ngm->cm.type, nss_gre_redir_lag_ds_log_message_types_str[ngm->cm.type],
 			ngm->cm.response, nss_cmn_response_str[ngm->cm.response],
 			ngm->cm.error);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
 		ngm, ngm->cm.type, nss_gre_redir_lag_ds_log_message_types_str[ngm->cm.type],
 		ngm->cm.response, nss_cmn_response_str[ngm->cm.response],
 		ngm->cm.error, nss_gre_redir_lag_ds_log_error_response_types_str[ngm->cm.error]);
--- a/nss_gre_redir_lag_us.c
+++ b/nss_gre_redir_lag_us.c
@@ -111,7 +111,7 @@ static void nss_gre_redir_lag_us_update_
 	spin_lock_bh(&cmn_ctx.nss_gre_redir_lag_us_stats_lock);
 	if (!nss_gre_redir_lag_us_get_node_idx(ifnum, &idx)) {
 		spin_unlock_bh(&cmn_ctx.nss_gre_redir_lag_us_stats_lock);
-		nss_warning("%p: Unable to update hash stats msg. Stats context not found.\n", nss_ctx);
+		nss_warning("%px: Unable to update hash stats msg. Stats context not found.\n", nss_ctx);
 		return;
 	}
 
@@ -150,7 +150,7 @@ static void nss_gre_redir_lag_us_hash_up
 	spin_lock_bh(&cmn_ctx.nss_gre_redir_lag_us_stats_lock);
 	if (!nss_gre_redir_lag_us_get_node_idx(ifnum, &idx)) {
 		spin_unlock_bh(&cmn_ctx.nss_gre_redir_lag_us_stats_lock);
-		nss_warning("%p: Unable to update hash stats msg. Stats context not found.\n", nss_ctx);
+		nss_warning("%px: Unable to update hash stats msg. Stats context not found.\n", nss_ctx);
 		return;
 	}
 
@@ -209,12 +209,12 @@ static void nss_gre_redir_lag_us_msg_han
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >=  NSS_GRE_REDIR_LAG_US_MAX_MSG_TYPES) {
-		nss_warning("%p: received invalid message %d for gre interface\n", nss_ctx, ncm->type);
+		nss_warning("%px: received invalid message %d for gre interface\n", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_gre_redir_lag_us_msg)) {
-		nss_warning("%p: Length of message is greater than required: %d\n", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: Length of message is greater than required: %d\n", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
@@ -223,7 +223,7 @@ static void nss_gre_redir_lag_us_msg_han
 	 * to the same callback/app_data.
 	 */
 	if (ncm->response == NSS_CMN_RESPONSE_NOTIFY) {
-		ncm->cb = (nss_ptr_t)nss_ctx->nss_top->if_rx_msg_callback[ncm->interface];
+		ncm->cb = (nss_ptr_t)nss_core_get_msg_handler(nss_ctx, ncm->interface);
 		ncm->app_data = (nss_ptr_t)nss_ctx->nss_rx_interface_handlers[nss_ctx->id][ncm->interface].app_data;
 	}
 
@@ -274,12 +274,12 @@ static nss_tx_status_t nss_gre_redir_lag
 	 * interface of type NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_LAG_US.
 	 */
 	if (!nss_gre_redir_lag_us_verify_ifnum(ncm->interface)) {
-		nss_warning("%p: tx request for another interface: %d\n", nss_ctx, ncm->interface);
+		nss_warning("%px: tx request for another interface: %d\n", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
 	if (ncm->type >= NSS_GRE_REDIR_LAG_US_MAX_MSG_TYPES) {
-		nss_warning("%p: message type out of range: %d\n", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d\n", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
@@ -311,14 +311,14 @@ static nss_tx_status_t nss_gre_redir_lag
 
 	status = nss_gre_redir_lag_us_tx_msg_with_size(nss_ctx, ngrm, size);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: gre_tx_msg failed\n", nss_ctx);
+		nss_warning("%px: gre_tx_msg failed\n", nss_ctx);
 		up(&nss_gre_redir_lag_us_sync_ctx.sem);
 		return status;
 	}
 
 	ret = wait_for_completion_timeout(&nss_gre_redir_lag_us_sync_ctx.complete, msecs_to_jiffies(NSS_GRE_REDIR_LAG_US_TX_TIMEOUT));
 	if (!ret) {
-		nss_warning("%p: GRE LAG US tx sync failed due to timeout\n", nss_ctx);
+		nss_warning("%px: GRE LAG US tx sync failed due to timeout\n", nss_ctx);
 		nss_gre_redir_lag_us_sync_ctx.response = NSS_TX_FAILURE;
 	}
 
@@ -358,7 +358,7 @@ static void nss_gre_redir_lag_us_stats_s
 		}
 
 		retry--;
-		nss_warning("%p: TX_NOT_OKAY, try again later\n", nss_ctx);
+		nss_warning("%px: TX_NOT_OKAY, try again later\n", nss_ctx);
 		usleep_range(100, 200);
 	}
 
@@ -383,7 +383,7 @@ static bool nss_gre_redir_lag_us_sync_wo
 	spin_lock_bh(&cmn_ctx.nss_gre_redir_lag_us_stats_lock);
 	if (!nss_gre_redir_lag_us_get_node_idx(ifnum, &idx)) {
 		spin_unlock_bh(&cmn_ctx.nss_gre_redir_lag_us_stats_lock);
-		nss_warning("%p: Unable to init work. Stats context not found.\n", nss_ctx);
+		nss_warning("%px: Unable to init work. Stats context not found.\n", nss_ctx);
 		return false;
 	}
 
@@ -394,7 +394,7 @@ static bool nss_gre_redir_lag_us_sync_wo
 			&(cmn_ctx.stats_ctx[idx].nss_gre_redir_lag_us_work), NSS_GRE_REDIR_LAG_US_STATS_SYNC_PERIOD);
 	if (!ret) {
 		spin_unlock_bh(&cmn_ctx.nss_gre_redir_lag_us_stats_lock);
-		nss_warning("%p: Unable to queue work function to work queue\n", nss_ctx);
+		nss_warning("%px: Unable to queue work function to work queue\n", nss_ctx);
 		return false;
 	}
 
@@ -415,14 +415,19 @@ static enum nss_gre_redir_lag_err_types
 	nss_assert(nss_ctx);
 	nss_assert(!nss_gre_redir_lag_us_verify_ifnum(if_num));
 
+	status = nss_core_unregister_msg_handler(nss_ctx, if_num);
+	if (status != NSS_CORE_STATUS_SUCCESS) {
+		nss_warning("%px: Not able to unregister handler for gre_lag interface %d with NSS core\n", nss_ctx, if_num);
+		return NSS_GRE_REDIR_LAG_ERR_CORE_UNREGISTER_FAILED;
+	}
+
 	status = nss_core_unregister_handler(nss_ctx, if_num);
 	if (status != NSS_CORE_STATUS_SUCCESS) {
-		nss_warning("%p: Not able to unregister handler for gre_lag interface %d with NSS core\n", nss_ctx, if_num);
+		nss_warning("%px: Not able to unregister handler for gre_lag interface %d with NSS core\n", nss_ctx, if_num);
 		return NSS_GRE_REDIR_LAG_ERR_CORE_UNREGISTER_FAILED;
 	}
 
 	nss_core_unregister_subsys_dp(nss_ctx, if_num);
-	nss_top_main.if_rx_msg_callback[if_num] = NULL;
 
 	spin_lock_bh(&cmn_ctx.nss_gre_redir_lag_us_stats_lock);
 	if (!nss_gre_redir_lag_us_get_node_idx(if_num, &idx)) {
@@ -479,7 +484,22 @@ static struct nss_ctx_instance *nss_gre_
 	 */
 	status = nss_core_register_handler(nss_ctx, if_num, nss_gre_redir_lag_us_msg_handler, app_ctx);
 	if (status != NSS_CORE_STATUS_SUCCESS) {
-		nss_warning("%p: Not able to register handler for gre_lag interface %d with NSS core\n", nss_ctx, if_num);
+		nss_warning("%px: Not able to register handler for gre_lag interface %d with NSS core\n", nss_ctx, if_num);
+		spin_lock_bh(&cmn_ctx.nss_gre_redir_lag_us_stats_lock);
+		cmn_ctx.stats_ctx[i].valid = false;
+		cmn_ctx.stats_ctx[i].cb = NULL;
+		cmn_ctx.stats_ctx[i].app_data = NULL;
+		spin_unlock_bh(&cmn_ctx.nss_gre_redir_lag_us_stats_lock);
+		return NULL;
+	}
+
+	/*
+	 * Registering handler for sending tunnel interface msgs to NSS.
+	 */
+	status = nss_core_register_msg_handler(nss_ctx, if_num, cb_func_msg);
+	if (status != NSS_CORE_STATUS_SUCCESS) {
+		nss_core_unregister_handler(nss_ctx, if_num);
+		nss_warning("%px: Not able to register handler for gre_lag interface %d with NSS core\n", nss_ctx, if_num);
 		spin_lock_bh(&cmn_ctx.nss_gre_redir_lag_us_stats_lock);
 		cmn_ctx.stats_ctx[i].valid = false;
 		cmn_ctx.stats_ctx[i].cb = NULL;
@@ -490,7 +510,6 @@ static struct nss_ctx_instance *nss_gre_
 
 	nss_core_register_subsys_dp(nss_ctx, if_num, cb_func_data, NULL, NULL, netdev, features);
 	nss_core_set_subsys_dp_type(nss_ctx, netdev, if_num, type);
-	nss_top_main.if_rx_msg_callback[if_num] = cb_func_msg;
 	return nss_ctx;
 }
 
@@ -524,32 +543,32 @@ bool nss_gre_redir_lag_us_configure_node
 
 	config = (struct nss_gre_redir_lag_us_msg *) kzalloc(sizeof(struct nss_gre_redir_lag_us_msg), GFP_KERNEL);
 	if (!config) {
-		nss_warning("%p: Unable to allocate memory to send configure message.\n", nss_ctx);
+		nss_warning("%px: Unable to allocate memory to send configure message.\n", nss_ctx);
 		return false;
 	}
 
 	iftype = nss_dynamic_interface_get_type(nss_ctx, ifnum);
 	if (iftype != NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_LAG_US) {
-		nss_warning("%p: Incorrect interface type %u\n", nss_ctx, iftype);
+		nss_warning("%px: Incorrect interface type %u\n", nss_ctx, iftype);
 		kfree(config);
 		return false;
 	}
 
 	if (!ngluc) {
-		nss_warning("%p: Pointer to GRE redir LAG US message is NULL.\n", nss_ctx);
+		nss_warning("%px: Pointer to GRE redir LAG US message is NULL.\n", nss_ctx);
 		kfree(config);
 		return false;
 	}
 
 	if ((ngluc->num_slaves < NSS_GRE_REDIR_LAG_MIN_SLAVE) || (ngluc->num_slaves > NSS_GRE_REDIR_LAG_MAX_SLAVE)) {
-		nss_warning("%p: Number of slaves is not in reange\n", nss_ctx);
+		nss_warning("%px: Number of slaves is not in reange\n", nss_ctx);
 		kfree(config);
 		return false;
 	}
 
 	ret = nss_gre_redir_lag_us_sync_work_init(ifnum);
 	if (!ret) {
-		nss_warning("%p: Unable to initialize work queue\n", nss_ctx);
+		nss_warning("%px: Unable to initialize work queue\n", nss_ctx);
 		kfree(config);
 		return false;
 	}
@@ -571,7 +590,7 @@ bool nss_gre_redir_lag_us_configure_node
 	spin_lock_bh(&cmn_ctx.nss_gre_redir_lag_us_stats_lock);
 	if (nss_gre_redir_lag_us_get_node_idx(ifnum, &idx)) {
 		spin_unlock_bh(&cmn_ctx.nss_gre_redir_lag_us_stats_lock);
-		nss_warning("%p: Stats context not found.\n", nss_ctx);
+		nss_warning("%px: Stats context not found.\n", nss_ctx);
 		return false;
 	}
 
@@ -581,7 +600,7 @@ bool nss_gre_redir_lag_us_configure_node
 	 * Work is per LAG US node. Cancel work as configuration failed.
 	 */
 	cancel_delayed_work_sync(&(cmn_ctx.stats_ctx[idx].nss_gre_redir_lag_us_work));
-	nss_warning("%p: Unable to configure upstream lag node %d.\n", nss_ctx, ifnum);
+	nss_warning("%px: Unable to configure upstream lag node %d.\n", nss_ctx, ifnum);
 	return false;
 }
 EXPORT_SYMBOL(nss_gre_redir_lag_us_configure_node);
@@ -645,19 +664,19 @@ enum nss_gre_redir_lag_err_types nss_gre
 	nss_tx_status_t status;
 
 	if (!nss_gre_redir_lag_us_verify_ifnum(ifnum)) {
-		nss_warning("%p: Unknown interface type %u.\n", nss_ctx, ifnum);
+		nss_warning("%px: Unknown interface type %u.\n", nss_ctx, ifnum);
 		return NSS_GRE_REDIR_LAG_ERR_INCORRECT_IFNUM;
 	}
 
 	ret = nss_gre_redir_lag_us_unregister_if(ifnum);
 	if (ret) {
-		nss_warning("%p: Unable to unregister interface %u.\n", nss_ctx, ifnum);
+		nss_warning("%px: Unable to unregister interface %u.\n", nss_ctx, ifnum);
 		return ret;
 	}
 
 	status = nss_dynamic_interface_dealloc_node(ifnum, NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_LAG_US);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: Unable to deallocate node %u\n", nss_ctx, ifnum);
+		nss_warning("%px: Unable to deallocate node %u\n", nss_ctx, ifnum);
 		return NSS_GRE_REDIR_LAG_ERR_DEALLOC_FAILED;
 	}
 
@@ -679,17 +698,17 @@ int nss_gre_redir_lag_us_alloc_and_regis
 
 	ifnum = nss_dynamic_interface_alloc_node(NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_LAG_US);
 	if (ifnum == -1) {
-		nss_warning("%p: Unable to allocate GRE_LAG node of type = %u\n", dev, NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_LAG_US);
+		nss_warning("%px: Unable to allocate GRE_LAG node of type = %u\n", dev, NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_LAG_US);
 		return -1;
 	}
 
 	nss_ctx = nss_gre_redir_lag_us_register_if(ifnum, dev, cb_func_data,
 			cb_func_msg, 0, NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_LAG_US, app_ctx);
 	if (!nss_ctx) {
-		nss_warning("%p: Unable to register GRE_LAG node of type = %u\n", dev, NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_LAG_US);
+		nss_warning("%px: Unable to register GRE_LAG node of type = %u\n", dev, NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_LAG_US);
 		status = nss_dynamic_interface_dealloc_node(ifnum, NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_LAG_US);
 		if (status != NSS_TX_SUCCESS) {
-			nss_warning("%p: Unable to deallocate node.\n", dev);
+			nss_warning("%px: Unable to deallocate node.\n", dev);
 		}
 
 		return -1;
--- a/nss_gre_redir_lag_us_log.c
+++ b/nss_gre_redir_lag_us_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -53,10 +53,10 @@ static int8_t *nss_gre_redir_lag_us_log_
 static void nss_gre_redir_lag_us_log_config_msg(struct nss_gre_redir_lag_us_msg *ngm)
 {
 	struct nss_gre_redir_lag_us_config_msg *ngcm __maybe_unused = &ngm->msg.config_us;
-	nss_trace("%p: NSS GRE REDIR LAG Config Message:\n"
+	nss_trace("%px: NSS GRE REDIR LAG Config Message:\n"
 		"GRE REDIR LAG US Hash Mode: %d\n"
 		"GRE REDIR LAG US Number of Slaves: %d\n"
-		"GRE REDIR LAG US Interface Number: %p\n",
+		"GRE REDIR LAG US Interface Number: %px\n",
 		ngcm, ngcm->hash_mode, ngcm->num_slaves,
 		ngcm->if_num);
 }
@@ -68,10 +68,10 @@ static void nss_gre_redir_lag_us_log_con
 static void nss_gre_redir_lag_us_log_add_hash_node_msg(struct nss_gre_redir_lag_us_msg *ngm)
 {
 	struct nss_gre_redir_lag_us_add_hash_node_msg *ngam __maybe_unused = &ngm->msg.add_hash;
-	nss_trace("%p: NSS GRE REDIR LAG Add Hash Node Message:\n"
+	nss_trace("%px: NSS GRE REDIR LAG Add Hash Node Message:\n"
 		"GRE REDIR LAG US Interface Number: %d\n"
-		"GRE REDIR LAG US Source MAC: %p\n"
-		"GRE REDIR LAG US Destination MAC: %p\n",
+		"GRE REDIR LAG US Source MAC: %px\n"
+		"GRE REDIR LAG US Destination MAC: %px\n",
 		ngam, ngam->if_num, ngam->src_mac,
 		ngam->dest_mac);
 }
@@ -83,9 +83,9 @@ static void nss_gre_redir_lag_us_log_add
 static void nss_gre_redir_lag_us_log_del_hash_node_msg(struct nss_gre_redir_lag_us_msg *ngm)
 {
 	struct nss_gre_redir_lag_us_del_hash_node_msg *ngdm __maybe_unused = &ngm->msg.del_hash;
-	nss_trace("%p: NSS GRE REDIR LAG Del Hash Node Message:\n"
-		"GRE REDIR LAG US Source MAC: %p\n"
-		"GRE REDIR LAG US Destination MAC: %p\n",
+	nss_trace("%px: NSS GRE REDIR LAG Del Hash Node Message:\n"
+		"GRE REDIR LAG US Source MAC: %px\n"
+		"GRE REDIR LAG US Destination MAC: %px\n",
 		ngdm, ngdm->src_mac,ngdm->dest_mac);
 }
 
@@ -96,9 +96,9 @@ static void nss_gre_redir_lag_us_log_del
 static void nss_gre_redir_lag_us_log_query_hash_node_msg(struct nss_gre_redir_lag_us_msg *ngm)
 {
 	struct nss_gre_redir_lag_us_query_hash_node_msg *ngqm __maybe_unused = &ngm->msg.query_hash;
-	nss_trace("%p: NSS GRE REDIR LAG Query Hash Node Message:\n"
-		"GRE REDIR LAG US Source MAC: %p\n"
-		"GRE REDIR LAG US Destination MAC: %p\n"
+	nss_trace("%px: NSS GRE REDIR LAG Query Hash Node Message:\n"
+		"GRE REDIR LAG US Source MAC: %px\n"
+		"GRE REDIR LAG US Destination MAC: %px\n"
 		"GRE REDIR LAG US Interface Number: %d\n",
 		ngqm, ngqm->src_mac, ngqm->dest_mac,
 		ngqm->ifnum);
@@ -135,7 +135,7 @@ static void nss_gre_redir_lag_us_log_ver
 		break;
 
 	default:
-		nss_warning("%p: Invalid message type\n", ngm);
+		nss_warning("%px: Invalid message type\n", ngm);
 		break;
 	}
 }
@@ -147,11 +147,11 @@ static void nss_gre_redir_lag_us_log_ver
 void nss_gre_redir_lag_us_log_tx_msg(struct nss_gre_redir_lag_us_msg *ngm)
 {
 	if (ngm->cm.type >= NSS_GRE_REDIR_LAG_US_MAX_MSG_TYPES) {
-		nss_warning("%p: Invalid message type\n", ngm);
+		nss_warning("%px: Invalid message type\n", ngm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", ngm, ngm->cm.type, nss_gre_redir_lag_us_log_message_types_str[ngm->cm.type]);
+	nss_info("%px: type[%d]:%s\n", ngm, ngm->cm.type, nss_gre_redir_lag_us_log_message_types_str[ngm->cm.type]);
 	nss_gre_redir_lag_us_log_verbose(ngm);
 }
 
@@ -162,26 +162,26 @@ void nss_gre_redir_lag_us_log_tx_msg(str
 void nss_gre_redir_lag_us_log_rx_msg(struct nss_gre_redir_lag_us_msg *ngm)
 {
 	if (ngm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", ngm);
+		nss_warning("%px: Invalid response\n", ngm);
 		return;
 	}
 
 	if (ngm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (ngm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", ngm, ngm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", ngm, ngm->cm.type,
 			nss_gre_redir_lag_us_log_message_types_str[ngm->cm.type],
 			ngm->cm.response, nss_cmn_response_str[ngm->cm.response]);
 		goto verbose;
 	}
 
 	if (ngm->cm.error >= NSS_GRE_REDIR_LAG_ERR_MAX) {
-		nss_warning("%p: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
+		nss_warning("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
 			ngm, ngm->cm.type, nss_gre_redir_lag_us_log_message_types_str[ngm->cm.type],
 			ngm->cm.response, nss_cmn_response_str[ngm->cm.response],
 			ngm->cm.error);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
 		ngm, ngm->cm.type, nss_gre_redir_lag_us_log_message_types_str[ngm->cm.type],
 		ngm->cm.response, nss_cmn_response_str[ngm->cm.response],
 		ngm->cm.error, nss_gre_redir_lag_us_log_error_response_types_str[ngm->cm.error]);
--- a/nss_gre_redir_log.c
+++ b/nss_gre_redir_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018-2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -43,10 +43,10 @@ static int8_t *nss_gre_redir_log_message
 static void nss_gre_redir_log_inner_configure_msg(struct nss_gre_redir_msg *ngm)
 {
 	struct nss_gre_redir_inner_configure_msg *ngicm __maybe_unused = &ngm->msg.inner_configure;
-	nss_trace("%p: NSS GRE Redir Inner Configure message"
+	nss_trace("%px: NSS GRE Redir Inner Configure message"
 		"GRE REDIR IP Header Type: %d\n"
-		"GRE REDIR Source IP: %p\n"
-		"GRE REDIR Destination IP: %p\n"
+		"GRE REDIR Source IP: %px\n"
+		"GRE REDIR Destination IP: %px\n"
 		"GRE REDIR Outer Interface: %d\n"
 		"GRE REDIR Do not Fragment: %d\n"
 		"GRE REDIR IP TTL: %d\n"
@@ -64,7 +64,7 @@ static void nss_gre_redir_log_inner_conf
 static void nss_gre_redir_log_interface_map_msg(struct nss_gre_redir_msg *ngm)
 {
 	struct nss_gre_redir_interface_map_msg *ngicm __maybe_unused = &ngm->msg.interface_map;
-	nss_trace("%p: NSS GRE Redir Interface Map message"
+	nss_trace("%px: NSS GRE Redir Interface Map message"
 		"GRE REDIR NSS VAP Interface: %d\n"
 		"GRE REDIR Next Hop NSS Interface: %d\n"
 		"GRE REDIR Radio ID: %d\n"
@@ -85,7 +85,7 @@ static void nss_gre_redir_log_interface_
 static void nss_gre_redir_log_interface_unmap_msg(struct nss_gre_redir_msg *ngm)
 {
 	struct nss_gre_redir_interface_unmap_msg *ngicm __maybe_unused = &ngm->msg.interface_unmap;
-	nss_trace("%p: NSS GRE Redir Interface Map message"
+	nss_trace("%px: NSS GRE Redir Interface Map message"
 		"GRE REDIR NSS VAP Interface: %d\n"
 		"GRE REDIR Radio ID: %d\n"
 		"GRE REDIR VAP ID: %d\n",
@@ -100,7 +100,7 @@ static void nss_gre_redir_log_interface_
 static void nss_gre_redir_log_sjack_map_msg(struct nss_gre_redir_msg *ngm)
 {
 	struct nss_gre_redir_sjack_map_msg *ngscm __maybe_unused = &ngm->msg.sjack_map;
-	nss_trace("%p: NSS GRE Redir SJACK Map message"
+	nss_trace("%px: NSS GRE Redir SJACK Map message"
 		"GRE REDIR Eth NSS Interface: %d\n"
 		"GRE REDIR Eth Interface ID: %d\n"
 		"GRE REDIR IPSec pattern: %x\n",
@@ -115,7 +115,7 @@ static void nss_gre_redir_log_sjack_map_
 static void nss_gre_redir_log_sjack_unmap_msg(struct nss_gre_redir_msg *ngm)
 {
 	struct nss_gre_redir_sjack_unmap_msg *ngscm __maybe_unused = &ngm->msg.sjack_unmap;
-	nss_trace("%p: NSS GRE Redir SJACK Map message"
+	nss_trace("%px: NSS GRE Redir SJACK Map message"
 		"GRE REDIR Eth NSS Interface: %d\n"
 		"GRE REDIR Eth Interface ID: %d\n",
 		ngscm, ngscm->eth_nssif,
@@ -129,7 +129,7 @@ static void nss_gre_redir_log_sjack_unma
 static void nss_gre_redir_log_outer_configure_msg(struct nss_gre_redir_msg *ngm)
 {
 	struct nss_gre_redir_outer_configure_msg *ngocm __maybe_unused = &ngm->msg.outer_configure;
-	nss_trace("%p: NSS GRE Redir Outer Configure message"
+	nss_trace("%px: NSS GRE Redir Outer Configure message"
 		"GRE REDIR IP Header Type: %d\n"
 		"GRE REDIR Host Inner Interface: %d\n"
 		"GRE REDIR NSS Inner Interface: %d\n"
@@ -149,7 +149,7 @@ static void nss_gre_redir_log_outer_conf
 static void nss_gre_redir_log_exception_ds_reg_cb_msg(struct nss_gre_redir_msg *ngm)
 {
 	struct nss_gre_redir_exception_ds_reg_cb_msg *exception_ds_configure __maybe_unused = &ngm->msg.exception_ds_configure;
-	nss_trace("%p: NSS GRE redir exception completion callback registration message\n"
+	nss_trace("%px: NSS GRE redir exception completion callback registration message\n"
 			"vap_if_num: %d\n", ngm, exception_ds_configure->dst_vap_nssif);
 }
 
@@ -195,7 +195,7 @@ static void nss_gre_redir_log_verbose(st
 		break;
 
 	default:
-		nss_warning("%p: Invalid message type\n", ngm);
+		nss_warning("%px: Invalid message type\n", ngm);
 		break;
 	}
 }
@@ -207,11 +207,11 @@ static void nss_gre_redir_log_verbose(st
 void nss_gre_redir_log_tx_msg(struct nss_gre_redir_msg *ngm)
 {
 	if (ngm->cm.type >= NSS_GRE_REDIR_MAX_MSG_TYPES) {
-		nss_warning("%p: Invalid message type\n", ngm);
+		nss_warning("%px: Invalid message type\n", ngm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", ngm, ngm->cm.type, nss_gre_redir_log_message_types_str[ngm->cm.type]);
+	nss_info("%px: type[%d]:%s\n", ngm, ngm->cm.type, nss_gre_redir_log_message_types_str[ngm->cm.type]);
 	nss_gre_redir_log_verbose(ngm);
 }
 
@@ -222,18 +222,18 @@ void nss_gre_redir_log_tx_msg(struct nss
 void nss_gre_redir_log_rx_msg(struct nss_gre_redir_msg *ngm)
 {
 	if (ngm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", ngm);
+		nss_warning("%px: Invalid response\n", ngm);
 		return;
 	}
 
 	if (ngm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (ngm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", ngm, ngm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", ngm, ngm->cm.type,
 			nss_gre_redir_log_message_types_str[ngm->cm.type],
 			ngm->cm.response, nss_cmn_response_str[ngm->cm.response]);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s\n",
 		ngm, ngm->cm.type, nss_gre_redir_log_message_types_str[ngm->cm.type],
 		ngm->cm.response, nss_cmn_response_str[ngm->cm.response]);
 
--- a/nss_gre_redir_mark.c
+++ b/nss_gre_redir_mark.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -62,12 +62,12 @@ static void nss_gre_redir_mark_stats_syn
 	struct net_device *dev;
 	dev = nss_cmn_get_interface_dev(nss_ctx, if_num);
 	if (!dev) {
-		nss_warning("%p: Unable to find net device for the interface %d\n", nss_ctx, if_num);
+		nss_warning("%px: Unable to find net device for the interface %d\n", nss_ctx, if_num);
 		return;
 	}
 
 	if (if_num != NSS_GRE_REDIR_MARK_INTERFACE) {
-		nss_warning("%p: Unknown type for interface %d\n", nss_ctx, if_num);
+		nss_warning("%px: Unknown type for interface %d\n", nss_ctx, if_num);
 		return;
 	}
 
@@ -116,12 +116,12 @@ static void nss_gre_redir_mark_handler(s
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >= NSS_GRE_REDIR_MARK_MSG_MAX) {
-		nss_warning("%p: received invalid message %d for GRE redir mark interface", nss_ctx, ncm->type);
+		nss_warning("%px: received invalid message %d for GRE redir mark interface", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_gre_redir_mark_msg)) {
-		nss_warning("%p: length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
@@ -145,7 +145,7 @@ static void nss_gre_redir_mark_handler(s
 	 * interface.
 	 */
 	if (ncm->response == NSS_CMN_RESPONSE_NOTIFY) {
-		ncm->cb = (nss_ptr_t)nss_top_main.if_rx_msg_callback[ncm->interface];
+		ncm->cb = (nss_ptr_t)nss_core_get_msg_handler(nss_ctx, ncm->interface);
 		ncm->app_data = (nss_ptr_t)nss_ctx->subsys_dp_register[ncm->interface].ndev;
 	}
 
@@ -202,7 +202,7 @@ nss_tx_status_t nss_gre_redir_mark_reg_c
 
         vap_type = nss_dynamic_interface_get_type(nss_ctx, ngrcm->nss_if_num);
         if ((vap_type != NSS_DYNAMIC_INTERFACE_TYPE_VAP)) {
-                nss_warning("%p: Incorrect type for vap interface type = %u", nss_ctx, vap_type);
+                nss_warning("%px: Incorrect type for vap interface type = %u", nss_ctx, vap_type);
                 return NSS_TX_FAILURE_BAD_PARAM;
         }
 
@@ -214,7 +214,7 @@ nss_tx_status_t nss_gre_redir_mark_reg_c
 
         status = nss_gre_redir_mark_tx_msg_sync(nss_ctx, &config);
         if (status != NSS_TX_SUCCESS) {
-                nss_warning("%p: Unable to register callback from GRE redir mark interface %d\n", nss_ctx, ifnum);
+                nss_warning("%px: Unable to register callback from GRE redir mark interface %d\n", nss_ctx, ifnum);
         }
 
         return status;
@@ -238,12 +238,12 @@ nss_tx_status_t nss_gre_redir_mark_tx_ms
 	 * interface should be of type of redir mark
 	 */
 	if (ncm->interface != NSS_GRE_REDIR_MARK_INTERFACE) {
-		nss_warning("%p: tx request for another interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: tx request for another interface: %d", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
 	if (ncm->type >= NSS_GRE_REDIR_MARK_MSG_MAX) {
-		nss_warning("%p: message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
@@ -268,14 +268,14 @@ nss_tx_status_t nss_gre_redir_mark_tx_ms
 	ngrm->cm.app_data = (nss_ptr_t)NULL;
 	status = nss_gre_redir_mark_tx_msg(nss_ctx, ngrm);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: GRE redir mark tx_msg failed\n", nss_ctx);
+		nss_warning("%px: GRE redir mark tx_msg failed\n", nss_ctx);
 		up(&nss_gre_redir_mark_pvt.sem);
 		return status;
 	}
 
 	ret = wait_for_completion_timeout(&nss_gre_redir_mark_pvt.complete, msecs_to_jiffies(NSS_GRE_REDIR_MARK_TX_TIMEOUT));
 	if (!ret) {
-		nss_warning("%p: GRE redir mark message tx sync failed due to timeout\n", nss_ctx);
+		nss_warning("%px: GRE redir mark message tx sync failed due to timeout\n", nss_ctx);
 		nss_gre_redir_mark_pvt.response = NSS_TX_FAILURE;
 	}
 
@@ -291,13 +291,13 @@ EXPORT_SYMBOL(nss_gre_redir_mark_tx_msg_
  */
 nss_tx_status_t nss_gre_redir_mark_tx_buf(struct nss_ctx_instance *nss_ctx, struct sk_buff *os_buf, uint32_t if_num)
 {
-	nss_trace("%p: GRE redir mark If Tx packet, interface id:%d, data=%p", nss_ctx, if_num, os_buf->data);
+	nss_trace("%px: GRE redir mark If Tx packet, interface id:%d, data=%px", nss_ctx, if_num, os_buf->data);
 
 	/*
 	 * We expect Tx packets to the GRE redir mark interface only.
 	 */
 	if (if_num != NSS_GRE_REDIR_MARK_INTERFACE) {
-		nss_warning("%p: Invalid interface:%d for GRE redir mark packets\n", nss_ctx, if_num);
+		nss_warning("%px: Invalid interface:%d for GRE redir mark packets\n", nss_ctx, if_num);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
@@ -323,6 +323,7 @@ bool nss_gre_redir_mark_unregister_if(ui
 {
 	struct nss_ctx_instance *nss_ctx __maybe_unused = (struct nss_ctx_instance *)&nss_top_main.nss[nss_top_main.gre_redir_handler_id];
 	struct net_device *dev;
+	uint32_t status;
 
 	nss_assert(nss_ctx);
 	nss_assert(if_num == NSS_GRE_REDIR_MARK_INTERFACE);
@@ -332,7 +333,14 @@ bool nss_gre_redir_mark_unregister_if(ui
 	BUG_ON(!dev);
 
 	nss_core_unregister_subsys_dp(nss_ctx, if_num);
-	nss_top_main.if_rx_msg_callback[if_num] = NULL;
+	status = nss_core_unregister_msg_handler(nss_ctx, if_num);
+	if (status != NSS_CORE_STATUS_SUCCESS) {
+		nss_warning("%px: Not able to unregister handler for gre_redir_mark interface %d with NSS core\n",
+				nss_ctx, if_num);
+		return false;
+	}
+
+	nss_ctx->nss_rx_interface_handlers[nss_ctx->id][if_num].msg_cb = NULL;
 	return true;
 }
 EXPORT_SYMBOL(nss_gre_redir_mark_unregister_if);
@@ -346,6 +354,7 @@ struct nss_ctx_instance *nss_gre_redir_m
 		uint32_t features)
 {
 	struct nss_ctx_instance *nss_ctx = (struct nss_ctx_instance *)&nss_top_main.nss[nss_top_main.gre_redir_handler_id];
+	uint32_t status;
 
 	nss_assert(nss_ctx);
 	nss_assert(if_num == NSS_GRE_REDIR_MARK_INTERFACE);
@@ -354,7 +363,13 @@ struct nss_ctx_instance *nss_gre_redir_m
 	 * Registering the interface with network data path.
 	 */
 	nss_core_register_subsys_dp(nss_ctx, if_num, cb_func_data, NULL, NULL, netdev, features);
-	nss_top_main.if_rx_msg_callback[if_num] = cb_func_msg;
+	status = nss_core_register_msg_handler(nss_ctx, NSS_GRE_REDIR_MARK_INTERFACE, cb_func_msg);
+	if (status != NSS_CORE_STATUS_SUCCESS) {
+		nss_warning("%px: Not able to register handler for gre_redir_mark interface %d with NSS core\n",
+				nss_ctx, if_num);
+		return NULL;
+	}
+
 	return nss_ctx;
 }
 EXPORT_SYMBOL(nss_gre_redir_mark_register_if);
@@ -385,7 +400,7 @@ void nss_gre_redir_mark_register_handler
 	 */
 	gre_redir_mark_dentry = nss_gre_redir_mark_stats_dentry_create();
 	if (!gre_redir_mark_dentry) {
-		nss_warning("%p: Not able to create debugfs entry\n", nss_ctx);
+		nss_warning("%px: Not able to create debugfs entry\n", nss_ctx);
 		return;
 	}
 
@@ -397,7 +412,7 @@ void nss_gre_redir_mark_register_handler
 	if (status != NSS_CORE_STATUS_SUCCESS) {
 		debugfs_remove_recursive(gre_redir_mark_dentry);
 		gre_redir_mark_dentry = NULL;
-		nss_warning("%p: Not able to register handler for GRE redir mark with NSS core\n", nss_ctx);
+		nss_warning("%px: Not able to register handler for GRE redir mark with NSS core\n", nss_ctx);
 		return;
 	}
 }
--- a/nss_gre_redir_mark_log.c
+++ b/nss_gre_redir_mark_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -14,7 +14,6 @@
  **************************************************************************
  */
 
-
 #include "nss_core.h"
 
 /*
@@ -43,7 +42,7 @@ static int8_t *nss_gre_redir_mark_log_er
 static void nss_gre_redir_mark_log_reg_cb_msg(struct nss_gre_redir_mark_msg *ncm)
 {
 	struct nss_gre_redir_mark_register_cb_msg *reg_cb_msg __maybe_unused = &ncm->msg.reg_cb_msg;
-	nss_trace("%p: NSS GRE redir mark callback registration message \n"
+	nss_trace("%px: NSS GRE redir mark callback registration message \n"
 			"nss_if_num: %d\n", ncm, reg_cb_msg->nss_if_num);
 }
 
@@ -65,7 +64,7 @@ static void nss_gre_redir_mark_log_verbo
 		break;
 
 	default:
-		nss_trace("%p: Invalid message type\n", ncm);
+		nss_trace("%px: Invalid message type\n", ncm);
 		break;
 	}
 }
@@ -77,11 +76,11 @@ static void nss_gre_redir_mark_log_verbo
 void nss_gre_redir_mark_log_tx_msg(struct nss_gre_redir_mark_msg *ngm)
 {
 	if (ngm->cm.type >= NSS_GRE_REDIR_MARK_MSG_MAX) {
-		nss_warning("%p: Invalid message type\n", ngm);
+		nss_warning("%px: Invalid message type\n", ngm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", ngm, ngm->cm.type, nss_gre_redir_mark_log_message_types_str[ngm->cm.type]);
+	nss_info("%px: type[%d]:%s\n", ngm, ngm->cm.type, nss_gre_redir_mark_log_message_types_str[ngm->cm.type]);
 	nss_gre_redir_mark_log_verbose(ngm);
 }
 /*
@@ -91,26 +90,26 @@ void nss_gre_redir_mark_log_tx_msg(struc
 void nss_gre_redir_mark_log_rx_msg(struct nss_gre_redir_mark_msg *ncm)
 {
 	if (ncm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", ncm);
+		nss_warning("%px: Invalid response\n", ncm);
 		return;
 	}
 
 	if (ncm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (ncm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", ncm, ncm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", ncm, ncm->cm.type,
 			nss_gre_redir_mark_log_message_types_str[ncm->cm.type],
 			ncm->cm.response, nss_cmn_response_str[ncm->cm.response]);
 		goto verbose;
 	}
 
 	if (ncm->cm.error >= NSS_GRE_REDIR_MARK_ERROR_TYPE_MAX) {
-		nss_warning("%p: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
+		nss_warning("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
 			ncm, ncm->cm.type, nss_gre_redir_mark_log_message_types_str[ncm->cm.type],
 			ncm->cm.response, nss_cmn_response_str[ncm->cm.response],
 			ncm->cm.error);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
 		ncm, ncm->cm.type, nss_gre_redir_mark_log_message_types_str[ncm->cm.type],
 		ncm->cm.response, nss_cmn_response_str[ncm->cm.response],
 		ncm->cm.error, nss_gre_redir_mark_log_error_response_types_str[ncm->cm.error]);
@@ -118,4 +117,3 @@ void nss_gre_redir_mark_log_rx_msg(struc
 verbose:
 	nss_gre_redir_mark_log_verbose(ncm);
 }
-
--- a/nss_gre_tunnel.c
+++ b/nss_gre_tunnel.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2016-2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -74,12 +74,12 @@ static void nss_gre_tunnel_handler(struc
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >= NSS_GRE_TUNNEL_MSG_MAX) {
-		nss_warning("%p: received invalid message %d for GRE_TUNNEL interface %d", nss_ctx, ncm->type, ncm->interface);
+		nss_warning("%px: received invalid message %d for GRE_TUNNEL interface %d", nss_ctx, ncm->type, ncm->interface);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_gre_tunnel_msg)) {
-		nss_warning("%p: gre_tunnel message length is invalid: %d", nss_ctx, ncm->len);
+		nss_warning("%px: gre_tunnel message length is invalid: %d", nss_ctx, ncm->len);
 		return;
 	}
 
@@ -153,7 +153,7 @@ nss_tx_status_t nss_gre_tunnel_inquiry(
 	nim.msg.configure = *inquiry_info;
 	nss_tx_status = nss_gre_tunnel_tx_msg(nss_ctx, &nim);
 	if (nss_tx_status != NSS_TX_SUCCESS) {
-		nss_warning("%p: Send GT inquiry message failed\n", inquiry_info);
+		nss_warning("%px: Send GT inquiry message failed\n", inquiry_info);
 	}
 
 	return nss_tx_status;
@@ -181,7 +181,7 @@ int nss_gre_tunnel_ifnum_with_core_id(in
 	NSS_VERIFY_CTX_MAGIC(nss_ctx);
 
 	if (nss_is_dynamic_interface(if_num) == false) {
-		nss_info("%p: Invalid if_num: %d, must be a dynamic interface\n", nss_ctx, if_num);
+		nss_info("%px: Invalid if_num: %d, must be a dynamic interface\n", nss_ctx, if_num);
 		return 0;
 	}
 
@@ -219,7 +219,7 @@ nss_tx_status_t nss_gre_tunnel_tx_msg(st
 	 * Sanity check message
 	 */
 	if (ncm->type >= NSS_GRE_TUNNEL_MSG_MAX) {
-		nss_warning("%p: gre_tunnel message type out of range: %d",
+		nss_warning("%px: gre_tunnel message type out of range: %d",
 			nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
@@ -272,7 +272,7 @@ nss_tx_status_t nss_gre_tunnel_tx_msg_sy
 
 	status = nss_gre_tunnel_tx_msg(nss_ctx, ngtm);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: gre_tunnel_tx_msg failed\n", nss_ctx);
+		nss_warning("%px: gre_tunnel_tx_msg failed\n", nss_ctx);
 		up(&gre_tunnel_pvt.sem);
 		return status;
 	}
@@ -280,7 +280,7 @@ nss_tx_status_t nss_gre_tunnel_tx_msg_sy
 	ret = wait_for_completion_timeout(&gre_tunnel_pvt.complete, msecs_to_jiffies(NSS_GRE_TUNNEL_TX_TIMEOUT));
 
 	if (!ret) {
-		nss_warning("%p: GRE Tunnel msg tx failed due to timeout\n", nss_ctx);
+		nss_warning("%px: GRE Tunnel msg tx failed due to timeout\n", nss_ctx);
 		gre_tunnel_pvt.response = NSS_TX_FAILURE;
 	}
 
@@ -330,12 +330,12 @@ struct nss_ctx_instance *nss_gre_tunnel_
 	spin_unlock_bh(&nss_gre_tunnel_stats_session_debug_lock);
 
 	if (i == NSS_MAX_GRE_TUNNEL_SESSIONS) {
-		nss_warning("%p: Cannot find free slot for GRE Tunnel session stats, I/F:%u\n", nss_ctx, if_num);
+		nss_warning("%px: Cannot find free slot for GRE Tunnel session stats, I/F:%u\n", nss_ctx, if_num);
 		return NULL;
 	}
 
 	if (nss_ctx->subsys_dp_register[if_num].ndev) {
-		nss_warning("%p: Cannot find free slot for GRE Tunnel NSS I/F:%u\n", nss_ctx, if_num);
+		nss_warning("%px: Cannot find free slot for GRE Tunnel NSS I/F:%u\n", nss_ctx, if_num);
 		nss_gre_tunnel_session_debug_stats[i].valid = false;
 		nss_gre_tunnel_session_debug_stats[i].if_num = 0;
 		nss_gre_tunnel_session_debug_stats[i].if_index = 0;
@@ -374,12 +374,12 @@ void nss_gre_tunnel_unregister_if(uint32
 	spin_unlock_bh(&nss_gre_tunnel_stats_session_debug_lock);
 
 	if (i == NSS_MAX_GRE_TUNNEL_SESSIONS) {
-		nss_warning("%p: Cannot find debug stats for GRE Tunnel session: %d\n", nss_ctx, if_num);
+		nss_warning("%px: Cannot find debug stats for GRE Tunnel session: %d\n", nss_ctx, if_num);
 		return;
 	}
 
 	if (!nss_ctx->subsys_dp_register[if_num].ndev) {
-		nss_warning("%p: Cannot find registered netdev for GRE Tunnel NSS I/F: %d\n", nss_ctx, if_num);
+		nss_warning("%px: Cannot find registered netdev for GRE Tunnel NSS I/F: %d\n", nss_ctx, if_num);
 
 		return;
 	}
--- a/nss_gre_tunnel_log.c
+++ b/nss_gre_tunnel_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -40,7 +40,7 @@ static int8_t *nss_gre_tunnel_log_messag
 static void nss_gre_tunnel_log_configure_msg(struct nss_gre_tunnel_msg *ngm)
 {
 	struct nss_gre_tunnel_configure *ngcm __maybe_unused = &ngm->msg.configure;
-	nss_trace("%p: NSS GRE Tunnel configure message \n"
+	nss_trace("%px: NSS GRE Tunnel configure message \n"
 		"Meta Header Version: %d\n"
 		"GRE Mode: %x\n"
 		"IP Type: %x\n"
@@ -51,7 +51,7 @@ static void nss_gre_tunnel_log_configure
 		"Encryption Crypto Index: %d\n"
 		"Decryption Crypto Index: %d\n"
 		"Word0 header: %d\n"
-		"Initialization Vector: %p\n"
+		"Initialization Vector: %px\n"
 		"Sibling Interface Number: %d\n"
 		"TTL: %d\n"
 		"RPS: %d\n"
@@ -90,7 +90,7 @@ static void nss_gre_tunnel_log_configure
 static void nss_gre_tunnel_log_di_to_wlan_id_msg(struct nss_gre_tunnel_msg *ngm)
 {
 	struct nss_gre_tunnel_di_to_wlan_id *ngdm __maybe_unused = &ngm->msg.dtwi;
-	nss_trace("%p: NSS GRE Dynamic Interface to WLAN ID message: \n"
+	nss_trace("%px: NSS GRE Dynamic Interface to WLAN ID message: \n"
 		"Dynamic Interface Number: %d\n"
 		"WLAN ID: %x\n",
 		ngdm, ngdm->dynamic_interface_num,
@@ -121,7 +121,7 @@ static void nss_gre_tunnel_log_verbose(s
 		break;
 
 	default:
-		nss_trace("%p: Invalid message type\n", ngm);
+		nss_trace("%px: Invalid message type\n", ngm);
 		break;
 	}
 }
@@ -133,11 +133,11 @@ static void nss_gre_tunnel_log_verbose(s
 void nss_gre_tunnel_log_tx_msg(struct nss_gre_tunnel_msg *ngm)
 {
 	if (ngm->cm.type >= NSS_GRE_TUNNEL_MSG_MAX) {
-		nss_warning("%p: Invalid message type\n", ngm);
+		nss_warning("%px: Invalid message type\n", ngm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", ngm, ngm->cm.type, nss_gre_tunnel_log_message_types_str[ngm->cm.type]);
+	nss_info("%px: type[%d]:%s\n", ngm, ngm->cm.type, nss_gre_tunnel_log_message_types_str[ngm->cm.type]);
 	nss_gre_tunnel_log_verbose(ngm);
 }
 
@@ -148,18 +148,18 @@ void nss_gre_tunnel_log_tx_msg(struct ns
 void nss_gre_tunnel_log_rx_msg(struct nss_gre_tunnel_msg *ngm)
 {
 	if (ngm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", ngm);
+		nss_warning("%px: Invalid response\n", ngm);
 		return;
 	}
 
 	if (ngm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (ngm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", ngm, ngm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", ngm, ngm->cm.type,
 			nss_gre_tunnel_log_message_types_str[ngm->cm.type],
 			ngm->cm.response, nss_cmn_response_str[ngm->cm.response]);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s\n",
 		ngm, ngm->cm.type, nss_gre_tunnel_log_message_types_str[ngm->cm.type],
 		ngm->cm.response, nss_cmn_response_str[ngm->cm.response]);
 
--- a/nss_gre_tunnel_stats.c
+++ b/nss_gre_tunnel_stats.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2017, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -76,7 +76,7 @@ void nss_gre_tunnel_stats_session_sync(s
 
 	if (!s) {
 		spin_unlock_bh(&nss_gre_tunnel_stats_session_debug_lock);
-		nss_warning("%p: Session not found: %u", nss_ctx, if_num);
+		nss_warning("%px: Session not found: %u", nss_ctx, if_num);
 		return;
 	}
 
@@ -247,4 +247,3 @@ void nss_gre_tunnel_stats_dentry_create(
 {
 	nss_stats_create_dentry("gre_tunnel", &nss_gre_tunnel_stats_ops);
 }
-
--- a/nss_hal/fsm9010/nss_hal_pvt.c
+++ b/nss_hal/fsm9010/nss_hal_pvt.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2015-2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2015-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -130,12 +130,12 @@ static struct nss_platform_data *__nss_h
 	nss_ctx->id = npd->id;
 
 	if (of_address_to_resource(np, 0, &res_nphys) != 0) {
-		nss_info_always("%p: nss%d: of_address_to_resource() fail for nphys\n", nss_ctx, nss_ctx->id);
+		nss_info_always("%px: nss%d: of_address_to_resource() fail for nphys\n", nss_ctx, nss_ctx->id);
 		goto out;
 	}
 
 	if (of_address_to_resource(np, 1, &res_vphys) != 0) {
-		nss_info_always("%p: nss%d: of_address_to_resource() fail for vphys\n", nss_ctx, nss_ctx->id);
+		nss_info_always("%px: nss%d: of_address_to_resource() fail for vphys\n", nss_ctx, nss_ctx->id);
 		goto out;
 	}
 
@@ -147,13 +147,13 @@ static struct nss_platform_data *__nss_h
 
 	npd->nmap = ioremap(npd->nphys, resource_size(&res_nphys));
 	if (!npd->nmap) {
-		nss_info_always("%p: nss%d: ioremap() fail for nphys\n", nss_ctx, nss_ctx->id);
+		nss_info_always("%px: nss%d: ioremap() fail for nphys\n", nss_ctx, nss_ctx->id);
 		goto out;
 	}
 
 	npd->vmap = ioremap_cache(npd->vphys, resource_size(&res_vphys));
 	if (!npd->vmap) {
-		nss_info_always("%p: nss%d: ioremap() fail for vphys\n", nss_ctx, nss_ctx->id);
+		nss_info_always("%px: nss%d: ioremap() fail for vphys\n", nss_ctx, nss_ctx->id);
 		goto out;
 	}
 
@@ -163,7 +163,7 @@ static struct nss_platform_data *__nss_h
 	for (i = 0 ; i < npd->num_irq; i++) {
 		npd->irq[i] = irq_of_parse_and_map(np, i);
 		if (!npd->irq[i]) {
-			nss_info_always("%p: nss%d: irq_of_parse_and_map() fail for irq %d\n", nss_ctx, nss_ctx->id, i);
+			nss_info_always("%px: nss%d: irq_of_parse_and_map() fail for irq %d\n", nss_ctx, nss_ctx->id, i);
 			goto out;
 		}
 	}
@@ -285,7 +285,7 @@ static int __nss_hal_request_irq(struct
 		err = request_irq(npd->irq[irq_num], nss_hal_handle_irq, 0, "nss", int_ctx);
 	}
 	if (err) {
-		nss_warning("%p: IRQ%d request failed", nss_ctx, npd->irq[irq_num]);
+		nss_warning("%px: IRQ%d request failed", nss_ctx, npd->irq[irq_num]);
 		return err;
 	}
 
@@ -305,7 +305,7 @@ void __nss_hal_init_imem(struct nss_ctx_
 	mem_ctx->imem_end = mem_ctx->imem_head + NSS_IMEM_SIZE;
 	mem_ctx->imem_tail = mem_ctx->imem_head;
 
-	nss_info("%p: IMEM init: head: 0x%x end: 0x%x tail: 0x%x\n", nss_ctx,
+	nss_info("%px: IMEM init: head: 0x%x end: 0x%x tail: 0x%x\n", nss_ctx,
 			mem_ctx->imem_head, mem_ctx->imem_end, mem_ctx->imem_tail);
 }
 
--- a/nss_hal/ipq60xx/nss_hal_pvt.c
+++ b/nss_hal/ipq60xx/nss_hal_pvt.c
@@ -192,12 +192,12 @@ static struct nss_platform_data *__nss_h
 	nss_ctx->id = npd->id;
 
 	if (of_address_to_resource(np, 0, &res_nphys) != 0) {
-		nss_info_always("%p: nss%d: of_address_to_resource() fail for nphys\n", nss_ctx, nss_ctx->id);
+		nss_info_always("%px: nss%d: of_address_to_resource() fail for nphys\n", nss_ctx, nss_ctx->id);
 		goto out;
 	}
 
 	if (of_address_to_resource(np, 1, &res_qgic_phys) != 0) {
-		nss_info_always("%p: nss%d: of_address_to_resource() fail for qgic_phys\n", nss_ctx, nss_ctx->id);
+		nss_info_always("%px: nss%d: of_address_to_resource() fail for qgic_phys\n", nss_ctx, nss_ctx->id);
 		goto out;
 	}
 
@@ -209,13 +209,13 @@ static struct nss_platform_data *__nss_h
 
 	npd->nmap = ioremap(npd->nphys, resource_size(&res_nphys));
 	if (!npd->nmap) {
-		nss_info_always("%p: nss%d: ioremap() fail for nphys\n", nss_ctx, nss_ctx->id);
+		nss_info_always("%px: nss%d: ioremap() fail for nphys\n", nss_ctx, nss_ctx->id);
 		goto out;
 	}
 
 	npd->qgic_map = ioremap(npd->qgic_phys, resource_size(&res_qgic_phys));
 	if (!npd->qgic_map) {
-		nss_info_always("%p: nss%d: ioremap() fail for qgic map\n", nss_ctx, nss_ctx->id);
+		nss_info_always("%px: nss%d: ioremap() fail for qgic map\n", nss_ctx, nss_ctx->id);
 		goto out;
 	}
 
@@ -227,7 +227,7 @@ static struct nss_platform_data *__nss_h
 	for (i = 0 ; i < npd->num_irq; i++) {
 		npd->irq[i] = irq_of_parse_and_map(np, i);
 		if (!npd->irq[i]) {
-			nss_info_always("%p: nss%d: irq_of_parse_and_map() fail for irq %d\n", nss_ctx, nss_ctx->id, i);
+			nss_info_always("%px: nss%d: irq_of_parse_and_map() fail for irq %d\n", nss_ctx, nss_ctx->id, i);
 			goto out;
 		}
 	}
@@ -261,21 +261,21 @@ static int nss_hal_clock_set_and_enable(
 
 	nss_clk = devm_clk_get(dev, id);
 	if (IS_ERR(nss_clk)) {
-		pr_err("%p: cannot get clock: %s\n", dev, id);
+		pr_err("%px: cannot get clock: %s\n", dev, id);
 		return -EFAULT;
 	}
 
 	if (rate) {
 		err = clk_set_rate(nss_clk, rate);
 		if (err) {
-			pr_err("%p: cannot set %s freq\n", dev, id);
+			pr_err("%px: cannot set %s freq\n", dev, id);
 			return -EFAULT;
 		}
 	}
 
 	err = clk_prepare_enable(nss_clk);
 	if (err) {
-		pr_err("%p: cannot enable clock: %s\n", dev, id);
+		pr_err("%px: cannot enable clock: %s\n", dev, id);
 		return -EFAULT;
 	}
 
@@ -313,7 +313,6 @@ static int __nss_hal_core_reset(struct p
 	value &= ~NSS_CORE_GCC_RESET_2;
 	nss_write_32(nss_misc_reset, 0x0, value);
 
-
 	/*
 	 * Program address configuration
 	 */
@@ -416,18 +415,18 @@ static int __nss_hal_common_reset(struct
 	 */
 	cmn = of_find_node_by_name(NULL, "nss-common");
 	if (!cmn) {
-		pr_err("%p: Unable to find nss-common node\n", nss_dev);
+		pr_err("%px: Unable to find nss-common node\n", nss_dev);
 		return -EFAULT;
 	}
 
 	if (of_address_to_resource(cmn, 0, &res_nss_misc_reset) != 0) {
-		pr_err("%p: of_address_to_resource() return error for nss_misc_reset\n", nss_dev);
+		pr_err("%px: of_address_to_resource() return error for nss_misc_reset\n", nss_dev);
 		of_node_put(cmn);
 		return -EFAULT;
 	}
 
 	if (of_address_to_resource(cmn, 1, &res_nss_misc_reset_flag) != 0) {
-		pr_err("%p: of_address_to_resource() return error for nss_misc_reset_flag\n", nss_dev);
+		pr_err("%px: of_address_to_resource() return error for nss_misc_reset_flag\n", nss_dev);
 		of_node_put(cmn);
 		return -EFAULT;
 	}
@@ -436,13 +435,13 @@ static int __nss_hal_common_reset(struct
 
 	nss_misc_reset = ioremap(res_nss_misc_reset.start, resource_size(&res_nss_misc_reset));
 	if (!nss_misc_reset) {
-		pr_err("%p: ioremap fail for nss_misc_reset\n", nss_dev);
+		pr_err("%px: ioremap fail for nss_misc_reset\n", nss_dev);
 		return -EFAULT;
 	}
 
 	nss_misc_reset_flag = ioremap(res_nss_misc_reset_flag.start, resource_size(&res_nss_misc_reset_flag));
 	if (!nss_misc_reset_flag) {
-		pr_err("%p: ioremap fail for nss_misc_reset_flag\n", nss_dev);
+		pr_err("%px: ioremap fail for nss_misc_reset_flag\n", nss_dev);
 		return -EFAULT;
 	}
 
@@ -706,7 +705,7 @@ bool __nss_hal_init_utcm_shared(struct n
 	 * Check meminfo utcm_shared map magic
 	 */
 	if ((uint16_t)utcm_shared_map_magic != NSS_MEMINFO_RESERVE_AREA_UTCM_SHARED_MAP_MAGIC) {
-		nss_info_always("%p: failed to verify UTCM_SHARED map magic\n", nss_ctx);
+		nss_info_always("%px: failed to verify UTCM_SHARED map magic\n", nss_ctx);
 		return false;
 	}
 
@@ -714,7 +713,7 @@ bool __nss_hal_init_utcm_shared(struct n
 	mem_ctx->utcm_shared_end = mem_ctx->utcm_shared_head + utcm_shared_size;
 	mem_ctx->utcm_shared_tail = mem_ctx->utcm_shared_head;
 
-	nss_info("%p: UTCM_SHARED init: head: 0x%x end: 0x%x tail: 0x%x\n", nss_ctx,
+	nss_info("%px: UTCM_SHARED init: head: 0x%x end: 0x%x tail: 0x%x\n", nss_ctx,
 			mem_ctx->utcm_shared_head, mem_ctx->utcm_shared_end, mem_ctx->utcm_shared_tail);
 	return true;
 }
--- a/nss_hal/ipq806x/nss_hal_pvt.c
+++ b/nss_hal/ipq806x/nss_hal_pvt.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2013, 2015-2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2013, 2015-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -443,12 +443,12 @@ static struct nss_platform_data *__nss_h
 	nss_ctx->id = npd->id;
 
 	if (of_address_to_resource(np, 0, &res_nphys) != 0) {
-		nss_info_always("%p: nss%d: of_address_to_resource() fail for nphys\n", nss_ctx, nss_ctx->id);
+		nss_info_always("%px: nss%d: of_address_to_resource() fail for nphys\n", nss_ctx, nss_ctx->id);
 		goto out;
 	}
 
 	if (of_address_to_resource(np, 1, &res_vphys) != 0) {
-		nss_info_always("%p: nss%d: of_address_to_resource() fail for vphys\n", nss_ctx, nss_ctx->id);
+		nss_info_always("%px: nss%d: of_address_to_resource() fail for vphys\n", nss_ctx, nss_ctx->id);
 		goto out;
 	}
 
@@ -460,13 +460,13 @@ static struct nss_platform_data *__nss_h
 
 	npd->nmap = ioremap(npd->nphys, resource_size(&res_nphys));
 	if (!npd->nmap) {
-		nss_info_always("%p: nss%d: ioremap() fail for nphys\n", nss_ctx, nss_ctx->id);
+		nss_info_always("%px: nss%d: ioremap() fail for nphys\n", nss_ctx, nss_ctx->id);
 		goto out;
 	}
 
 	npd->vmap = ioremap_cache(npd->vphys, resource_size(&res_vphys));
 	if (!npd->vmap) {
-		nss_info_always("%p: nss%d: ioremap() fail for vphys\n", nss_ctx, nss_ctx->id);
+		nss_info_always("%px: nss%d: ioremap() fail for vphys\n", nss_ctx, nss_ctx->id);
 		goto out;
 	}
 
@@ -485,7 +485,7 @@ static struct nss_platform_data *__nss_h
 	for (i = 0 ; i < npd->num_irq; i++) {
 		npd->irq[i] = irq_of_parse_and_map(np, i);
 		if (!npd->irq[i]) {
-			nss_info_always("%p: nss%d: irq_of_parse_and_map() fail for irq %d\n", nss_ctx, nss_ctx->id, i);
+			nss_info_always("%px: nss%d: irq_of_parse_and_map() fail for irq %d\n", nss_ctx, nss_ctx->id, i);
 			goto out;
 		}
 	}
@@ -523,7 +523,7 @@ static int __nss_hal_core_reset(struct p
 	 */
 	rstctl = devm_reset_control_get(&nss_dev->dev, "clkrst-clamp");
 	if (IS_ERR(rstctl)) {
-		nss_info_always("%p: Deassert UBI32 core%d reset clamp failed", nss_dev, nss_dev->id);
+		nss_info_always("%px: Deassert UBI32 core%d reset clamp failed", nss_dev, nss_dev->id);
 		return -EFAULT;
 	}
 	reset_control_deassert(rstctl);
@@ -533,7 +533,7 @@ static int __nss_hal_core_reset(struct p
 	 */
 	rstctl = devm_reset_control_get(&nss_dev->dev, "clamp");
 	if (IS_ERR(rstctl)) {
-		nss_info_always("%p: Deassert UBI32 core%d clamp failed", nss_dev, nss_dev->id);
+		nss_info_always("%px: Deassert UBI32 core%d clamp failed", nss_dev, nss_dev->id);
 		return -EFAULT;
 	}
 	reset_control_deassert(rstctl);
@@ -543,7 +543,7 @@ static int __nss_hal_core_reset(struct p
 	 */
 	rstctl = devm_reset_control_get(&nss_dev->dev, "ahb");
 	if (IS_ERR(rstctl)) {
-		nss_info_always("%p: Deassert AHB core%d reset failed", nss_dev, nss_dev->id);
+		nss_info_always("%px: Deassert AHB core%d reset failed", nss_dev, nss_dev->id);
 		return -EFAULT;
 	}
 	reset_control_deassert(rstctl);
@@ -553,7 +553,7 @@ static int __nss_hal_core_reset(struct p
 	 */
 	rstctl = devm_reset_control_get(&nss_dev->dev, "axi");
 	if (IS_ERR(rstctl)) {
-		nss_info_always("%p: Deassert core%d AXI reset failed", nss_dev, nss_dev->id);
+		nss_info_always("%px: Deassert core%d AXI reset failed", nss_dev, nss_dev->id);
 		return -EFAULT;
 	}
 	reset_control_deassert(rstctl);
@@ -699,12 +699,12 @@ static int __nss_hal_common_reset(struct
 	 */
 	cmn = of_find_node_by_name(NULL, "nss-common");
 	if (!cmn) {
-		pr_err("%p: Unable to find nss-common node\n", nss_dev);
+		pr_err("%px: Unable to find nss-common node\n", nss_dev);
 		return -EFAULT;
 	}
 
 	if (of_address_to_resource(cmn, 0, &res_nss_fpb_base) != 0) {
-		pr_err("%p: of_address_to_resource() return error for nss_fpb_base\n", nss_dev);
+		pr_err("%px: of_address_to_resource() return error for nss_fpb_base\n", nss_dev);
 		of_node_put(cmn);
 		return -EFAULT;
 	}
@@ -712,7 +712,7 @@ static int __nss_hal_common_reset(struct
 
 	fpb_base = ioremap(res_nss_fpb_base.start, resource_size(&res_nss_fpb_base));
 	if (!fpb_base) {
-		pr_err("%p: ioremap fail for nss_fpb_base\n", nss_dev);
+		pr_err("%px: ioremap fail for nss_fpb_base\n", nss_dev);
 		return -EFAULT;
 	}
 
@@ -726,31 +726,31 @@ static int __nss_hal_common_reset(struct
 	 */
 	nss_tcm_src = clk_get(&nss_dev->dev, NSS_TCM_SRC_CLK);
 	if (IS_ERR(nss_tcm_src)) {
-		pr_err("%p: cannot get clock: %s\n", nss_dev, NSS_TCM_SRC_CLK);
+		pr_err("%px: cannot get clock: %s\n", nss_dev, NSS_TCM_SRC_CLK);
 		return -EFAULT;
 	}
 
 	err = clk_set_rate(nss_tcm_src, NSSTCM_FREQ);
 	if (err) {
-		pr_err("%p: cannot set NSSTCM freq\n", nss_dev);
+		pr_err("%px: cannot set NSSTCM freq\n", nss_dev);
 		return -EFAULT;
 	}
 
 	err = clk_prepare_enable(nss_tcm_src);
 	if (err) {
-		pr_err("%p: cannot enable NSSTCM clock source\n", nss_dev);
+		pr_err("%px: cannot enable NSSTCM clock source\n", nss_dev);
 		return -EFAULT;
 	}
 
 	nss_tcm_clk = clk_get(&nss_dev->dev, NSS_TCM_CLK);
 	if (IS_ERR(nss_tcm_clk)) {
-		pr_err("%p: cannot get clock: %s\n", nss_dev, NSS_TCM_CLK);
+		pr_err("%px: cannot get clock: %s\n", nss_dev, NSS_TCM_CLK);
 		return -EFAULT;
 	}
 
 	err = clk_prepare_enable(nss_tcm_clk);
 	if (err) {
-		pr_err("%p: cannot enable NSSTCM clock\n", nss_dev);
+		pr_err("%px: cannot enable NSSTCM clock\n", nss_dev);
 		return -EFAULT;
 	}
 
@@ -759,24 +759,24 @@ static int __nss_hal_common_reset(struct
 	 */
 	nss_fab0_clk = clk_get(&nss_dev->dev, NSS_FABRIC0_CLK);
 	if (IS_ERR(nss_fab0_clk)) {
-		pr_err("%p: cannot get clock: %s\n", nss_dev, NSS_FABRIC0_CLK);
+		pr_err("%px: cannot get clock: %s\n", nss_dev, NSS_FABRIC0_CLK);
 		nss_fab0_clk = NULL;
 	} else {
 		err = clk_prepare_enable(nss_fab0_clk);
 		if (err) {
-			pr_err("%p: cannot enable clock: %s\n", nss_dev, NSS_FABRIC0_CLK);
+			pr_err("%px: cannot enable clock: %s\n", nss_dev, NSS_FABRIC0_CLK);
 			return -EFAULT;
 		}
 	}
 
 	nss_fab1_clk = clk_get(&nss_dev->dev, NSS_FABRIC1_CLK);
 	if (IS_ERR(nss_fab1_clk)) {
-		pr_err("%p: cannot get clock: %s\n", nss_dev, NSS_FABRIC1_CLK);
+		pr_err("%px: cannot get clock: %s\n", nss_dev, NSS_FABRIC1_CLK);
 		nss_fab1_clk = NULL;
 	} else {
 		err = clk_prepare_enable(nss_fab1_clk);
 		if (err) {
-			pr_err("%p: cannot enable clock: %s\n", nss_dev, NSS_FABRIC1_CLK);
+			pr_err("%px: cannot enable clock: %s\n", nss_dev, NSS_FABRIC1_CLK);
 			return -EFAULT;
 		}
 	}
@@ -969,7 +969,7 @@ static int __nss_hal_clock_configure(str
 	nss_core0_clk = clk_get(&nss_dev->dev, NSS_CORE_CLK);
 	if (IS_ERR(nss_core0_clk)) {
 		err = PTR_ERR(nss_core0_clk);
-		nss_info_always("%p: Regulator %s get failed, err=%d\n", nss_ctx, dev_name(&nss_dev->dev), err);
+		nss_info_always("%px: Regulator %s get failed, err=%d\n", nss_ctx, dev_name(&nss_dev->dev), err);
 		return err;
 	}
 
@@ -1107,13 +1107,13 @@ clk_complete:
 	 */
 	err = clk_set_rate(nss_core0_clk, nss_runtime_samples.freq_scale[NSS_FREQ_MID_SCALE].frequency);
 	if (err) {
-		nss_info_always("%p: cannot set nss core0 clock\n", nss_ctx);
+		nss_info_always("%px: cannot set nss core0 clock\n", nss_ctx);
 		return -EFAULT;
 	}
 
 	err = clk_prepare_enable(nss_core0_clk);
 	if (err) {
-		nss_info_always("%p: cannot enable nss core0 clock\n", nss_ctx);
+		nss_info_always("%px: cannot enable nss core0 clock\n", nss_ctx);
 		return -EFAULT;
 	}
 
@@ -1177,7 +1177,7 @@ static int __nss_hal_request_irq(struct
 		err = request_irq(npd->irq[irq_num], nss_hal_handle_irq, 0, "nss", int_ctx);
 	}
 	if (err) {
-		nss_info_always("%p: IRQ%d request failed", nss_ctx, npd->irq[irq_num]);
+		nss_info_always("%px: IRQ%d request failed", nss_ctx, npd->irq[irq_num]);
 		return err;
 	}
 
@@ -1198,7 +1198,7 @@ void __nss_hal_init_imem(struct nss_ctx_
 	mem_ctx->imem_end = mem_ctx->imem_head + NSS_IMEM_SIZE;
 	mem_ctx->imem_tail = mem_ctx->imem_head;
 
-	nss_info("%p: IMEM init: head: 0x%x end: 0x%x tail: 0x%x\n", nss_ctx,
+	nss_info("%px: IMEM init: head: 0x%x end: 0x%x tail: 0x%x\n", nss_ctx,
 			mem_ctx->imem_head, mem_ctx->imem_end, mem_ctx->imem_tail);
 }
 
--- a/nss_hal/ipq807x/nss_hal_pvt.c
+++ b/nss_hal/ipq807x/nss_hal_pvt.c
@@ -213,17 +213,17 @@ static struct nss_platform_data *__nss_h
 	nss_ctx->id = npd->id;
 
 	if (of_address_to_resource(np, 0, &res_nphys) != 0) {
-		nss_info_always("%p: nss%d: of_address_to_resource() fail for nphys\n", nss_ctx, nss_ctx->id);
+		nss_info_always("%px: nss%d: of_address_to_resource() fail for nphys\n", nss_ctx, nss_ctx->id);
 		goto out;
 	}
 
 	if (of_address_to_resource(np, 1, &res_vphys) != 0) {
-		nss_info_always("%p: nss%d: of_address_to_resource() fail for vphys\n", nss_ctx, nss_ctx->id);
+		nss_info_always("%px: nss%d: of_address_to_resource() fail for vphys\n", nss_ctx, nss_ctx->id);
 		goto out;
 	}
 
 	if (of_address_to_resource(np, 2, &res_qgic_phys) != 0) {
-		nss_info_always("%p: nss%d: of_address_to_resource() fail for qgic_phys\n", nss_ctx, nss_ctx->id);
+		nss_info_always("%px: nss%d: of_address_to_resource() fail for qgic_phys\n", nss_ctx, nss_ctx->id);
 		goto out;
 	}
 
@@ -236,19 +236,19 @@ static struct nss_platform_data *__nss_h
 
 	npd->nmap = ioremap(npd->nphys, resource_size(&res_nphys));
 	if (!npd->nmap) {
-		nss_info_always("%p: nss%d: ioremap() fail for nphys\n", nss_ctx, nss_ctx->id);
+		nss_info_always("%px: nss%d: ioremap() fail for nphys\n", nss_ctx, nss_ctx->id);
 		goto out;
 	}
 
 	npd->vmap = ioremap_cache(npd->vphys, resource_size(&res_vphys));
 	if (!npd->vmap) {
-		nss_info_always("%p: nss%d: ioremap() fail for vphys\n", nss_ctx, nss_ctx->id);
+		nss_info_always("%px: nss%d: ioremap() fail for vphys\n", nss_ctx, nss_ctx->id);
 		goto out;
 	}
 
 	npd->qgic_map = ioremap(npd->qgic_phys, resource_size(&res_qgic_phys));
 	if (!npd->qgic_map) {
-		nss_info_always("%p: nss%d: ioremap() fail for qgic map\n", nss_ctx, nss_ctx->id);
+		nss_info_always("%px: nss%d: ioremap() fail for qgic map\n", nss_ctx, nss_ctx->id);
 		goto out;
 	}
 
@@ -267,7 +267,7 @@ static struct nss_platform_data *__nss_h
 	for (i = 0 ; i < npd->num_irq; i++) {
 		npd->irq[i] = irq_of_parse_and_map(np, i);
 		if (!npd->irq[i]) {
-			nss_info_always("%p: nss%d: irq_of_parse_and_map() fail for irq %d\n", nss_ctx, nss_ctx->id, i);
+			nss_info_always("%px: nss%d: irq_of_parse_and_map() fail for irq %d\n", nss_ctx, nss_ctx->id, i);
 			goto out;
 		}
 	}
@@ -368,21 +368,21 @@ static int nss_hal_clock_set_and_enable(
 
 	nss_clk = devm_clk_get(dev, id);
 	if (IS_ERR(nss_clk)) {
-		pr_err("%p: cannot get clock: %s\n", dev, id);
+		pr_err("%px: cannot get clock: %s\n", dev, id);
 		return -EFAULT;
 	}
 
 	if (rate) {
 		err = clk_set_rate(nss_clk, rate);
 		if (err) {
-			pr_err("%p: cannot set %s freq\n", dev, id);
+			pr_err("%px: cannot set %s freq\n", dev, id);
 			return -EFAULT;
 		}
 	}
 
 	err = clk_prepare_enable(nss_clk);
 	if (err) {
-		pr_err("%p: cannot enable clock: %s\n", dev, id);
+		pr_err("%px: cannot enable clock: %s\n", dev, id);
 		return -EFAULT;
 	}
 
@@ -455,12 +455,12 @@ static int __nss_hal_common_reset(struct
 	 */
 	cmn = of_find_node_by_name(NULL, "nss-common");
 	if (!cmn) {
-		pr_err("%p: Unable to find nss-common node\n", nss_dev);
+		pr_err("%px: Unable to find nss-common node\n", nss_dev);
 		return -EFAULT;
 	}
 
 	if (of_address_to_resource(cmn, 0, &res_nss_misc_reset) != 0) {
-		pr_err("%p: of_address_to_resource() return error for nss_misc_reset\n", nss_dev);
+		pr_err("%px: of_address_to_resource() return error for nss_misc_reset\n", nss_dev);
 		of_node_put(cmn);
 		return -EFAULT;
 	}
@@ -468,7 +468,7 @@ static int __nss_hal_common_reset(struct
 
 	nss_misc_reset = ioremap(res_nss_misc_reset.start, resource_size(&res_nss_misc_reset));
 	if (!nss_misc_reset) {
-		pr_err("%p: ioremap fail for nss_misc_reset\n", nss_dev);
+		pr_err("%px: ioremap fail for nss_misc_reset\n", nss_dev);
 		return -EFAULT;
 	}
 
@@ -504,7 +504,6 @@ static int __nss_hal_clock_configure(str
 		return -EFAULT;
 	}
 
-
 	/*
 	 * For IPQ807x, any rate above 1497 is Turbo Voltage
 	 * Temporary set the voltage to turbo till we start scaling frequenices.
@@ -735,7 +734,7 @@ void __nss_hal_init_imem(struct nss_ctx_
 	mem_ctx->imem_end = mem_ctx->imem_head + NSS_IMEM_SIZE;
 	mem_ctx->imem_tail = mem_ctx->imem_head;
 
-	nss_info("%p: IMEM init: head: 0x%x end: 0x%x tail: 0x%x\n", nss_ctx,
+	nss_info("%px: IMEM init: head: 0x%x end: 0x%x tail: 0x%x\n", nss_ctx,
 			mem_ctx->imem_head, mem_ctx->imem_end, mem_ctx->imem_tail);
 }
 
--- a/nss_hal/nss_hal.c
+++ b/nss_hal/nss_hal.c
@@ -61,7 +61,7 @@ int nss_hal_firmware_load(struct nss_ctx
 	} else if (nss_ctx->id == 1) {
 		rc = request_firmware(&nss_fw, NSS_AP1_IMAGE, &(nss_dev->dev));
 	} else {
-		nss_warning("%p: Invalid nss dev: %d\n", nss_ctx, nss_ctx->id);
+		nss_warning("%px: Invalid nss dev: %d\n", nss_ctx, nss_ctx->id);
 		return -EINVAL;
 	}
 
@@ -69,18 +69,18 @@ int nss_hal_firmware_load(struct nss_ctx
 	 *  Check if the file read is successful
 	 */
 	if (rc) {
-		nss_info_always("%p: request_firmware failed with err code: %d", nss_ctx, rc);
+		nss_info_always("%px: request_firmware failed with err code: %d", nss_ctx, rc);
 		return rc;
 	}
 
 	if (nss_fw->size < MIN_IMG_SIZE) {
-		nss_info_always("%p: nss firmware is truncated, size:%d", nss_ctx, (int)nss_fw->size);
+		nss_info_always("%px: nss firmware is truncated, size:%d", nss_ctx, (int)nss_fw->size);
 		return rc;
 	}
 
 	load_mem = ioremap(npd->load_addr, nss_fw->size);
 	if (!load_mem) {
-		nss_info_always("%p: ioremap failed: %x", nss_ctx, npd->load_addr);
+		nss_info_always("%px: ioremap failed: %x", nss_ctx, npd->load_addr);
 		release_firmware(nss_fw);
 		return rc;
 	}
@@ -180,7 +180,7 @@ static int nss_hal_register_irq(struct n
 	int_ctx->nss_ctx = nss_ctx;
 	err = nss_top->hal_ops->request_irq(nss_ctx, npd, irq_num);
 	if (err) {
-		nss_warning("%p: IRQ request for queue %d failed", nss_ctx, irq_num);
+		nss_warning("%px: IRQ request for queue %d failed", nss_ctx, irq_num);
 		return err;
 	}
 
@@ -240,27 +240,27 @@ int nss_hal_probe(struct platform_device
 	 */
 	nss_ctx->dev = &nss_dev->dev;
 
-	nss_info("%p: NSS_DEV_ID %s\n", nss_ctx, dev_name(&nss_dev->dev));
+	nss_info("%px: NSS_DEV_ID %s\n", nss_ctx, dev_name(&nss_dev->dev));
 
 	/*
 	 * Do firmware load from nss-drv if required
 	 */
 	err = nss_top->hal_ops->firmware_load(nss_ctx, nss_dev, npd);
 	if (err) {
-		nss_info_always("%p: firmware load from driver failed\n", nss_ctx);
+		nss_info_always("%px: firmware load from driver failed\n", nss_ctx);
 		goto err_init;
 	}
 
 	err = nss_top->hal_ops->clock_configure(nss_ctx, nss_dev, npd);
 	if (err) {
-		nss_info_always("%p: clock configure failed\n", nss_ctx);
+		nss_info_always("%px: clock configure failed\n", nss_ctx);
 		goto err_init;
 	}
 
 	/*
 	 * Get load address of NSS firmware
 	 */
-	nss_info("%p: Setting NSS%d Firmware load address to %x\n", nss_ctx, nss_ctx->id, npd->load_addr);
+	nss_info("%px: Setting NSS%d Firmware load address to %x\n", nss_ctx, nss_ctx->id, npd->load_addr);
 	nss_top->nss[nss_ctx->id].load = npd->load_addr;
 
 	/*
@@ -293,11 +293,11 @@ int nss_hal_probe(struct platform_device
 	 */
 	nss_ctx->vphys = npd->vphys;
 	nss_assert(nss_ctx->vphys);
-	nss_info("%d:ctx=%p, vphys=%x, vmap=%p, nphys=%x, nmap=%p", nss_ctx->id,
+	nss_info("%d:ctx=%px, vphys=%x, vmap=%px, nphys=%x, nmap=%px", nss_ctx->id,
 			nss_ctx, nss_ctx->vphys, nss_ctx->vmap, nss_ctx->nphys, nss_ctx->nmap);
 
 	if (!nss_meminfo_init(nss_ctx)) {
-		nss_info_always("%p: meminfo init failed\n", nss_ctx);
+		nss_info_always("%px: meminfo init failed\n", nss_ctx);
 		err = -EFAULT;
 		goto err_init;
 	}
@@ -321,7 +321,7 @@ int nss_hal_probe(struct platform_device
 	if (npd->tstamp_enabled == NSS_FEATURE_ENABLED) {
 		tstamp_ndev = nss_tstamp_register_netdev();
 		if (!tstamp_ndev) {
-			nss_warning("%p: Unable to register the TSTAMP net_device", nss_ctx);
+			nss_warning("%px: Unable to register the TSTAMP net_device", nss_ctx);
 			npd->tstamp_enabled = NSS_FEATURE_NOT_ENABLED;
 		}
 		nss_top->tstamp_handler_id = nss_dev->id;
@@ -415,6 +415,11 @@ int nss_hal_probe(struct platform_device
 		nss_top->crypto_enabled = 1;
 		nss_crypto_register_handler();
 #endif
+
+#if defined(NSS_HAL_IPQ807x_SUPPORT) || defined(NSS_HAL_IPQ60XX_SUPPORT)
+		nss_top->dma_handler_id = nss_dev->id;
+		nss_dma_register_handler();
+#endif
 	}
 #endif
 
@@ -563,7 +568,6 @@ int nss_hal_probe(struct platform_device
 		nss_wifi_mac_db_register_handler();
 	}
 
-
 #ifdef NSS_DRV_OAM_ENABLE
 	if (npd->oam_enabled == NSS_FEATURE_ENABLED) {
 		nss_top->oam_handler_id = nss_dev->id;
@@ -685,7 +689,7 @@ int nss_hal_probe(struct platform_device
 	spin_lock_init(&(nss_ctx->decongest_cb_lock));
 	nss_ctx->magic = NSS_CTX_MAGIC;
 
-	nss_info("%p: Reseting NSS core %d now", nss_ctx, nss_ctx->id);
+	nss_info("%px: Reseting NSS core %d now", nss_ctx, nss_ctx->id);
 
 	/*
 	 * Enable clocks and bring NSS core out of reset
@@ -716,7 +720,7 @@ int nss_hal_probe(struct platform_device
 		nss_hal_enable_interrupt(nss_ctx, nss_ctx->int_ctx[i].shift_factor, NSS_HAL_SUPPORTED_INTERRUPTS);
 	}
 
-	nss_info("%p: All resources initialized and nss core%d has been brought out of reset", nss_ctx, nss_dev->id);
+	nss_info("%px: All resources initialized and nss core%d has been brought out of reset", nss_ctx, nss_dev->id);
 	goto out;
 
 err_register_irq:
@@ -787,6 +791,6 @@ int nss_hal_remove(struct platform_devic
 		}
 	}
 
-	nss_info("%p: All resources freed for nss core%d", nss_ctx, nss_dev->id);
+	nss_info("%px: All resources freed for nss core%d", nss_ctx, nss_dev->id);
 	return 0;
 }
--- a/nss_if.c
+++ b/nss_if.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2016, 2018-2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2016, 2018-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -20,6 +20,74 @@
  */
 
 #include "nss_tx_rx_common.h"
+#include "nss_if_log.h"
+
+/*
+ * nss_if_pvt
+ *	NSS private structure to handle the completion of NSS -> HLOS messages.
+ */
+static struct nss_if_pvt {
+	struct semaphore sem;
+	struct completion complete;
+	int response;
+} nss_if;
+
+static bool nss_if_sem_init_done;
+
+/*
+ * nss_if_callback
+ *	Callback to handle the completion of NSS ->HLOS messages.
+ */
+static void nss_if_callback(void *app_data, struct nss_if_msg *nim)
+{
+	if (nim->cm.response != NSS_CMN_RESPONSE_ACK) {
+		nss_warning("nss_if Error response %d\n", nim->cm.response);
+		nss_if.response = NSS_TX_FAILURE;
+		complete(&nss_if.complete);
+		return;
+	}
+
+	nss_if.response = NSS_TX_SUCCESS;
+	complete(&nss_if.complete);
+}
+
+/*
+ * nss_if_msg_sync()
+ *	Send a message to an interface and wait for the response.
+ */
+nss_tx_status_t nss_if_msg_sync(struct nss_ctx_instance *nss_ctx, struct nss_if_msg *nim)
+{
+	nss_tx_status_t status;
+	int ret = 0;
+
+	if (!nss_if_sem_init_done) {
+		sema_init(&nss_if.sem, 1);
+		init_completion(&nss_if.complete);
+		nss_if_sem_init_done = 1;
+	}
+
+	down(&nss_if.sem);
+
+	status = nss_if_tx_msg(nss_ctx, nim);
+	if (status != NSS_TX_SUCCESS) {
+		nss_warning("%px: nss_if_msg failed\n", nss_ctx);
+		up(&nss_if.sem);
+		return status;
+	}
+
+	ret = wait_for_completion_timeout(&nss_if.complete, msecs_to_jiffies(NSS_IF_TX_TIMEOUT));
+
+	if (!ret) {
+		nss_warning("%px: nss_if tx failed due to timeout\n", nss_ctx);
+		nss_if.response = NSS_TX_FAILURE;
+	}
+
+	status = nss_if.response;
+	up(&nss_if.sem);
+
+	return status;
+}
+EXPORT_SYMBOL(nss_if_msg_sync);
 
 /*
  * nss_if_msg_handler()
@@ -35,18 +103,18 @@ void nss_if_msg_handler(struct nss_ctx_i
 	 * We only support base class messages with this interface
 	 */
 	if (ncm->type > NSS_IF_MAX_MSG_TYPES) {
-		nss_warning("%p: message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (!nss_is_dynamic_interface(ncm->interface) &&
 		!((ncm->interface >= NSS_PHYSICAL_IF_START) && (ncm->interface < NSS_VIRTUAL_IF_START))) {
-		nss_warning("%p: interface %d not in physical or dynamic if range\n", nss_ctx, ncm->interface);
+		nss_warning("%px: interface %d not in physical or dynamic if range\n", nss_ctx, ncm->interface);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_if_msg)) {
-		nss_warning("%p: message length too big: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: message length too big: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
@@ -56,6 +124,11 @@ void nss_if_msg_handler(struct nss_ctx_i
 	nss_core_log_msg_failures(nss_ctx, ncm);
 
 	/*
+	 * Trace messages.
+	 */
+	nss_if_log_rx_msg(nim);
+
+	/*
 	 * Do we have a callback?
 	 */
 	if (!ncm->cb) {
@@ -75,11 +148,11 @@ void nss_if_msg_handler(struct nss_ctx_i
  */
 nss_tx_status_t nss_if_tx_buf(struct nss_ctx_instance *nss_ctx, struct sk_buff *os_buf, uint32_t if_num)
 {
-	nss_trace("%p: If Tx packet, id:%d, data=%p", nss_ctx, if_num, os_buf->data);
+	nss_trace("%px: If Tx packet, id:%d, data=%px", nss_ctx, if_num, os_buf->data);
 
 	if (!nss_is_dynamic_interface(if_num) &&
 		!((if_num >= NSS_PHYSICAL_IF_START) && (if_num < NSS_VIRTUAL_IF_START))) {
-		nss_warning("%p: interface %d not in physical or dynamic if range\n", nss_ctx, if_num);
+		nss_warning("%px: interface %d not in physical or dynamic if range\n", nss_ctx, if_num);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
@@ -100,14 +173,28 @@ nss_tx_status_t nss_if_tx_msg(struct nss
 	/*
 	 * Sanity check the message
 	 */
-	if (ncm->type > NSS_IF_MAX_MSG_TYPES) {
-		nss_warning("%p: message type out of range: %d", nss_ctx, ncm->type);
+	if (ncm->type >= NSS_IF_MAX_MSG_TYPES) {
+		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
+	/*
+	 * Sanity check the message for valid interfaces.
+	 */
+	if (ncm->interface < NSS_PHYSICAL_IF_START ||
+		ncm->interface >= NSS_MAX_NET_INTERFACES ) {
+		nss_warning("%px: Tx request for invalid interface: %d", nss_ctx, ncm->interface);
+		return NSS_TX_FAILURE_BAD_PARAM;
+	}
+
+	/*
+	 * Trace messages.
+	 */
+	nss_if_log_tx_msg(nim);
+
 	dev = nss_ctx->subsys_dp_register[ncm->interface].ndev;
 	if (!dev) {
-		nss_warning("%p: Unregister interface %d: no context", nss_ctx, ncm->interface);
+		nss_warning("%px: Unregister interface %d: no context", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
@@ -134,6 +221,50 @@ void nss_if_unregister(uint32_t if_num)
 {
 }
 
+/*
+ * nss_if_reset_nexthop()
+ *	De-configures the nexthop for an interface
+ */
+nss_tx_status_t nss_if_reset_nexthop(struct nss_ctx_instance *nss_ctx, uint32_t if_num)
+{
+	struct nss_if_msg nim;
+
+	NSS_VERIFY_CTX_MAGIC(nss_ctx);
+
+	nss_trace("Resetting Nexthop. nss_ctx: %px ifnum: %u", nss_ctx, if_num);
+
+	nss_cmn_msg_init(&nim.cm, if_num, NSS_IF_RESET_NEXTHOP, 0, nss_if_callback, NULL);
+
+	return nss_if_msg_sync(nss_ctx, &nim);
+}
+EXPORT_SYMBOL(nss_if_reset_nexthop);
+
+/*
+ * nss_if_set_nexthop()
+ *	Configures the nexthop for an interface
+ */
+nss_tx_status_t nss_if_set_nexthop(struct nss_ctx_instance *nss_ctx, uint32_t if_num, uint32_t nexthop)
+{
+	struct nss_if_msg nim;
+
+	NSS_VERIFY_CTX_MAGIC(nss_ctx);
+
+	if (nexthop >= NSS_MAX_NET_INTERFACES) {
+		nss_warning("%px: Invalid nexthop interface number: %d", nss_ctx, nexthop);
+		return NSS_TX_FAILURE_BAD_PARAM;
+	}
+
+	nss_trace("%px: NSS If nexthop will be set to %d, id:%d\n", nss_ctx, nexthop, if_num);
+
+	nss_cmn_msg_init(&nim.cm, if_num, NSS_IF_SET_NEXTHOP,
+				sizeof(struct nss_if_set_nexthop), nss_if_callback, NULL);
+
+	nim.msg.set_nexthop.nexthop = nexthop;
+
+	return nss_if_msg_sync(nss_ctx, &nim);
+}
+EXPORT_SYMBOL(nss_if_set_nexthop);
+
 EXPORT_SYMBOL(nss_if_tx_msg);
 EXPORT_SYMBOL(nss_if_register);
 EXPORT_SYMBOL(nss_if_unregister);
--- /dev/null
+++ b/nss_if_log.c
@@ -0,0 +1,429 @@
+/*
+ **************************************************************************
+ * Copyright (c) 2020, The Linux Foundation. All rights reserved.
+
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ **************************************************************************
+ */
+
+/*
+ * nss_if_log.c
+ *	NSS Interface logger file.
+ */
+
+#include "nss_core.h"
+
+/*
+ * nss_if_log_message_types_str
+ *	NSS interface rule message strings
+ */
+static int8_t *nss_if_log_message_types_str[NSS_IF_MAX_MSG_TYPES] __maybe_unused = {
+	"NSS interface Open message",
+	"NSS interface close message",
+	"NSS interface link state notify message",
+	"NSS interface MTU change message",
+	"NSS interface MAC address set message",
+	"NSS interface stats message",
+	"NSS interface ishaper assign message",
+	"NSS interface bshaper assign message",
+	"NSS interface ishaper unassign message",
+	"NSS interface bshaper unassign message",
+	"NSS interface ishaper config message",
+	"NSS interface bshaper config message",
+	"NSS interface pause on off message",
+	"NSS interface VSI assign message",
+	"NSS interface VSI unassign message",
+	"NSS interface set next hop message",
+	"NSS interface set IGS node message",
+	"NSS interface clear IGS node message",
+	"NSS interface reset next hop message",
+};
+
+/*
+ * nss_if_log_error_response_types_str
+ *	Strings for error types for NSS interface messages
+ */
+static int8_t *nss_if_log_error_response_types_str[NSS_IF_ERROR_TYPE_MAX] __maybe_unused = {
+	"No Ishapers",
+	"No Bshapers",
+	"No Ishaper",
+	"No Bshaper",
+	"No Old Ishaper",
+	"No Old Bshaper",
+	"Ishaper config failed",
+	"Bshaper config failed",
+	"Unknown error",
+	"Interface open error",
+	"Interface invalid MTU error",
+	"Invalid MAC address error",
+	"VSI no match error",
+	"VSI reassign error",
+	"Invalid VSI error",
+	"Max error",
+};
+
+/*
+ * nss_if_log_rule_open()
+ *	Log NSS open interface message.
+ */
+static void nss_if_log_rule_open(struct nss_if_msg *nim)
+{
+	struct nss_if_open *niom __maybe_unused = &nim->msg.open;
+	nss_trace("%px: NSS open interface message \n"
+		"tx_desc_ring: %X\n"
+		"rx_desc_ring: %X\n"
+		"rx_forward_if: %u\n"
+		"alignment_mode: %u\n",
+		nim,
+		niom->tx_desc_ring,
+		niom->rx_desc_ring,
+		niom->rx_forward_if,
+		niom->alignment_mode);
+}
+
+/*
+ * nss_if_log_rule_close()
+ *	Log NSS close interface message.
+ */
+static void nss_if_log_rule_close(struct nss_if_msg *nim)
+{
+	nss_trace("%px: NSS close interface message \n", nim);
+}
+
+/*
+ * nss_if_log_rule_link_state_notify()
+ *	Log NSS interface link state notify message.
+ */
+static void nss_if_log_rule_link_state_notify(struct nss_if_msg *nim)
+{
+	struct nss_if_link_state_notify *nilstm __maybe_unused = &nim->msg.link_state_notify;
+	nss_trace("%px: NSS interface link state notify interface message \n"
+		"state: %u\n",
+		nim,
+		nilstm->state);
+}
+
+/*
+ * nss_if_log_rule_mtu_change()
+ *	Log NSS interface MTU change message.
+ */
+static void nss_if_log_rule_mtu_change(struct nss_if_msg *nim)
+{
+	struct nss_if_mtu_change *nimcm __maybe_unused = &nim->msg.mtu_change;
+	nss_trace("%px: NSS interface MTU change message \n"
+		"min_buf_size: %u\n",
+		nim,
+		nimcm->min_buf_size);
+}
+
+/*
+ * nss_if_log_rule_mac_addr_set()
+ *	Log NSS interface MAC address set message.
+ */
+static void nss_if_log_rule_mac_addr_set(struct nss_if_msg *nim)
+{
+	struct nss_if_mac_address_set *nimasm __maybe_unused = &nim->msg.mac_address_set;
+	nss_trace("%px: NSS interface MAC address set message \n"
+		"MAC address: %X:%X:%X:%X:%X:%X\n",
+		nim,
+		nimasm->mac_addr[0], nimasm->mac_addr[1], nimasm->mac_addr[2],
+		nimasm->mac_addr[3], nimasm->mac_addr[4], nimasm->mac_addr[5]);
+}
+
+/*
+ * nss_if_log_rule_stats()
+ *	Log NSS interface stats message.
+ */
+static void nss_if_log_rule_stats(struct nss_if_msg *nim)
+{
+	uint16_t i;
+	struct nss_cmn_node_stats *nism __maybe_unused = &nim->msg.stats;
+
+	nss_trace("%px: NSS interface stats message \n"
+		"rx_packets: %u\n"
+		"rx_bytes: %u\n"
+		"tx_packets: %u\n"
+		"tx_bytes: %u\n",
+		nim,
+		nism->rx_packets,
+		nism->rx_bytes,
+		nism->tx_packets,
+		nism->tx_bytes);
+
+	for(i=0; i < NSS_MAX_NUM_PRI; i++)
+	{
+		nss_trace("rx_dropped[%u]: %u\n", i, nism->rx_dropped[i]);
+	}
+}
+
+/*
+ * nss_if_log_rule_shaper_assign()
+ *	Log NSS interface shaper assignment message.
+ */
+static void nss_if_log_rule_shaper_assign(struct nss_if_msg *nim)
+{
+	struct nss_if_shaper_assign *shaper_assign_msg __maybe_unused = &nim->msg.shaper_assign;
+	nss_trace("%px: NSS interface shaper assign message \n"
+		"shaper_id: %u\n"
+		"new_shaper_id: %u\n",
+		nim,
+		shaper_assign_msg->shaper_id,
+		shaper_assign_msg->new_shaper_id);
+}
+
+/*
+ * nss_if_log_rule_shaper_unassign()
+ *	Log NSS interface shaper unassignment message.
+ */
+static void nss_if_log_rule_shaper_unassign(struct nss_if_msg *nim)
+{
+	struct nss_if_shaper_unassign *shaper_unassign_msg __maybe_unused = &nim->msg.shaper_unassign;
+	nss_trace("%px: NSS interface shaper unassign message \n"
+		"shaper_id: %u\n",
+		nim,
+		shaper_unassign_msg->shaper_id);
+}
+
+/*
+ * nss_if_log_rule_shaper_config()
+ *	Log NSS interface shaper configuration message.
+ */
+static void nss_if_log_rule_shaper_config(struct nss_if_msg *nim)
+{
+	struct nss_if_shaper_configure *shaper_configure_msg __maybe_unused = &nim->msg.shaper_configure;
+	nss_trace("%px: NSS interface shaper configuration message \n"
+		"request_type: %u\n"
+		"response_type: %u\n",
+		nim,
+		shaper_configure_msg->config.request_type,
+		shaper_configure_msg->config.response_type);
+}
+
+/*
+ * nss_if_log_rule_pause_on_off()
+ *	Log NSS interface pause on off message.
+ */
+static void nss_if_log_rule_pause_on_off(struct nss_if_msg *nim)
+{
+	struct nss_if_pause_on_off *pause_on_off_msg __maybe_unused = &nim->msg.pause_on_off;
+	nss_trace("%px: NSS interface pause ON/OFF message \n"
+		"pause_on: %u\n",
+		nim,
+		pause_on_off_msg->pause_on);
+}
+
+/*
+ * nss_if_log_rule_vsi_assign()
+ *	Log NSS interface VSI assignment message.
+ */
+static void nss_if_log_rule_vsi_assign(struct nss_if_msg *nim)
+{
+	struct nss_if_vsi_assign *vsi_assign_msg __maybe_unused = &nim->msg.vsi_assign;
+	nss_trace("%px: NSS interface VSI assignment message \n"
+		"VSI: %u\n",
+		nim,
+		vsi_assign_msg->vsi);
+}
+
+/*
+ * nss_if_log_rule_vsi_unassign()
+ *	Log NSS interface VSI unassignment message.
+ */
+static void nss_if_log_rule_vsi_unassign(struct nss_if_msg *nim)
+{
+	struct nss_if_vsi_unassign *vsi_unassign_msg __maybe_unused = &nim->msg.vsi_unassign;
+	nss_trace("%px: NSS interface VSI unassignment message \n"
+		"VSI: %u\n",
+		nim,
+		vsi_unassign_msg->vsi);
+}
+
+/*
+ * nss_if_log_rule_set_nexthop()
+ *	Log NSS interface set nexthop message.
+ */
+static void nss_if_log_rule_set_nexthop(struct nss_if_msg *nim)
+{
+	struct nss_if_set_nexthop *nisn __maybe_unused = &nim->msg.set_nexthop;
+	nss_trace("%px: NSS interface set nethop message \n"
+		"Nexthop: %u\n",
+		nim,
+		nisn->nexthop);
+}
+
+/*
+ * nss_if_log_rule_set_igs_node()
+ *	Log NSS interface set IGS node message.
+ */
+static void nss_if_log_rule_set_igs_node(struct nss_if_msg *nim)
+{
+	struct nss_if_igs_config *igs_config_msg __maybe_unused = &nim->msg.config_igs;
+	nss_trace("%px: NSS interface set IGS node message \n"
+		"igs_num: %d\n",
+		nim,
+		igs_config_msg->igs_num);
+}
+
+/*
+ * nss_if_log_rule_clear_igs_node()
+ *	Log NSS interface clear IGS node message.
+ */
+static void nss_if_log_rule_clear_igs_node(struct nss_if_msg *nim)
+{
+	struct nss_if_igs_config *igs_config_msg __maybe_unused = &nim->msg.config_igs;
+	nss_trace("%px: NSS interface clear IGS node message \n"
+		"igs_num: %d\n",
+		nim,
+		igs_config_msg->igs_num);
+}
+
+/*
+ * nss_if_log_rule_reset_nexthop()
+ *	Log NSS interface reset nexthop message.
+ */
+static void nss_if_log_rule_reset_nexthop(struct nss_if_msg *nim)
+{
+	nss_trace("%px: NSS interface reset nexthop message \n", nim);
+}
+
+/*
+ * nss_if_log_verbose()
+ *	Log message contents.
+ */
+static void nss_if_log_verbose(struct nss_if_msg *nim)
+{
+	nss_trace("NSS interface number: %u\n", nim->cm.interface);
+
+	switch (nim->cm.type) {
+	case NSS_IF_OPEN:
+		nss_if_log_rule_open(nim);
+		break;
+
+	case NSS_IF_CLOSE:
+		nss_if_log_rule_close(nim);
+		break;
+
+	case NSS_IF_LINK_STATE_NOTIFY:
+		nss_if_log_rule_link_state_notify(nim);
+		break;
+
+	case NSS_IF_MTU_CHANGE:
+		nss_if_log_rule_mtu_change(nim);
+		break;
+
+	case NSS_IF_MAC_ADDR_SET:
+		nss_if_log_rule_mac_addr_set(nim);
+		break;
+
+	case NSS_IF_STATS:
+		nss_if_log_rule_stats(nim);
+		break;
+
+	case NSS_IF_ISHAPER_ASSIGN:
+	case NSS_IF_BSHAPER_ASSIGN:
+		nss_if_log_rule_shaper_assign(nim);
+		break;
+
+	case NSS_IF_ISHAPER_UNASSIGN:
+	case NSS_IF_BSHAPER_UNASSIGN:
+		nss_if_log_rule_shaper_unassign(nim);
+		break;
+
+	case NSS_IF_ISHAPER_CONFIG:
+	case NSS_IF_BSHAPER_CONFIG:
+		nss_if_log_rule_shaper_config(nim);
+		break;
+
+	case NSS_IF_PAUSE_ON_OFF:
+		nss_if_log_rule_pause_on_off(nim);
+		break;
+
+	case NSS_IF_VSI_ASSIGN:
+		nss_if_log_rule_vsi_assign(nim);
+		break;
+
+	case NSS_IF_VSI_UNASSIGN:
+		nss_if_log_rule_vsi_unassign(nim);
+		break;
+
+	case NSS_IF_SET_NEXTHOP:
+		nss_if_log_rule_set_nexthop(nim);
+		break;
+
+	case NSS_IF_SET_IGS_NODE:
+		nss_if_log_rule_set_igs_node(nim);
+		break;
+
+	case NSS_IF_CLEAR_IGS_NODE:
+		nss_if_log_rule_clear_igs_node(nim);
+		break;
+
+	case NSS_IF_RESET_NEXTHOP:
+		nss_if_log_rule_reset_nexthop(nim);
+		break;
+
+	default:
+		nss_trace("%px: Invalid message type\n", nim);
+		break;
+	}
+}
+
+/*
+ * nss_if_log_rx_msg()
+ *	Log messages received from FW.
+ */
+void nss_if_log_rx_msg(struct nss_if_msg *nim)
+{
+	if (nim->cm.response >= NSS_CMN_RESPONSE_LAST) {
+		nss_info("%px: Invalid response\n", nim);
+		return;
+	}
+
+	if (nim->cm.response == NSS_CMN_RESPONSE_NOTIFY || (nim->cm.response == NSS_CMN_RESPONSE_ACK)) {
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", nim, nim->cm.type,
+			nss_if_log_message_types_str[nim->cm.type],
+			nim->cm.response, nss_cmn_response_str[nim->cm.response]);
+			goto verbose;
+	}
+
+	if (nim->cm.error >= NSS_IF_ERROR_TYPE_MAX) {
+		nss_info("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
+		nim, nim->cm.type, nss_if_log_message_types_str[nim->cm.type],
+			nim->cm.response, nss_cmn_response_str[nim->cm.response],
+			nim->cm.error);
+		goto verbose;
+	}
+
+	nss_info("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
+		nim, nim->cm.type, nss_if_log_message_types_str[nim->cm.type],
+		nim->cm.response, nss_cmn_response_str[nim->cm.response],
+		nim->cm.error, nss_if_log_error_response_types_str[nim->cm.error]);
+
+verbose:
+	nss_if_log_verbose(nim);
+}
+
+/*
+ * nss_if_log_tx_msg()
+ *	Log messages transmitted to FW.
+ */
+void nss_if_log_tx_msg(struct nss_if_msg *nim)
+{
+	if (nim->cm.type >= NSS_IF_MAX_MSG_TYPES) {
+		nss_info("%px: Invalid message type\n", nim);
+		return;
+	}
+
+	nss_info("%px: type[%d]:%s\n", nim, nim->cm.type, nss_if_log_message_types_str[nim->cm.type]);
+	nss_if_log_verbose(nim);
+}
--- /dev/null
+++ b/nss_if_log.h
@@ -0,0 +1,40 @@
+/*
+ **************************************************************************
+ * Copyright (c) 2020, The Linux Foundation. All rights reserved.
+
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ **************************************************************************
+ */
+
+#ifndef __NSS_IF_LOG_H
+#define __NSS_IF_LOG_H
+
+/*
+ * nss_if_log.h
+ *	NSS Interface header file.
+ */
+
+/*
+ * nss_if_log_tx_msg
+ *	Logs an NSS interface message that is sent to the NSS firmware.
+ */
+void nss_if_log_tx_msg(struct nss_if_msg *nim);
+
+/*
+ * nss_if_log_rx_msg
+ *	Logs an NSS interface message that is received from the NSS firmware.
+ */
+void nss_if_log_rx_msg(struct nss_if_msg *nim);
+
+
+#endif /* __NSS_IF_LOG_H */
--- a/nss_igs.c
+++ b/nss_igs.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -57,12 +57,12 @@ static void nss_igs_handler(struct nss_c
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >= NSS_IGS_MSG_MAX) {
-		nss_warning("%p: received invalid message %d for IGS interface", nss_ctx, ncm->type);
+		nss_warning("%px: received invalid message %d for IGS interface", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_igs_msg)) {
-		nss_warning("%p: tx request for another interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: tx request for another interface: %d", nss_ctx, ncm->interface);
 		return;
 	}
 
@@ -79,7 +79,7 @@ static void nss_igs_handler(struct nss_c
 	 * Update the callback and app_data for NOTIFY messages
 	 */
 	if (ncm->response == NSS_CMN_RESPONSE_NOTIFY) {
-		ncm->cb = (nss_ptr_t)nss_top_main.if_rx_msg_callback[ncm->interface];
+		ncm->cb = (nss_ptr_t)nss_core_get_msg_handler(nss_ctx, ncm->interface);
 		ncm->app_data = (nss_ptr_t)app_data;
 	}
 
@@ -93,7 +93,7 @@ static void nss_igs_handler(struct nss_c
 	 * call igs callback
 	 */
 	if (!cb) {
-		nss_warning("%p: No callback for igs interface %d",
+		nss_warning("%px: No callback for igs interface %d",
 			    nss_ctx, ncm->interface);
 		return;
 	}
@@ -108,15 +108,18 @@ static void nss_igs_handler(struct nss_c
 void nss_igs_unregister_if(uint32_t if_num)
 {
 	struct nss_ctx_instance *nss_ctx = (struct nss_ctx_instance *)&nss_top_main.nss[nss_top_main.igs_handler_id];
+	uint32_t status;
 
 	nss_assert(nss_ctx);
 	nss_assert(nss_igs_verify_if_num(if_num));
 
 	nss_core_unregister_subsys_dp(nss_ctx, if_num);
 
-	nss_top_main.if_rx_msg_callback[if_num] = NULL;
-
 	nss_core_unregister_handler(nss_ctx, if_num);
+	status = nss_core_unregister_msg_handler(nss_ctx, if_num);
+	if (status != NSS_CORE_STATUS_SUCCESS) {
+		nss_warning("%px: Not able to unregister handler for interface %d with NSS core\n", nss_ctx, if_num);
+	}
 
 	nss_igs_stats_reset(if_num);
 }
@@ -131,18 +134,23 @@ struct nss_ctx_instance *nss_igs_registe
 		 uint32_t features)
 {
 	struct nss_ctx_instance *nss_ctx = (struct nss_ctx_instance *)&nss_top_main.nss[nss_top_main.igs_handler_id];
+	uint32_t status;
 
 	nss_assert(nss_ctx);
 	nss_assert(nss_igs_verify_if_num(if_num));
 
+	nss_core_register_handler(nss_ctx, if_num, nss_igs_handler, netdev);
+	status = nss_core_register_msg_handler(nss_ctx, if_num, event_callback);
+	if (status != NSS_CORE_STATUS_SUCCESS) {
+		nss_core_unregister_handler(nss_ctx, if_num);
+		nss_warning("%px: Not able to register handler for interface %d with NSS core\n", nss_ctx, if_num);
+		return NULL;
+	}
+
 	nss_core_register_subsys_dp(nss_ctx, if_num, NULL, 0, netdev, netdev, features);
 	nss_core_set_subsys_dp_type(nss_ctx, netdev, if_num, type);
 
-	nss_top_main.if_rx_msg_callback[if_num] = event_callback;
-
-	nss_core_register_handler(nss_ctx, if_num, nss_igs_handler, netdev);
 	nss_igs_stats_dentry_create();
-
 	nss_igs_stats_init(if_num, netdev);
 
 	return nss_ctx;
--- a/nss_init.c
+++ b/nss_init.c
@@ -660,7 +660,7 @@ static int __init nss_init(void)
 #if defined(NSS_HAL_IPQ807x_SUPPORT)
 	if (of_machine_is_compatible("qcom,ipq807x") || of_machine_is_compatible("qcom,ipq8074")) {
 		nss_top_main.hal_ops = &nss_hal_ipq807x_ops;
-		nss_top_main.data_plane_ops = &nss_data_plane_edma_ops;
+		nss_top_main.data_plane_ops = &nss_data_plane_ops;
 #if defined(NSS_MEM_PROFILE_LOW)
 		nss_top_main.num_nss = 1;
 #else
@@ -671,14 +671,14 @@ static int __init nss_init(void)
 #if defined(NSS_HAL_IPQ60XX_SUPPORT)
 	if (of_machine_is_compatible("qcom,ipq6018")) {
 		nss_top_main.hal_ops = &nss_hal_ipq60xx_ops;
-		nss_top_main.data_plane_ops = &nss_data_plane_edma_ops;
+		nss_top_main.data_plane_ops = &nss_data_plane_ops;
 		nss_top_main.num_nss = 1;
 	}
 #endif
 #if defined(NSS_HAL_IPQ50XX_SUPPORT)
 	if (of_machine_is_compatible("qcom,ipq5018")) {
 		nss_top_main.hal_ops = &nss_hal_ipq50xx_ops;
-		nss_top_main.data_plane_ops = &nss_data_plane_edma_ops;
+		nss_top_main.data_plane_ops = &nss_data_plane_ops;
 		nss_top_main.num_nss = 1;
 	}
 #endif
@@ -864,6 +864,10 @@ static int __init nss_init(void)
 		nss_ppe_init();
 	}
 
+#ifdef NSS_DRV_DMA_ENABLE
+	nss_dma_init();
+#endif
+
 	/*
 	 * Register platform_driver
 	 */
--- a/nss_ipsec.c
+++ b/nss_ipsec.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2013-2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2013-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -136,19 +136,19 @@ static void nss_ipsec_msg_handler(struct
 	 * Sanity check the message type
 	 */
 	if (ncm->type > NSS_IPSEC_MSG_TYPE_MAX) {
-		nss_warning("%p: rx message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: rx message type out of range: %d", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_ipsec_msg)) {
-		nss_warning("%p: rx message length is invalid: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: rx message length is invalid: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
 	BUG_ON((if_num != NSS_IPSEC_ENCAP_INTERFACE_NUM) && (if_num != NSS_IPSEC_DECAP_INTERFACE_NUM));
 
 	if (ncm->response == NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: rx message response for if %d, type %d, is invalid: %d", nss_ctx, ncm->interface,
+		nss_warning("%px: rx message response for if %d, type %d, is invalid: %d", nss_ctx, ncm->interface,
 				ncm->type, ncm->response);
 		return;
 	}
@@ -169,7 +169,7 @@ static void nss_ipsec_msg_handler(struct
 	 */
 	cb = (nss_ipsec_msg_callback_t)ncm->cb;
 	if (unlikely(!cb)) {
-		nss_trace("%p: rx handler has been unregistered for i/f: %d", nss_ctx, ncm->interface);
+		nss_trace("%px: rx handler has been unregistered for i/f: %d", nss_ctx, ncm->interface);
 		return;
 	}
 
@@ -215,7 +215,7 @@ nss_tx_status_t nss_ipsec_tx_msg(struct
 {
 	struct nss_cmn_msg *ncm = &msg->cm;
 
-	nss_info("%p: message %d for if %d\n", nss_ctx, ncm->type, ncm->interface);
+	nss_info("%px: message %d for if %d\n", nss_ctx, ncm->type, ncm->interface);
 
 	BUILD_BUG_ON(NSS_NBUF_PAYLOAD_SIZE < sizeof(struct nss_ipsec_msg));
 
@@ -225,16 +225,16 @@ nss_tx_status_t nss_ipsec_tx_msg(struct
 	nss_ipsec_log_tx_msg(msg);
 
 	if ((ncm->interface != NSS_IPSEC_ENCAP_INTERFACE_NUM) && (ncm->interface != NSS_IPSEC_DECAP_INTERFACE_NUM)) {
-		nss_warning("%p: tx message request for another interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: tx message request for another interface: %d", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
 	if (ncm->type > NSS_IPSEC_MSG_TYPE_MAX) {
-		nss_warning("%p: tx message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: tx message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
-	nss_info("msg params version:%d, interface:%d, type:%d, cb:%p, app_data:%p, len:%d\n",
+	nss_info("msg params version:%d, interface:%d, type:%d, cb:%px, app_data:%px, len:%d\n",
 			ncm->version, ncm->interface, ncm->type, (void *)ncm->cb, (void *)ncm->app_data, ncm->len);
 
 	return nss_core_send_cmd(nss_ctx, msg, sizeof(*msg), NSS_NBUF_PAYLOAD_SIZE);
@@ -257,7 +257,7 @@ nss_tx_status_t nss_ipsec_tx_msg_sync(st
 	 * Length of the message should be the based on type
 	 */
 	if (len > sizeof(nim_local.msg)) {
-		nss_warning("%p: (%u)Bad message length(%u) for type (%d)", nss_ctx, if_num, len, type);
+		nss_warning("%px: (%u)Bad message length(%u) for type (%d)", nss_ctx, if_num, len, type);
 		return NSS_TX_FAILURE_TOO_LARGE;
 	}
 
@@ -265,7 +265,7 @@ nss_tx_status_t nss_ipsec_tx_msg_sync(st
 	 * Response buffer is a required for copying the response for message
 	 */
 	if (!resp) {
-		nss_warning("%p: (%u)Response buffer is empty, type(%d)", nss_ctx, if_num, type);
+		nss_warning("%px: (%u)Response buffer is empty, type(%d)", nss_ctx, if_num, type);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
@@ -297,13 +297,13 @@ nss_tx_status_t nss_ipsec_tx_msg_sync(st
 
 	status = nss_ipsec_tx_msg(nss_ctx, &nim_local);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: ipsec_tx_msg failed", nss_ctx);
+		nss_warning("%px: ipsec_tx_msg failed", nss_ctx);
 		goto done;
 	}
 
 	ret = wait_for_completion_timeout(&nss_ipsec.complete, NSS_IPSEC_TX_TIMEO_TICKS);
 	if (!ret) {
-		nss_warning("%p: IPsec msg tx failed due to timeout", nss_ctx);
+		nss_warning("%px: IPsec msg tx failed due to timeout", nss_ctx);
 		status = NSS_TX_FAILURE_NOT_ENABLED;
 		goto done;
 	}
@@ -339,7 +339,7 @@ nss_tx_status_t nss_ipsec_tx_buf(struct
 {
 	struct nss_ctx_instance *nss_ctx = &nss_top_main.nss[nss_top_main.ipsec_handler_id];
 
-	nss_trace("%p: IPsec If Tx packet, id:%d, data=%p", nss_ctx, if_num, skb->data);
+	nss_trace("%px: IPsec If Tx packet, id:%d, data=%px", nss_ctx, if_num, skb->data);
 
 	return nss_core_send_packet(nss_ctx, skb, if_num, H2N_BIT_FLAG_BUFFER_REUSABLE);
 }
@@ -362,7 +362,7 @@ struct nss_ctx_instance *nss_ipsec_notif
 	struct nss_ctx_instance *nss_ctx = &nss_top->nss[core_id];
 
 	if (if_num >= NSS_MAX_NET_INTERFACES) {
-		nss_warning("%p: notfiy register received for invalid interface %d", nss_ctx, if_num);
+		nss_warning("%px: notfiy register received for invalid interface %d", nss_ctx, if_num);
 		return NULL;
 	}
 
@@ -390,7 +390,7 @@ void nss_ipsec_notify_unregister(struct
 	struct nss_top_instance *nss_top = nss_ctx->nss_top;
 
 	if (if_num >= NSS_MAX_NET_INTERFACES) {
-		nss_warning("%p: notify unregister received for invalid interface %d", nss_ctx, if_num);
+		nss_warning("%px: notify unregister received for invalid interface %d", nss_ctx, if_num);
 		return;
 	}
 
@@ -419,7 +419,7 @@ struct nss_ctx_instance *nss_ipsec_data_
 	nss_ctx = &nss_top_main.nss[nss_top_main.ipsec_handler_id];
 
 	if ((if_num >= NSS_MAX_NET_INTERFACES) && (if_num < NSS_MAX_PHYSICAL_INTERFACES)){
-		nss_warning("%p: data register received for invalid interface %d", nss_ctx, if_num);
+		nss_warning("%px: data register received for invalid interface %d", nss_ctx, if_num);
 		return NULL;
 	}
 
@@ -451,7 +451,7 @@ void nss_ipsec_data_unregister(struct ns
 	struct nss_ctx_instance *nss_ctx0;
 
 	if ((if_num >= NSS_MAX_NET_INTERFACES) && (if_num < NSS_MAX_PHYSICAL_INTERFACES)){
-		nss_warning("%p: data unregister received for invalid interface %d", nss_ctx, if_num);
+		nss_warning("%px: data unregister received for invalid interface %d", nss_ctx, if_num);
 		return;
 	}
 
@@ -529,7 +529,7 @@ bool nss_ipsec_ppe_port_config(struct ns
 	if_num = NSS_INTERFACE_NUM_APPEND_COREID(nss_ctx, if_num);
 
 	if (nss_ppe_tx_ipsec_config_msg(if_num, vsi_num, netdev->mtu, netdev->mtu) != NSS_TX_SUCCESS) {
-		nss_warning("%p: Failed to configure PPE IPsec port", nss_ctx);
+		nss_warning("%px: Failed to configure PPE IPsec port", nss_ctx);
 		return false;
 	}
 
@@ -550,7 +550,7 @@ bool nss_ipsec_ppe_mtu_update(struct nss
 	if_num = NSS_INTERFACE_NUM_APPEND_COREID(nss_ctx, if_num);
 
 	if (nss_ppe_tx_ipsec_mtu_msg(if_num, mtu, mru) != NSS_TX_SUCCESS) {
-		nss_warning("%p: Failed to update PPE MTU for IPsec port", nss_ctx);
+		nss_warning("%px: Failed to update PPE MTU for IPsec port", nss_ctx);
 		return false;
 	}
 
--- a/nss_ipsec_cmn.c
+++ b/nss_ipsec_cmn.c
@@ -180,12 +180,12 @@ static void nss_ipsec_cmn_msg_handler(st
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >=  NSS_IPSEC_CMN_MSG_TYPE_MAX) {
-		nss_warning("%p: Invalid message type(%u) for interface(%u)\n", nss_ctx, ncm->type, ncm->interface);
+		nss_warning("%px: Invalid message type(%u) for interface(%u)\n", nss_ctx, ncm->type, ncm->interface);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_ipsec_cmn_msg)) {
-		nss_warning("%p: Invalid message length(%d)\n", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: Invalid message length(%d)\n", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
@@ -216,11 +216,11 @@ static void nss_ipsec_cmn_msg_handler(st
 	 * Call IPsec message callback
 	 */
 	if (!cb) {
-		nss_warning("%p: No callback for IPsec interface %d\n", nss_ctx, ncm->interface);
+		nss_warning("%px: No callback for IPsec interface %d\n", nss_ctx, ncm->interface);
 		return;
 	}
 
-	nss_trace("%p: calling ipsecsmgr message handler(%u)\n", nss_ctx, ncm->interface);
+	nss_trace("%px: calling ipsecsmgr message handler(%u)\n", nss_ctx, ncm->interface);
 	cb(app_data, ncm);
 }
 
@@ -297,17 +297,17 @@ nss_tx_status_t nss_ipsec_cmn_tx_msg(str
 	 * Sanity check the message
 	 */
 	if (ncm->type >= NSS_IPSEC_CMN_MSG_TYPE_MAX) {
-		nss_warning("%p: Invalid message type(%u)\n", nss_ctx, ncm->type);
+		nss_warning("%px: Invalid message type(%u)\n", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
 	if (!nss_ipsec_cmn_verify_ifnum(nss_ctx, ncm->interface)) {
-		nss_warning("%p: Invalid message interface(%u)\n", nss_ctx, ncm->interface);
+		nss_warning("%px: Invalid message interface(%u)\n", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_ipsec_cmn_msg)) {
-		nss_warning("%p: Invalid message length(%u)\n", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: Invalid message length(%u)\n", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return NSS_TX_FAILURE;
 	}
 
@@ -331,7 +331,7 @@ nss_tx_status_t nss_ipsec_cmn_tx_msg_syn
 	 * Length of the message should be the based on type
 	 */
 	if (len > sizeof(struct nss_ipsec_cmn_msg)) {
-		nss_warning("%p: Invalid message length(%u), type (%d), I/F(%u)\n", nss_ctx, len, type, if_num);
+		nss_warning("%px: Invalid message length(%u), type (%d), I/F(%u)\n", nss_ctx, len, type, if_num);
 		return NSS_TX_FAILURE;
 	}
 
@@ -348,13 +348,13 @@ nss_tx_status_t nss_ipsec_cmn_tx_msg_syn
 
 	status = nss_ipsec_cmn_tx_msg(nss_ctx, local_nicm);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: Failed to send message\n", nss_ctx);
+		nss_warning("%px: Failed to send message\n", nss_ctx);
 		goto done;
 	}
 
 	ret = wait_for_completion_timeout(&ipsec_cmn_pvt.complete, msecs_to_jiffies(NSS_IPSEC_CMN_TX_TIMEOUT));
 	if (!ret) {
-		nss_warning("%p: Failed to receive response, timeout(%d)\n", nss_ctx, ret);
+		nss_warning("%px: Failed to receive response, timeout(%d)\n", nss_ctx, ret);
 		status = NSS_TX_FAILURE_NOT_READY;
 		goto done;
 	}
@@ -388,11 +388,11 @@ EXPORT_SYMBOL(nss_ipsec_cmn_tx_msg_sync)
  */
 nss_tx_status_t nss_ipsec_cmn_tx_buf(struct nss_ctx_instance *nss_ctx, struct sk_buff *os_buf, uint32_t if_num)
 {
-	nss_trace("%p: Send to IPsec I/F(%u), skb(%p)\n", nss_ctx, if_num, os_buf);
+	nss_trace("%px: Send to IPsec I/F(%u), skb(%px)\n", nss_ctx, if_num, os_buf);
 	NSS_VERIFY_CTX_MAGIC(nss_ctx);
 
 	if (!nss_ipsec_cmn_verify_ifnum(nss_ctx, if_num)) {
-		nss_warning("%p: Interface number(%d) is not IPSec type\n", nss_ctx, if_num);
+		nss_warning("%px: Interface number(%d) is not IPSec type\n", nss_ctx, if_num);
 		return NSS_TX_FAILURE;
 	}
 
@@ -413,12 +413,12 @@ struct nss_ctx_instance *nss_ipsec_cmn_r
 	uint32_t status;
 
 	if (!nss_ipsec_cmn_verify_ifnum(nss_ctx, if_num)) {
-		nss_warning("%p: Invalid IPsec interface(%u)\n", nss_ctx, if_num);
+		nss_warning("%px: Invalid IPsec interface(%u)\n", nss_ctx, if_num);
 		return NULL;
 	}
 
 	if (nss_ctx->subsys_dp_register[if_num].ndev) {
-		nss_warning("%p: Failed find free slot for IPsec NSS I/F:%u\n", nss_ctx, if_num);
+		nss_warning("%px: Failed find free slot for IPsec NSS I/F:%u\n", nss_ctx, if_num);
 		return NULL;
 	}
 
@@ -430,14 +430,14 @@ struct nss_ctx_instance *nss_ipsec_cmn_r
 	 */
 	status = nss_core_register_handler(nss_ctx, if_num, nss_ipsec_cmn_msg_handler, app_ctx);
 	if (status != NSS_CORE_STATUS_SUCCESS){
-		nss_warning("%p: Failed to register message handler for IPsec NSS I/F:%u\n", nss_ctx, if_num);
+		nss_warning("%px: Failed to register message handler for IPsec NSS I/F:%u\n", nss_ctx, if_num);
 		return NULL;
 	}
 
 	status = nss_core_register_msg_handler(nss_ctx, if_num, cb_msg);
 	if (status != NSS_CORE_STATUS_SUCCESS) {
 		nss_core_unregister_handler(nss_ctx, if_num);
-		nss_warning("%p: Failed to register message handler for IPsec NSS I/F:%u\n", nss_ctx, if_num);
+		nss_warning("%px: Failed to register message handler for IPsec NSS I/F:%u\n", nss_ctx, if_num);
 		return NULL;
 	}
 
@@ -466,13 +466,13 @@ bool nss_ipsec_cmn_unregister_if(uint32_
 	nss_assert(nss_ctx);
 
 	if (!nss_ipsec_cmn_verify_ifnum(nss_ctx, if_num)) {
-		nss_warning("%p: Invalid IPsec interface(%u)\n", nss_ctx, if_num);
+		nss_warning("%px: Invalid IPsec interface(%u)\n", nss_ctx, if_num);
 		return false;
 	}
 
 	dev = nss_cmn_get_interface_dev(nss_ctx, if_num);
 	if (!dev) {
-		nss_warning("%p: Failed to find registered netdev for IPsec NSS I/F:%u\n", nss_ctx, if_num);
+		nss_warning("%px: Failed to find registered netdev for IPsec NSS I/F:%u\n", nss_ctx, if_num);
 		return false;
 	}
 
@@ -485,13 +485,13 @@ bool nss_ipsec_cmn_unregister_if(uint32_
 
 	status = nss_core_unregister_msg_handler(nss_ctx, if_num);
 	if (status != NSS_CORE_STATUS_SUCCESS) {
-		nss_warning("%p: Failed to unregister handler for IPsec NSS I/F:%u\n", nss_ctx, if_num);
+		nss_warning("%px: Failed to unregister handler for IPsec NSS I/F:%u\n", nss_ctx, if_num);
 		return false;
 	}
 
 	status = nss_core_unregister_handler(nss_ctx, if_num);
 	if (status != NSS_CORE_STATUS_SUCCESS) {
-		nss_warning("%p: Failed to unregister handler for IPsec NSS I/F:%u\n", nss_ctx, if_num);
+		nss_warning("%px: Failed to unregister handler for IPsec NSS I/F:%u\n", nss_ctx, if_num);
 		return false;
 	}
 
@@ -512,14 +512,14 @@ struct nss_ctx_instance *nss_ipsec_cmn_n
 
 	ret = nss_core_register_handler(nss_ctx, if_num, nss_ipsec_cmn_msg_handler, app_data);
 	if (ret != NSS_CORE_STATUS_SUCCESS) {
-		nss_warning("%p: unable to register event handler for interface(%u)\n", nss_ctx, if_num);
+		nss_warning("%px: unable to register event handler for interface(%u)\n", nss_ctx, if_num);
 		return NULL;
 	}
 
 	ret = nss_core_register_msg_handler(nss_ctx, if_num, cb);
 	if (ret != NSS_CORE_STATUS_SUCCESS) {
 		nss_core_unregister_handler(nss_ctx, if_num);
-		nss_warning("%p: Failed to register message handler for IPsec NSS I/F:%u\n", nss_ctx, if_num);
+		nss_warning("%px: Failed to register message handler for IPsec NSS I/F:%u\n", nss_ctx, if_num);
 		return NULL;
 	}
 
@@ -536,19 +536,19 @@ void nss_ipsec_cmn_notify_unregister(str
 	uint32_t ret;
 
 	if (if_num >= NSS_MAX_NET_INTERFACES) {
-		nss_warning("%p: notify unregister received for invalid interface %d\n", nss_ctx, if_num);
+		nss_warning("%px: notify unregister received for invalid interface %d\n", nss_ctx, if_num);
 		return;
 	}
 
 	ret = nss_core_unregister_msg_handler(nss_ctx, if_num);
 	if (ret != NSS_CORE_STATUS_SUCCESS) {
-		nss_warning("%p: unable to unregister event handler for interface(%u)\n", nss_ctx, if_num);
+		nss_warning("%px: unable to unregister event handler for interface(%u)\n", nss_ctx, if_num);
 		return;
 	}
 
 	ret = nss_core_unregister_handler(nss_ctx, if_num);
 	if (ret != NSS_CORE_STATUS_SUCCESS) {
-		nss_warning("%p: unable to unregister event handler for interface(%u)\n", nss_ctx, if_num);
+		nss_warning("%px: unable to unregister event handler for interface(%u)\n", nss_ctx, if_num);
 		return;
 	}
 }
@@ -565,7 +565,7 @@ bool nss_ipsec_cmn_ppe_port_config(struc
 	if_num = NSS_INTERFACE_NUM_APPEND_COREID(nss_ctx, if_num);
 
 	if (nss_ppe_tx_ipsec_config_msg(if_num, vsi_num, netdev->mtu, netdev->mtu) != NSS_TX_SUCCESS) {
-		nss_warning("%p: Failed to configure PPE IPsec port\n", nss_ctx);
+		nss_warning("%px: Failed to configure PPE IPsec port\n", nss_ctx);
 		return false;
 	}
 
@@ -586,7 +586,7 @@ bool nss_ipsec_cmn_ppe_mtu_update(struct
 	if_num = NSS_INTERFACE_NUM_APPEND_COREID(nss_ctx, if_num);
 
 	if (nss_ppe_tx_ipsec_mtu_msg(if_num, mtu, mru) != NSS_TX_SUCCESS) {
-		nss_warning("%p: Failed to update PPE MTU for IPsec port\n", nss_ctx);
+		nss_warning("%px: Failed to update PPE MTU for IPsec port\n", nss_ctx);
 		return false;
 	}
 
--- a/nss_ipsec_cmn_log.c
+++ b/nss_ipsec_cmn_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018-2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -145,7 +145,7 @@ static void nss_ipsec_cmn_log_node_msg(s
 {
 	struct nss_ipsec_cmn_node *node_msg __maybe_unused = &nim->msg.node;
 
-	nss_trace("%p: NSS IPSEC Node Message:\n"
+	nss_trace("%px: NSS IPSEC Node Message:\n"
 		  "%s: %d\n"
 		  "%s: %d\n"
 		  "%s: %d\n", nim,
@@ -162,7 +162,7 @@ static void nss_ipsec_cmn_log_ctx_msg(st
 {
 	struct nss_ipsec_cmn_ctx *ctx_msg __maybe_unused = &nim->msg.ctx;
 
-	nss_trace("%p: NSS IPSEC CTX Message:\n"
+	nss_trace("%px: NSS IPSEC CTX Message:\n"
 		  "%s: %s\n"
 		  "%s: %d\n", nim,
 		  nss_ipsec_cmn_log_ctx_str[0], nss_ipsec_cmn_ctx_types_str[ctx_msg->type],
@@ -179,7 +179,7 @@ static void nss_ipsec_cmn_log_sa_msg(str
 	struct nss_ipsec_cmn_sa_tuple *tuple = &sa_msg->sa_tuple;
 	struct nss_ipsec_cmn_sa_data *data __maybe_unused = &sa_msg->sa_data;
 
-	nss_trace("%p: NSS IPSEC SA Message:\n", nim);
+	nss_trace("%px: NSS IPSEC SA Message:\n", nim);
 
 	if (tuple->ip_ver == 4) {
 		nss_trace("%s: %pI4\n%s: %pI4\n",
@@ -224,7 +224,7 @@ static void nss_ipsec_cmn_log_flow_msg(s
 	struct nss_ipsec_cmn_flow_tuple *flow = &flow_msg->flow_tuple;
 	struct nss_ipsec_cmn_sa_tuple *sa = &flow_msg->sa_tuple;
 
-	nss_trace("%p: NSS IPSEC Flow Message:\n", nim);
+	nss_trace("%px: NSS IPSEC Flow Message:\n", nim);
 
 	if (sa->ip_ver == 4) {
 		nss_trace("%s: %pI4\n%s: %pI4\n",
@@ -298,7 +298,7 @@ static void nss_ipsec_cmn_log_verbose(st
 		break;
 
 	default:
-		nss_warning("%p: Invalid message type\n", nim);
+		nss_warning("%px: Invalid message type\n", nim);
 		break;
 	}
 }
@@ -310,11 +310,11 @@ static void nss_ipsec_cmn_log_verbose(st
 void nss_ipsec_cmn_log_tx_msg(struct nss_ipsec_cmn_msg *nim)
 {
 	if (nim->cm.type >= NSS_IPSEC_CMN_MSG_TYPE_MAX) {
-		nss_warning("%p: Invalid message type\n", nim);
+		nss_warning("%px: Invalid message type\n", nim);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", nim, nim->cm.type, nss_ipsec_cmn_log_msg_types_str[nim->cm.type]);
+	nss_info("%px: type[%d]:%s\n", nim, nim->cm.type, nss_ipsec_cmn_log_msg_types_str[nim->cm.type]);
 	nss_ipsec_cmn_log_verbose(nim);
 }
 
@@ -325,26 +325,26 @@ void nss_ipsec_cmn_log_tx_msg(struct nss
 void nss_ipsec_cmn_log_rx_msg(struct nss_ipsec_cmn_msg *nim)
 {
 	if (nim->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", nim);
+		nss_warning("%px: Invalid response\n", nim);
 		return;
 	}
 
 	if (nim->cm.response == NSS_CMN_RESPONSE_NOTIFY || (nim->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", nim, nim->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", nim, nim->cm.type,
 			nss_ipsec_cmn_log_msg_types_str[nim->cm.type],
 			nim->cm.response, nss_cmn_response_str[nim->cm.response]);
 		goto verbose;
 	}
 
 	if (nim->cm.error >= NSS_IPSEC_CMN_MSG_ERROR_MAX) {
-		nss_warning("%p: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
+		nss_warning("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
 			nim, nim->cm.type, nss_ipsec_cmn_log_msg_types_str[nim->cm.type],
 			nim->cm.response, nss_cmn_response_str[nim->cm.response],
 			nim->cm.error);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
 		nim, nim->cm.type, nss_ipsec_cmn_log_msg_types_str[nim->cm.type],
 		nim->cm.response, nss_cmn_response_str[nim->cm.response],
 		nim->cm.error, nss_ipsec_cmn_log_error_str[nim->cm.error]);
--- a/nss_ipsec_log.c
+++ b/nss_ipsec_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -63,7 +63,7 @@ static void nss_ipsec_log_rule_msg(struc
 {
 	struct nss_ipsec_rule *nir __maybe_unused = &nim->msg.rule;
 
-	nss_trace("%p: NSS IPSEC Rule Message:\n"
+	nss_trace("%px: NSS IPSEC Rule Message:\n"
 		"IPSEC ESP SPI Index: %dn"
 		"IPSEC TTL Hop Limit: %dn"
 		"IPSEC IP Version: %x\n"
@@ -115,7 +115,7 @@ static void nss_ipsec_log_rule_msg(struc
 static void nss_ipsec_log_configure_node_msg(struct nss_ipsec_msg *nim)
 {
 	struct nss_ipsec_configure_node *nicn __maybe_unused = &nim->msg.node;
-	nss_trace("%p: NSS IPSEC Configure Node\n"
+	nss_trace("%px: NSS IPSEC Configure Node\n"
 		"IPSEC DMA Redirect: %d\n"
 		"IPSEC DMA Lookaside: %d\n",
 		nicn, nicn->dma_redirect,
@@ -149,7 +149,7 @@ static void nss_ipsec_log_verbose(struct
 		break;
 
 	default:
-		nss_warning("%p: Invalid message type\n", nim);
+		nss_warning("%px: Invalid message type\n", nim);
 		break;
 	}
 }
@@ -161,11 +161,11 @@ static void nss_ipsec_log_verbose(struct
 void nss_ipsec_log_tx_msg(struct nss_ipsec_msg *nim)
 {
 	if (nim->cm.type >= NSS_IPSEC_MSG_TYPE_MAX) {
-		nss_warning("%p: Invalid message type\n", nim);
+		nss_warning("%px: Invalid message type\n", nim);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", nim, nim->cm.type, nss_ipsec_log_message_types_str[nim->cm.type]);
+	nss_info("%px: type[%d]:%s\n", nim, nim->cm.type, nss_ipsec_log_message_types_str[nim->cm.type]);
 	nss_ipsec_log_verbose(nim);
 }
 
@@ -176,26 +176,26 @@ void nss_ipsec_log_tx_msg(struct nss_ips
 void nss_ipsec_log_rx_msg(struct nss_ipsec_msg *nim)
 {
 	if (nim->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", nim);
+		nss_warning("%px: Invalid response\n", nim);
 		return;
 	}
 
 	if (nim->cm.response == NSS_CMN_RESPONSE_NOTIFY || (nim->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", nim, nim->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", nim, nim->cm.type,
 			nss_ipsec_log_message_types_str[nim->cm.type],
 			nim->cm.response, nss_cmn_response_str[nim->cm.response]);
 		goto verbose;
 	}
 
 	if (nim->cm.error >= NSS_IPSEC_ERROR_TYPE_MAX) {
-		nss_warning("%p: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
+		nss_warning("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
 			nim, nim->cm.type, nss_ipsec_log_message_types_str[nim->cm.type],
 			nim->cm.response, nss_cmn_response_str[nim->cm.response],
 			nim->cm.error);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
 		nim, nim->cm.type, nss_ipsec_log_message_types_str[nim->cm.type],
 		nim->cm.response, nss_cmn_response_str[nim->cm.response],
 		nim->cm.error, nss_ipsec_log_error_response_types_str[nim->cm.error]);
--- a/nss_ipv4.c
+++ b/nss_ipv4.c
@@ -84,12 +84,12 @@ static void nss_ipv4_rx_msg_handler(stru
 	 * Sanity check the message type
 	 */
 	if (ncm->type >= NSS_IPV4_MAX_MSG_TYPES) {
-		nss_warning("%p: message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_ipv4_msg)) {
-		nss_warning("%p: message length is invalid: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: message length is invalid: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
@@ -221,7 +221,7 @@ nss_tx_status_t nss_ipv4_conn_inquiry(st
 	nim.msg.inquiry.rr.tuple = *ipv4_5t_p;
 	nss_tx_status = nss_ipv4_tx(nss_ctx, &nim);
 	if (nss_tx_status != NSS_TX_SUCCESS) {
-		nss_warning("%p: Send inquiry message failed\n", ipv4_5t_p);
+		nss_warning("%px: Send inquiry message failed\n", ipv4_5t_p);
 	}
 
 	return nss_tx_status;
@@ -240,12 +240,12 @@ nss_tx_status_t nss_ipv4_tx_with_size(st
 	 * Sanity check the message
 	 */
 	if (ncm->interface != NSS_IPV4_RX_INTERFACE) {
-		nss_warning("%p: tx request for another interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: tx request for another interface: %d", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
 	if (ncm->type >= NSS_IPV4_MAX_MSG_TYPES) {
-		nss_warning("%p: message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
@@ -286,14 +286,14 @@ nss_tx_status_t nss_ipv4_tx_sync(struct
 
 	status = nss_ipv4_tx(nss_ctx, nim);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: nss ipv4 msg tx failed\n", nss_ctx);
+		nss_warning("%px: nss ipv4 msg tx failed\n", nss_ctx);
 		up(&nss_ipv4_pvt.sem);
 		return status;
 	}
 
 	ret = wait_for_completion_timeout(&nss_ipv4_pvt.complete, msecs_to_jiffies(NSS_IPV4_TX_MSG_TIMEOUT));
 	if (!ret) {
-		nss_warning("%p: IPv4 tx sync failed due to timeout\n", nss_ctx);
+		nss_warning("%px: IPv4 tx sync failed due to timeout\n", nss_ctx);
 		nss_ipv4_pvt.response = NSS_TX_FAILURE;
 	}
 
@@ -396,14 +396,14 @@ static void nss_ipv4_conn_cfg_process_ca
 	struct nss_ctx_instance *nss_ctx __maybe_unused = nss_ipv4_get_mgr();
 
 	if (nim->cm.response != NSS_CMN_RESPONSE_ACK) {
-		nss_warning("%p: IPv4 connection configuration failed with error: %d\n", nss_ctx, nim->cm.error);
+		nss_warning("%px: IPv4 connection configuration failed with error: %d\n", nss_ctx, nim->cm.error);
 		nss_core_update_max_ipv4_conn(NSS_FW_DEFAULT_NUM_CONN);
 		nss_ipv4_free_conn_tables();
 		return;
 	}
 
 	nss_ipv4_conn_cfg = ntohl(nirccm->num_conn);
-	nss_info("%p: IPv4 connection configuration success: %d\n", nss_ctx, nim->cm.error);
+	nss_info("%px: IPv4 connection configuration success: %d\n", nss_ctx, nim->cm.error);
 }
 
 /*
@@ -417,17 +417,17 @@ static int nss_ipv4_conn_cfg_process(str
 	nss_tx_status_t nss_tx_status;
 
 	if ((!nss_ipv4_ct_info.ce_table_size) || (!nss_ipv4_ct_info.cme_table_size)) {
-		nss_warning("%p: connection entry or connection match entry table size not available\n",
+		nss_warning("%px: connection entry or connection match entry table size not available\n",
 				nss_ctx);
 		return -EINVAL;
 	}
 
-	nss_info("%p: IPv4 supported connections: %d\n", nss_ctx, conn);
+	nss_info("%px: IPv4 supported connections: %d\n", nss_ctx, conn);
 
 	nss_ipv4_ct_info.ce_mem = __get_free_pages(GFP_KERNEL | __GFP_NOWARN | __GFP_ZERO,
 					get_order(nss_ipv4_ct_info.ce_table_size));
 	if (!nss_ipv4_ct_info.ce_mem) {
-		nss_warning("%p: Memory allocation failed for IPv4 Connections: %d\n",
+		nss_warning("%px: Memory allocation failed for IPv4 Connections: %d\n",
 							nss_ctx,
 							conn);
 		goto fail;
@@ -436,7 +436,7 @@ static int nss_ipv4_conn_cfg_process(str
 	nss_ipv4_ct_info.cme_mem = __get_free_pages(GFP_KERNEL | __GFP_NOWARN | __GFP_ZERO,
 					get_order(nss_ipv4_ct_info.cme_table_size));
 	if (!nss_ipv4_ct_info.ce_mem) {
-		nss_warning("%p: Memory allocation failed for IPv4 Connections: %d\n",
+		nss_warning("%px: Memory allocation failed for IPv4 Connections: %d\n",
 							nss_ctx,
 							conn);
 		goto fail;
@@ -450,19 +450,19 @@ static int nss_ipv4_conn_cfg_process(str
 	nirccm->num_conn = htonl(conn);
 	nirccm->ce_mem = dma_map_single(nss_ctx->dev, (void *)nss_ipv4_ct_info.ce_mem, nss_ipv4_ct_info.ce_table_size, DMA_TO_DEVICE);
 	if (unlikely(dma_mapping_error(nss_ctx->dev, nirccm->ce_mem))) {
-		nss_warning("%p: DMA mapping failed for virtual address = %p", nss_ctx, (void *)nss_ipv4_ct_info.ce_mem);
+		nss_warning("%px: DMA mapping failed for virtual address = %px", nss_ctx, (void *)nss_ipv4_ct_info.ce_mem);
 		goto fail;
 	}
 
 	nirccm->cme_mem = dma_map_single(nss_ctx->dev, (void *)nss_ipv4_ct_info.cme_mem, nss_ipv4_ct_info.cme_table_size, DMA_TO_DEVICE);
 	if (unlikely(dma_mapping_error(nss_ctx->dev, nirccm->cme_mem))) {
-		nss_warning("%p: DMA mapping failed for virtual address = %p", nss_ctx, (void *)nss_ipv4_ct_info.cme_mem);
+		nss_warning("%px: DMA mapping failed for virtual address = %px", nss_ctx, (void *)nss_ipv4_ct_info.cme_mem);
 		goto fail;
 	}
 
 	nss_tx_status = nss_ipv4_tx(nss_ctx, &nim);
 	if (nss_tx_status != NSS_TX_SUCCESS) {
-		nss_warning("%p: nss_tx error setting IPv4 Connections: %d\n",
+		nss_warning("%px: nss_tx error setting IPv4 Connections: %d\n",
 							nss_ctx,
 							conn);
 		goto fail;
@@ -485,7 +485,7 @@ static void nss_ipv4_update_conn_count_c
 	struct nss_ctx_instance *nss_ctx = nss_ipv4_get_mgr();
 
 	if (nim->cm.response != NSS_CMN_RESPONSE_ACK) {
-		nss_warning("%p: IPv4 fetch connection info failed with error: %d\n", nss_ctx, nim->cm.error);
+		nss_warning("%px: IPv4 fetch connection info failed with error: %d\n", nss_ctx, nim->cm.error);
 		nss_core_update_max_ipv4_conn(NSS_FW_DEFAULT_NUM_CONN);
 		return;
 	}
@@ -496,7 +496,7 @@ static void nss_ipv4_update_conn_count_c
 	nss_ipv4_ct_info.cme_table_size = ntohl(nircgts->cme_table_size);
 
 	if (nss_ipv4_conn_cfg_process(nss_ctx, ntohl(nircgts->num_conn)) != 0) {
-		nss_warning("%p: IPv4 connection entry or connection match entry table size\
+		nss_warning("%px: IPv4 connection entry or connection match entry table size\
 				not available\n", nss_ctx);
 	}
 
@@ -522,7 +522,7 @@ int nss_ipv4_update_conn_count(int ipv4_
 	 * By default, NSS FW is configured with default number of connections.
 	 */
 	if (ipv4_num_conn == NSS_FW_DEFAULT_NUM_CONN) {
-		nss_info("%p: Default number of connections (%d) already configured\n", nss_ctx, ipv4_num_conn);
+		nss_info("%px: Default number of connections (%d) already configured\n", nss_ctx, ipv4_num_conn);
 		return 0;
 	}
 
@@ -536,7 +536,7 @@ int nss_ipv4_update_conn_count(int ipv4_
 	if ((ipv4_num_conn & NSS_NUM_CONN_QUANTA_MASK) ||
 		(sum_of_conn > NSS_MAX_TOTAL_NUM_CONN_IPV4_IPV6) ||
 		(ipv4_num_conn < NSS_MIN_NUM_CONN)) {
-		nss_warning("%p: input supported connections (%d) does not adhere\
+		nss_warning("%px: input supported connections (%d) does not adhere\
 				specifications\n1) not multiple of 1024,\n2) is less than \
 				min val: %d, OR\n	IPv4/6 total exceeds %d\n",
 				nss_ctx,
@@ -555,7 +555,7 @@ int nss_ipv4_update_conn_count(int ipv4_
 	nss_tx_status = nss_ipv4_tx(nss_ctx, &nim);
 
 	if (nss_tx_status != NSS_TX_SUCCESS) {
-		nss_warning("%p: Send fetch connection info message failed\n", nss_ctx);
+		nss_warning("%px: Send fetch connection info message failed\n", nss_ctx);
 		return -EINVAL;
 	}
 
@@ -616,7 +616,7 @@ static int nss_ipv4_accel_mode_cfg_handl
 
 	nss_tx_status = nss_ipv4_tx_sync(nss_ctx, &nim);
 	if (nss_tx_status != NSS_TX_SUCCESS) {
-		nss_warning("%p: Send acceleration mode message failed\n", nss_ctx);
+		nss_warning("%px: Send acceleration mode message failed\n", nss_ctx);
 		nss_ipv4_accel_mode_cfg = current_value;
 		return -EIO;
 	}
@@ -665,7 +665,7 @@ static int nss_ipv4_dscp_map_cfg_handler
 
 	status = nss_ipv4_tx_sync(nss_ctx, &nim);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: ipv4 dscp2pri config message failed\n", nss_ctx);
+		nss_warning("%px: ipv4 dscp2pri config message failed\n", nss_ctx);
 		return -EFAULT;
 	}
 
--- a/nss_ipv4_log.c
+++ b/nss_ipv4_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2016, 2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016, 2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -63,7 +63,7 @@ static int8_t *nss_ipv4_log_error_respon
 static void nss_ipv4_log_rule_create_msg(struct nss_ipv4_msg *nim)
 {
 	struct nss_ipv4_rule_create_msg *nircm __maybe_unused = &nim->msg.rule_create;
-	nss_trace("%p: IPv4 create rule message \n"
+	nss_trace("%px: IPv4 create rule message \n"
 		"Protocol: %d\n"
 		"from_mtu: %u\n"
 		"to_mtu: %u\n"
@@ -124,7 +124,7 @@ static void nss_ipv4_log_rule_create_msg
 static void nss_ipv4_log_destroy_rule_msg(struct nss_ipv4_msg *nim)
 {
 	struct nss_ipv4_rule_destroy_msg *nirdm __maybe_unused = &nim->msg.rule_destroy;
-	nss_trace("%p: IPv4 destroy rule message: \n"
+	nss_trace("%px: IPv4 destroy rule message: \n"
 		"flow_ip: %pI4h:%d\n"
 		"return_ip: %pI4h:%d\n"
 		"protocol: %d\n",
@@ -142,7 +142,7 @@ static void nss_ipv4_log_conn_sync(struc
 {
 	struct nss_ipv4_conn_sync *sync = &nim->msg.conn_stats;
 	if (sync->flow_tx_packet_count || sync->return_tx_packet_count) {
-		nss_trace("%p: IPv4 connection stats sync message: \n"
+		nss_trace("%px: IPv4 connection stats sync message: \n"
 			"Protocol: %d\n"
 			"src_addr: %pI4h:%d\n"
 			"dest_addr: %pI4h:%d\n"
@@ -176,7 +176,7 @@ static void nss_ipv4_log_conn_sync(struc
 static void nss_ipv4_log_conn_cfg_msg(struct nss_ipv4_msg *nim)
 {
 	struct nss_ipv4_rule_conn_cfg_msg *nirccm __maybe_unused = &nim->msg.rule_conn_cfg;
-	nss_trace("%p: IPv4 number of connections supported rule message: \n"
+	nss_trace("%px: IPv4 number of connections supported rule message: \n"
 		"num_conn: %d\n",
 		nim,
 		nirccm->num_conn);
@@ -191,7 +191,7 @@ static void nss_ipv4_log_mc_rule_create_
 	uint16_t vif;
 	struct nss_ipv4_mc_rule_create_msg *nimrcm = &nim->msg.mc_rule_create;
 	for (vif = 0; vif < nimrcm->if_count ; vif++) {
-		nss_trace("%p: IPv4 multicast create rule message \n"
+		nss_trace("%px: IPv4 multicast create rule message \n"
 			"Rule flag: %x\n"
 			"Vif: %d\n"
 			"Protocol: %d\n"
@@ -227,7 +227,7 @@ static void nss_ipv4_log_conn_sync_many_
 	for (i = 0; i < nicsm->count; i++) {
 		struct nss_ipv4_conn_sync *sync = &nicsm->conn_sync[i];
 		if (sync->flow_tx_packet_count || sync->return_tx_packet_count) {
-			nss_trace("%p: IPv4 many conn sync message \n"
+			nss_trace("%px: IPv4 many conn sync message \n"
 				"count: %d\n"
 				"i: %d\n"
 				"Protocol: %d\n"
@@ -295,7 +295,7 @@ static void nss_ipv4_log_verbose(struct
 		break;
 
 	default:
-		nss_trace("%p: Invalid message type\n", nim);
+		nss_trace("%px: Invalid message type\n", nim);
 		break;
 	}
 }
@@ -307,11 +307,11 @@ static void nss_ipv4_log_verbose(struct
 void nss_ipv4_log_tx_msg(struct nss_ipv4_msg *nim)
 {
 	if (nim->cm.type >= NSS_IPV4_MAX_MSG_TYPES) {
-		nss_info("%p: Invalid message type\n", nim);
+		nss_info("%px: Invalid message type\n", nim);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", nim, nim->cm.type, nss_ipv4_log_message_types_str[nim->cm.type]);
+	nss_info("%px: type[%d]:%s\n", nim, nim->cm.type, nss_ipv4_log_message_types_str[nim->cm.type]);
 	nss_ipv4_log_verbose(nim);
 }
 
@@ -322,26 +322,26 @@ void nss_ipv4_log_tx_msg(struct nss_ipv4
 void nss_ipv4_log_rx_msg(struct nss_ipv4_msg *nim)
 {
 	if (nim->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_info("%p: Invalid response\n", nim);
+		nss_info("%px: Invalid response\n", nim);
 		return;
 	}
 
 	if (nim->cm.response == NSS_CMN_RESPONSE_NOTIFY || (nim->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", nim, nim->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", nim, nim->cm.type,
 			nss_ipv4_log_message_types_str[nim->cm.type],
 			nim->cm.response, nss_cmn_response_str[nim->cm.response]);
 		goto verbose;
 	}
 
 	if (nim->cm.error >= NSS_IPV4_LAST) {
-		nss_info("%p: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
+		nss_info("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
 			nim, nim->cm.type, nss_ipv4_log_message_types_str[nim->cm.type],
 			nim->cm.response, nss_cmn_response_str[nim->cm.response],
 			nim->cm.error);
 		goto verbose;
 	}
 
-	nss_info("%p: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
+	nss_info("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
 		nim, nim->cm.type, nss_ipv4_log_message_types_str[nim->cm.type],
 		nim->cm.response, nss_cmn_response_str[nim->cm.response],
 		nim->cm.error, nss_ipv4_log_error_response_types_str[nim->cm.error]);
--- a/nss_ipv4_stats.c
+++ b/nss_ipv4_stats.c
@@ -130,7 +130,7 @@ void nss_ipv4_stats_conn_sync_many(struc
 	 * Sanity check for the stats count
 	 */
 	if (nicsm->count * sizeof(struct nss_ipv4_conn_sync) >= nicsm->size) {
-		nss_warning("%p: stats sync count %u exceeds the size of this msg %u", nss_ctx, nicsm->count, nicsm->size);
+		nss_warning("%px: stats sync count %u exceeds the size of this msg %u", nss_ctx, nicsm->count, nicsm->size);
 		return;
 	}
 
--- a/nss_ipv6.c
+++ b/nss_ipv6.c
@@ -84,12 +84,12 @@ static void nss_ipv6_rx_msg_handler(stru
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >= NSS_IPV6_MAX_MSG_TYPES) {
-		nss_warning("%p: received invalid message %d for IPv6 interface", nss_ctx, nim->cm.type);
+		nss_warning("%px: received invalid message %d for IPv6 interface", nss_ctx, nim->cm.type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_ipv6_msg)) {
-		nss_warning("%p: message length is invalid: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: message length is invalid: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
@@ -224,7 +224,7 @@ nss_tx_status_t nss_ipv6_conn_inquiry(st
 	nim.msg.inquiry.rr.tuple = *ipv6_5t_p;
 	nss_tx_status = nss_ipv6_tx(nss_ctx, &nim);
 	if (nss_tx_status != NSS_TX_SUCCESS) {
-		nss_warning("%p: Send inquiry message failed\n", ipv6_5t_p);
+		nss_warning("%px: Send inquiry message failed\n", ipv6_5t_p);
 	}
 
 	return nss_tx_status;
@@ -243,12 +243,12 @@ nss_tx_status_t nss_ipv6_tx_with_size(st
 	 * Sanity check the message
 	 */
 	if (ncm->interface != NSS_IPV6_RX_INTERFACE) {
-		nss_warning("%p: tx request for another interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: tx request for another interface: %d", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
 	if (ncm->type >= NSS_IPV6_MAX_MSG_TYPES) {
-		nss_warning("%p: message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
@@ -289,14 +289,14 @@ nss_tx_status_t nss_ipv6_tx_sync(struct
 
 	status = nss_ipv6_tx(nss_ctx, nim);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: nss ipv6 msg tx failed\n", nss_ctx);
+		nss_warning("%px: nss ipv6 msg tx failed\n", nss_ctx);
 		up(&nss_ipv6_pvt.sem);
 		return status;
 	}
 
 	ret = wait_for_completion_timeout(&nss_ipv6_pvt.complete, msecs_to_jiffies(NSS_IPV6_TX_MSG_TIMEOUT));
 	if (!ret) {
-		nss_warning("%p: IPv6 tx sync failed due to timeout\n", nss_ctx);
+		nss_warning("%px: IPv6 tx sync failed due to timeout\n", nss_ctx);
 		nss_ipv6_pvt.response = NSS_TX_FAILURE;
 	}
 
@@ -399,7 +399,7 @@ static void nss_ipv6_conn_cfg_process_ca
 	struct nss_ctx_instance *nss_ctx __maybe_unused = nss_ipv6_get_mgr();
 
 	if (nim->cm.response != NSS_CMN_RESPONSE_ACK) {
-		nss_warning("%p: IPv6 connection configuration failed with error: %d\n", nss_ctx, nim->cm.error);
+		nss_warning("%px: IPv6 connection configuration failed with error: %d\n", nss_ctx, nim->cm.error);
 		nss_core_update_max_ipv6_conn(NSS_FW_DEFAULT_NUM_CONN);
 		nss_ipv6_free_conn_tables();
 		return;
@@ -407,7 +407,7 @@ static void nss_ipv6_conn_cfg_process_ca
 
 	nss_ipv6_conn_cfg = ntohl(nirccm->num_conn);
 
-	nss_info("%p: IPv6 connection configuration success: %d\n", nss_ctx, nim->cm.error);
+	nss_info("%px: IPv6 connection configuration success: %d\n", nss_ctx, nim->cm.error);
 }
 
 /*
@@ -421,34 +421,34 @@ static int nss_ipv6_conn_cfg_process(str
 	nss_tx_status_t nss_tx_status;
 
 	if ((!nss_ipv6_ct_info.ce_table_size) || (!nss_ipv6_ct_info.cme_table_size)) {
-		nss_warning("%p: connection entry or connection match entry table size not available\n",
+		nss_warning("%px: connection entry or connection match entry table size not available\n",
 				nss_ctx);
 		return -EINVAL;
 	}
 
-	nss_info("%p: IPv6 supported connections: %d\n", nss_ctx, conn);
+	nss_info("%px: IPv6 supported connections: %d\n", nss_ctx, conn);
 
 	nss_ipv6_ct_info.ce_mem = __get_free_pages(GFP_KERNEL | __GFP_NOWARN | __GFP_ZERO,
 					get_order(nss_ipv6_ct_info.ce_table_size));
 	if (!nss_ipv6_ct_info.ce_mem) {
-		nss_warning("%p: Memory allocation failed for IPv6 Connections: %d\n",
+		nss_warning("%px: Memory allocation failed for IPv6 Connections: %d\n",
 							nss_ctx,
 							conn);
 		goto fail;
 	}
-	nss_info("%p: CE Memory allocated for IPv6 Connections: %d\n",
+	nss_info("%px: CE Memory allocated for IPv6 Connections: %d\n",
 							nss_ctx,
 							conn);
 
 	nss_ipv6_ct_info.cme_mem = __get_free_pages(GFP_KERNEL | __GFP_NOWARN | __GFP_ZERO,
 					get_order(nss_ipv6_ct_info.cme_table_size));
 	if (!nss_ipv6_ct_info.cme_mem) {
-		nss_warning("%p: Memory allocation failed for IPv6 Connections: %d\n",
+		nss_warning("%px: Memory allocation failed for IPv6 Connections: %d\n",
 							nss_ctx,
 							conn);
 		goto fail;
 	}
-	nss_info("%p: CME Memory allocated for IPv6 Connections: %d\n",
+	nss_info("%px: CME Memory allocated for IPv6 Connections: %d\n",
 							nss_ctx,
 							conn);
 
@@ -460,19 +460,19 @@ static int nss_ipv6_conn_cfg_process(str
 	nirccm->num_conn = htonl(conn);
 	nirccm->ce_mem = dma_map_single(nss_ctx->dev, (void *)nss_ipv6_ct_info.ce_mem, nss_ipv6_ct_info.ce_table_size, DMA_TO_DEVICE);
 	if (unlikely(dma_mapping_error(nss_ctx->dev, nirccm->ce_mem))) {
-		nss_warning("%p: DMA mapping failed for virtual address = %p", nss_ctx, (void *)nss_ipv6_ct_info.ce_mem);
+		nss_warning("%px: DMA mapping failed for virtual address = %px", nss_ctx, (void *)nss_ipv6_ct_info.ce_mem);
 		goto fail;
 	}
 
 	nirccm->cme_mem = dma_map_single(nss_ctx->dev, (void *)nss_ipv6_ct_info.cme_mem, nss_ipv6_ct_info.cme_table_size, DMA_TO_DEVICE);
 	if (unlikely(dma_mapping_error(nss_ctx->dev, nirccm->cme_mem))) {
-		nss_warning("%p: DMA mapping failed for virtual address = %p", nss_ctx, (void *)nss_ipv6_ct_info.cme_mem);
+		nss_warning("%px: DMA mapping failed for virtual address = %px", nss_ctx, (void *)nss_ipv6_ct_info.cme_mem);
 		goto fail;
 	}
 
 	nss_tx_status = nss_ipv6_tx(nss_ctx, &nim);
 	if (nss_tx_status != NSS_TX_SUCCESS) {
-		nss_warning("%p: nss_tx error setting IPv6 Connections: %d\n",
+		nss_warning("%px: nss_tx error setting IPv6 Connections: %d\n",
 						nss_ctx,
 						conn);
 		goto fail;
@@ -495,7 +495,7 @@ static void nss_ipv6_update_conn_count_c
 	struct nss_ctx_instance *nss_ctx = nss_ipv6_get_mgr();
 
 	if (nim->cm.response != NSS_CMN_RESPONSE_ACK) {
-		nss_warning("%p: IPv6 fetch connection info failed with error: %d\n", nss_ctx, nim->cm.error);
+		nss_warning("%px: IPv6 fetch connection info failed with error: %d\n", nss_ctx, nim->cm.error);
 		nss_core_update_max_ipv6_conn(NSS_FW_DEFAULT_NUM_CONN);
 		return;
 	}
@@ -506,7 +506,7 @@ static void nss_ipv6_update_conn_count_c
 	nss_ipv6_ct_info.cme_table_size = ntohl(nircgts->cme_table_size);
 
 	if (nss_ipv6_conn_cfg_process(nss_ctx, ntohl(nircgts->num_conn)) != 0) {
-		nss_warning("%p: IPv6 connection entry or connection match entry table size\
+		nss_warning("%px: IPv6 connection entry or connection match entry table size\
 				not available\n", nss_ctx);
 	}
 
@@ -532,7 +532,7 @@ int nss_ipv6_update_conn_count(int ipv6_
 	 * By default, NSS FW is configured with default number of connections.
 	 */
 	if (ipv6_num_conn == NSS_FW_DEFAULT_NUM_CONN) {
-		nss_info("%p: Default number of connections (%d) already configured\n", nss_ctx, ipv6_num_conn);
+		nss_info("%px: Default number of connections (%d) already configured\n", nss_ctx, ipv6_num_conn);
 		return 0;
 	}
 
@@ -547,7 +547,7 @@ int nss_ipv6_update_conn_count(int ipv6_
 	if ((ipv6_num_conn & NSS_NUM_CONN_QUANTA_MASK) ||
 		(sum_of_conn > NSS_MAX_TOTAL_NUM_CONN_IPV4_IPV6) ||
 		(ipv6_num_conn < NSS_MIN_NUM_CONN)) {
-		nss_warning("%p: input supported connections (%d) does not adhere\
+		nss_warning("%px: input supported connections (%d) does not adhere\
 				specifications\n1) not power of 2,\n2) is less than \
 				min val: %d, OR\n	IPv4/6 total exceeds %d\n",
 				nss_ctx,
@@ -565,7 +565,7 @@ int nss_ipv6_update_conn_count(int ipv6_
 	nircgts->num_conn = htonl(ipv6_num_conn);
 	nss_tx_status = nss_ipv6_tx(nss_ctx, &nim);
 	if (nss_tx_status != NSS_TX_SUCCESS) {
-		nss_warning("%p: Send acceleration mode message failed\n", nss_ctx);
+		nss_warning("%px: Send acceleration mode message failed\n", nss_ctx);
 		return -EINVAL;
 	}
 
@@ -626,7 +626,7 @@ static int nss_ipv6_accel_mode_cfg_handl
 
 	nss_tx_status = nss_ipv6_tx_sync(nss_ctx, &nim);
 	if (nss_tx_status != NSS_TX_SUCCESS) {
-		nss_warning("%p: Send acceleration mode message failed\n", nss_ctx);
+		nss_warning("%px: Send acceleration mode message failed\n", nss_ctx);
 		nss_ipv6_accel_mode_cfg = current_value;
 		return -EIO;
 	}
@@ -674,7 +674,7 @@ static int nss_ipv6_dscp_map_cfg_handler
 
 	status = nss_ipv6_tx_sync(nss_ctx, &nim);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: ipv6 dscp2pri config message failed\n", nss_ctx);
+		nss_warning("%px: ipv6 dscp2pri config message failed\n", nss_ctx);
 		return -EFAULT;
 	}
 
--- a/nss_ipv6_log.c
+++ b/nss_ipv6_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2016, 2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016, 2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -80,7 +80,7 @@ static void nss_ipv6_log_rule_create_msg
 	NSS_IPV6_ADDR_TO_NW(nircm->tuple.flow_ip, src_ip);
 	NSS_IPV6_ADDR_TO_NW(nircm->tuple.return_ip, dest_ip);
 
-	nss_trace("%p: IPv6 create rule message \n"
+	nss_trace("%px: IPv6 create rule message \n"
 		"Protocol: %d\n"
 		"from_mtu: %u\n"
 		"to_mtu: %u\n"
@@ -143,7 +143,7 @@ static void nss_ipv6_log_destroy_rule_ms
 	NSS_IPV6_ADDR_TO_NW(nirdm->tuple.flow_ip, src_ip);
 	NSS_IPV6_ADDR_TO_NW(nirdm->tuple.return_ip, dest_ip);
 
-	nss_trace("%p: IPv6 destroy rule message: \n"
+	nss_trace("%px: IPv6 destroy rule message: \n"
 		"flow_ip: %pI6:%d\n"
 		"return_ip: %pI6:%d\n"
 		"protocol: %d\n",
@@ -167,7 +167,7 @@ static void nss_ipv6_log_conn_sync(struc
 		NSS_IPV6_ADDR_TO_NW(sync->flow_ip, src_ip);
 		NSS_IPV6_ADDR_TO_NW(sync->return_ip, dest_ip);
 
-		nss_trace("%p: IPv6 connection stats sync message: \n"
+		nss_trace("%px: IPv6 connection stats sync message: \n"
 			"Protocol: %d\n"
 			"src_addr: %pI6:%d\n"
 			"dest_addr: %pI6:%d\n"
@@ -201,7 +201,7 @@ static void nss_ipv6_log_conn_sync(struc
 static void nss_ipv6_log_conn_cfg_msg(struct nss_ipv6_msg *nim)
 {
 	struct nss_ipv6_rule_conn_cfg_msg *nirccm __maybe_unused = &nim->msg.rule_conn_cfg;
-	nss_trace("%p: IPv6 number of connections supported rule message: \n"
+	nss_trace("%px: IPv6 number of connections supported rule message: \n"
 		"num_conn: %d\n",
 		nim,
 		nirccm->num_conn);
@@ -222,7 +222,7 @@ static void nss_ipv6_log_mc_rule_create_
 	NSS_IPV6_ADDR_TO_NW(nimrcm->tuple.return_ip, dest_ip);
 
 	for (vif = 0; vif < nimrcm->if_count ; vif++) {
-		nss_trace("%p: IPv6 multicast create rule message \n"
+		nss_trace("%px: IPv6 multicast create rule message \n"
 			"Rule flag: %x\n"
 			"Vif: %d\n"
 			"Protocol: %d\n"
@@ -264,7 +264,7 @@ static void nss_ipv6_log_conn_sync_many_
 			NSS_IPV6_ADDR_TO_NW(sync->flow_ip, src_ip);
 			NSS_IPV6_ADDR_TO_NW(sync->return_ip, dest_ip);
 
-			nss_trace("%p: IPv6 many conn sync message \n"
+			nss_trace("%px: IPv6 many conn sync message \n"
 				"count: %d\n"
 				"i: %d\n"
 				"Protocol: %d\n"
@@ -332,7 +332,7 @@ static void nss_ipv6_log_verbose(struct
 		break;
 
 	default:
-		nss_trace("%p: Invalid message type\n", nim);
+		nss_trace("%px: Invalid message type\n", nim);
 		break;
 	}
 }
@@ -343,7 +343,7 @@ static void nss_ipv6_log_verbose(struct
  */
 void nss_ipv6_log_tx_msg(struct nss_ipv6_msg *nim)
 {
-	nss_info("%p: type[%d]: %s\n", nim, nim->cm.type, nss_ipv6_log_message_types_str[nim->cm.type]);
+	nss_info("%px: type[%d]: %s\n", nim, nim->cm.type, nss_ipv6_log_message_types_str[nim->cm.type]);
 	nss_ipv6_log_verbose(nim);
 }
 
@@ -354,26 +354,26 @@ void nss_ipv6_log_tx_msg(struct nss_ipv6
 void nss_ipv6_log_rx_msg(struct nss_ipv6_msg *nim)
 {
 	if (nim->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_info("%p: Invalid response\n", nim);
+		nss_info("%px: Invalid response\n", nim);
 		return;
 	}
 
 	if (nim->cm.response == NSS_CMN_RESPONSE_NOTIFY || (nim->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]: %s, response[%d]: %s\n", nim, nim->cm.type,
+		nss_info("%px: type[%d]: %s, response[%d]: %s\n", nim, nim->cm.type,
 			nss_ipv6_log_message_types_str[nim->cm.type],
 			nim->cm.response, nss_cmn_response_str[nim->cm.response]);
 		goto verbose;
 	}
 
 	if (nim->cm.error > NSS_IPV6_CR_MULTICAST_UPDATE_INVALID_IF) {
-		nss_info("%p: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
+		nss_info("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
 			nim, nim->cm.type, nss_ipv6_log_message_types_str[nim->cm.type],
 			nim->cm.response, nss_cmn_response_str[nim->cm.response],
 			nim->cm.error);
 		goto verbose;
 	}
 
-	nss_info("%p: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
+	nss_info("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
 		nim, nim->cm.type, nss_ipv6_log_message_types_str[nim->cm.type],
 		nim->cm.response, nss_cmn_response_str[nim->cm.response],
 		nim->cm.error, nss_ipv6_log_error_response_types_str[nim->cm.error]);
--- a/nss_ipv6_stats.c
+++ b/nss_ipv6_stats.c
@@ -132,7 +132,7 @@ void nss_ipv6_stats_conn_sync_many(struc
 	 * Sanity check for the stats count
 	 */
 	if (nicsm->count * sizeof(struct nss_ipv6_conn_sync) >= nicsm->size) {
-		nss_warning("%p: stats sync count %u exceeds the size of this msg %u", nss_ctx, nicsm->count, nicsm->size);
+		nss_warning("%px: stats sync count %u exceeds the size of this msg %u", nss_ctx, nicsm->count, nicsm->size);
 		return;
 	}
 
--- a/nss_l2tpv2.c
+++ b/nss_l2tpv2.c
@@ -95,12 +95,12 @@ static void nss_l2tpv2_handler(struct ns
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >= NSS_L2TPV2_MSG_MAX) {
-		nss_warning("%p: received invalid message %d for L2TP interface", nss_ctx, ncm->type);
+		nss_warning("%px: received invalid message %d for L2TP interface", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_l2tpv2_msg)) {
-		nss_warning("%p: message length is invalid: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: message length is invalid: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
@@ -145,7 +145,7 @@ static void nss_l2tpv2_handler(struct ns
 	 * call l2tpv2 tunnel callback
 	 */
 	if (!ctx) {
-		nss_warning("%p: Event received for l2tpv2 tunnel interface %d before registration", nss_ctx, ncm->interface);
+		nss_warning("%px: Event received for l2tpv2 tunnel interface %d before registration", nss_ctx, ncm->interface);
 		return;
 	}
 
@@ -169,12 +169,12 @@ nss_tx_status_t nss_l2tpv2_tx(struct nss
 	 * Sanity check the message
 	 */
 	if (!nss_is_dynamic_interface(ncm->interface)) {
-		nss_warning("%p: tx request for non dynamic interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: tx request for non dynamic interface: %d", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
 	if (ncm->type > NSS_L2TPV2_MSG_MAX) {
-		nss_warning("%p: message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
--- a/nss_l2tpv2_log.c
+++ b/nss_l2tpv2_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -38,7 +38,7 @@ static int8_t *nss_l2tpv2_log_message_ty
 static void nss_l2tpv2_log_session_create_msg(struct nss_l2tpv2_msg *nlm)
 {
 	struct nss_l2tpv2_session_create_msg *nlcm __maybe_unused = &nlm->msg.session_create_msg;
-	nss_trace("%p: NSS L2TPV2 Session Create message \n"
+	nss_trace("%px: NSS L2TPV2 Session Create message \n"
 		"L2TPV2 Local Tunnel ID: %x\n"
 		"L2TPV2 Local Session ID: %x\n"
 		"L2TPV2 Peer Tunnel ID: %x\n"
@@ -67,7 +67,7 @@ static void nss_l2tpv2_log_session_creat
 static void nss_l2tpv2_log_session_destroy_msg(struct nss_l2tpv2_msg *nlm)
 {
 	struct nss_l2tpv2_session_destroy_msg *nldm __maybe_unused = &nlm->msg.session_destroy_msg;
-	nss_trace("%p: NSS L2TPV2 Session Destroy message \n"
+	nss_trace("%px: NSS L2TPV2 Session Destroy message \n"
 		"L2TPV2 Local Tunnel ID: %x\n"
 		"L2TPV2 Local Session ID: %x\n",
 		nldm, nldm->local_tunnel_id,
@@ -96,7 +96,7 @@ static void nss_l2tpv2_log_verbose(struc
 		break;
 
 	default:
-		nss_trace("%p: Invalid message type\n", nlm);
+		nss_trace("%px: Invalid message type\n", nlm);
 		break;
 	}
 }
@@ -108,11 +108,11 @@ static void nss_l2tpv2_log_verbose(struc
 void nss_l2tpv2_log_tx_msg(struct nss_l2tpv2_msg *nlm)
 {
 	if (nlm->cm.type >= NSS_L2TPV2_MSG_MAX) {
-		nss_warning("%p: Invalid message type\n", nlm);
+		nss_warning("%px: Invalid message type\n", nlm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", nlm, nlm->cm.type, nss_l2tpv2_log_message_types_str[nlm->cm.type]);
+	nss_info("%px: type[%d]:%s\n", nlm, nlm->cm.type, nss_l2tpv2_log_message_types_str[nlm->cm.type]);
 	nss_l2tpv2_log_verbose(nlm);
 }
 
@@ -123,18 +123,18 @@ void nss_l2tpv2_log_tx_msg(struct nss_l2
 void nss_l2tpv2_log_rx_msg(struct nss_l2tpv2_msg *nlm)
 {
 	if (nlm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", nlm);
+		nss_warning("%px: Invalid response\n", nlm);
 		return;
 	}
 
 	if (nlm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (nlm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", nlm, nlm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", nlm, nlm->cm.type,
 			nss_l2tpv2_log_message_types_str[nlm->cm.type],
 			nlm->cm.response, nss_cmn_response_str[nlm->cm.response]);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s\n",
 		nlm, nlm->cm.type, nss_l2tpv2_log_message_types_str[nlm->cm.type],
 		nlm->cm.response, nss_cmn_response_str[nlm->cm.response]);
 
--- a/nss_lag.c
+++ b/nss_lag.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -90,7 +90,7 @@ nss_tx_status_t nss_lag_tx(struct nss_ct
 	nss_lag_verify_ifnum(ncm->interface);
 
 	if (ncm->type > NSS_TX_METADATA_LAG_MAX) {
-		nss_warning("%p: message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
@@ -123,7 +123,6 @@ void *nss_register_lag_if(uint32_t if_nu
 }
 EXPORT_SYMBOL(nss_register_lag_if);
 
-
 /**
  * nss_unregister_lag_if()
  */
@@ -140,7 +139,6 @@ void nss_unregister_lag_if(uint32_t if_n
 }
 EXPORT_SYMBOL(nss_unregister_lag_if);
 
-
 /**
  * nss_lag_handler()
  */
@@ -163,12 +161,12 @@ void nss_lag_handler(struct nss_ctx_inst
 	nss_lag_log_rx_msg(lm);
 
 	if (ncm->type >= NSS_TX_METADATA_LAG_MAX) {
-		nss_warning("%p: received invalid message %d for LAG interface", nss_ctx, ncm->type);
+		nss_warning("%px: received invalid message %d for LAG interface", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_lag_msg)) {
-		nss_warning("%p: invalid length for LAG message: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: invalid length for LAG message: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
@@ -201,7 +199,6 @@ void nss_lag_handler(struct nss_ctx_inst
 	cb(ctx, lm);
 }
 
-
 /**
  * nss_lag_register_handler()
  */
@@ -256,7 +253,7 @@ nss_tx_status_t nss_lag_tx_slave_state(u
 
 	status = nss_lag_tx(nss_ctx, &nm);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: Send LAG update failed, status: %d\n", nss_ctx,
+		nss_warning("%px: Send LAG update failed, status: %d\n", nss_ctx,
 				status);
 		return NSS_TX_FAILURE;
 	}
@@ -267,7 +264,7 @@ nss_tx_status_t nss_lag_tx_slave_state(u
 	ret = wait_for_completion_timeout(&lag_msg_state.complete,
 			msecs_to_jiffies(NSS_LAG_RESP_TIMEOUT));
 	if (!ret) {
-		nss_warning("%p: Waiting for ack timed out\n", nss_ctx);
+		nss_warning("%px: Waiting for ack timed out\n", nss_ctx);
 		return NSS_TX_FAILURE;
 	}
 
--- a/nss_lag_log.c
+++ b/nss_lag_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -36,7 +36,7 @@ static int8_t *nss_lag_log_message_types
 static void nss_lag_log_state_change_msg(struct nss_lag_msg *nlm)
 {
 	struct nss_lag_state_change *nlcm __maybe_unused = &nlm->msg.state;
-	nss_trace("%p: NSS LAG State Change message \n"
+	nss_trace("%px: NSS LAG State Change message \n"
 		"LAG ID: %x\n"
 		"LAG Interface: %x\n"
 		"LAG Event: %d\n",
@@ -54,9 +54,9 @@ static void nss_lag_log_verbose(struct n
 	case NSS_TX_METADATA_LAG_STATE_CHANGE:
 		nss_lag_log_state_change_msg(nlm);
 		break;
-	
+
 	default:
-		nss_trace("%p: Invalid message type\n", nlm);
+		nss_trace("%px: Invalid message type\n", nlm);
 		break;
 	}
 }
@@ -68,11 +68,11 @@ static void nss_lag_log_verbose(struct n
 void nss_lag_log_tx_msg(struct nss_lag_msg *nlm)
 {
 	if (nlm->cm.type >= NSS_TX_METADATA_LAG_MAX) {
-		nss_warning("%p: Invalid message type\n", nlm);
+		nss_warning("%px: Invalid message type\n", nlm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", nlm, nlm->cm.type, nss_lag_log_message_types_str[nlm->cm.type]);
+	nss_info("%px: type[%d]:%s\n", nlm, nlm->cm.type, nss_lag_log_message_types_str[nlm->cm.type]);
 	nss_lag_log_verbose(nlm);
 }
 
@@ -83,18 +83,18 @@ void nss_lag_log_tx_msg(struct nss_lag_m
 void nss_lag_log_rx_msg(struct nss_lag_msg *nlm)
 {
 	if (nlm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", nlm);
+		nss_warning("%px: Invalid response\n", nlm);
 		return;
 	}
 
 	if (nlm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (nlm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", nlm, nlm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", nlm, nlm->cm.type,
 			nss_lag_log_message_types_str[nlm->cm.type],
 			nlm->cm.response, nss_cmn_response_str[nlm->cm.response]);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s\n",
 		nlm, nlm->cm.type, nss_lag_log_message_types_str[nlm->cm.type],
 		nlm->cm.response, nss_cmn_response_str[nlm->cm.response]);
 
--- a/nss_log.c
+++ b/nss_log.c
@@ -108,7 +108,7 @@ static int nss_log_open(struct inode *in
 
 	data = kzalloc(sizeof(struct nss_log_data), GFP_KERNEL);
 	if (!data) {
-		nss_warning("%p: Failed to allocate memory for log_data", nss_ctx);
+		nss_warning("%px: Failed to allocate memory for log_data", nss_ctx);
 		return -ENOMEM;
 	}
 
@@ -116,7 +116,7 @@ static int nss_log_open(struct inode *in
 	if (!nss_rbe[nss_id].addr) {
 		mutex_unlock(&nss_log_mutex);
 		kfree(data);
-		nss_warning("%p: Ring buffer not configured yet for nss_id:%d", nss_ctx, nss_id);
+		nss_warning("%px: Ring buffer not configured yet for nss_id:%d", nss_ctx, nss_id);
 		return -EIO;
 	}
 
@@ -196,7 +196,7 @@ static ssize_t nss_log_read(struct file
 
 	desc = data->load_mem;
 	if (!desc) {
-		nss_warning("%p: load_mem is NULL", data);
+		nss_warning("%px: load_mem is NULL", data);
 		return -EINVAL;
 	}
 
@@ -333,12 +333,12 @@ static void nss_debug_interface_handler(
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type > NSS_DEBUG_INTERFACE_TYPE_MAX) {
-		nss_warning("%p: received invalid message %d for CAPWAP interface", nss_ctx, ncm->type);
+		nss_warning("%px: received invalid message %d for CAPWAP interface", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_log_debug_interface_msg)) {
-		nss_warning("%p: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
@@ -356,7 +356,7 @@ static void nss_debug_interface_handler(
 	 * Do we have a callback
 	 */
 	if (!ncm->cb) {
-		nss_trace("%p: cb is null for interface %d", nss_ctx, ncm->interface);
+		nss_trace("%px: cb is null for interface %d", nss_ctx, ncm->interface);
 		return;
 	}
 
@@ -376,12 +376,12 @@ static nss_tx_status_t nss_debug_interfa
 	 * Sanity check the message
 	 */
 	if (ncm->interface != NSS_DEBUG_INTERFACE) {
-		nss_warning("%p: tx request for another interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: tx request for another interface: %d", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
 	if (ncm->type > NSS_DEBUG_INTERFACE_TYPE_MAX) {
-		nss_warning("%p: message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
@@ -411,21 +411,21 @@ bool nss_debug_log_buffer_alloc(uint8_t
 	nss_ctx = &nss_top->nss[nss_id];
 
 	if (nss_ctx->state != NSS_CORE_STATE_INITIALIZED) {
-		nss_warning("%p: NSS Core:%d is not initialized yet\n", nss_ctx, nss_id);
+		nss_warning("%px: NSS Core:%d is not initialized yet\n", nss_ctx, nss_id);
 		return false;
 	}
 
 	size = sizeof(struct nss_log_descriptor) + (sizeof(struct nss_log_entry) * nentry);
 	addr = kmalloc(size, GFP_ATOMIC);
 	if (!addr) {
-		nss_warning("%p: Failed to allocate memory for logging (size:%d)\n", nss_ctx, size);
+		nss_warning("%px: Failed to allocate memory for logging (size:%d)\n", nss_ctx, size);
 		return false;
 	}
 
 	memset(addr, 0, size);
 	dma_addr = (uint32_t)dma_map_single(nss_ctx->dev, addr, size, DMA_FROM_DEVICE);
 	if (unlikely(dma_mapping_error(nss_ctx->dev, dma_addr))) {
-		nss_warning("%p: Failed to map address in DMA", nss_ctx);
+		nss_warning("%px: Failed to map address in DMA", nss_ctx);
 		kfree(addr);
 		return false;
 	}
@@ -444,7 +444,7 @@ bool nss_debug_log_buffer_alloc(uint8_t
 		 * release the reference.
 		 */
 		if (!wait_event_timeout(nss_log_wq, !nss_rbe[nss_id].ref_cnt, 5 * HZ)) {
-			nss_warning("%p: Timeout waiting for refcnt to become 0\n", nss_ctx);
+			nss_warning("%px: Timeout waiting for refcnt to become 0\n", nss_ctx);
 			goto fail;
 		}
 
@@ -455,7 +455,7 @@ bool nss_debug_log_buffer_alloc(uint8_t
 		}
 		if (nss_rbe[nss_id].ref_cnt > 0) {
 			mutex_unlock(&nss_log_mutex);
-			nss_warning("%p: Some other thread is contending..opting out\n", nss_ctx);
+			nss_warning("%px: Some other thread is contending..opting out\n", nss_ctx);
 			goto fail;
 		}
 	}
@@ -473,7 +473,7 @@ bool nss_debug_log_buffer_alloc(uint8_t
 	status = nss_debug_interface_tx(nss_ctx, &msg);
 	if (status != NSS_TX_SUCCESS) {
 		mutex_unlock(&nss_log_mutex);
-		nss_warning("%p: Failed to send message to debug interface:%d\n", nss_ctx, status);
+		nss_warning("%px: Failed to send message to debug interface:%d\n", nss_ctx, status);
 		goto fail;
 	}
 
@@ -484,13 +484,13 @@ bool nss_debug_log_buffer_alloc(uint8_t
 	 */
 	if (!wait_event_timeout(msg_wq, msg_event, 5 * HZ)) {
 		mutex_unlock(&nss_log_mutex);
-		nss_warning("%p: Timeout send message to debug interface\n", nss_ctx);
+		nss_warning("%px: Timeout send message to debug interface\n", nss_ctx);
 		goto fail;
 	}
 
 	if (msg_response != NSS_CMN_RESPONSE_ACK) {
 		mutex_unlock(&nss_log_mutex);
-		nss_warning("%p: Response error for send message to debug interface:%d\n", nss_ctx, msg_response);
+		nss_warning("%px: Response error for send message to debug interface:%d\n", nss_ctx, msg_response);
 		goto fail;
 	}
 
--- a/nss_lso_rx.c
+++ b/nss_lso_rx.c
@@ -45,7 +45,7 @@ static void nss_rx_lso_rx_interface_hand
 			/*
 			 * Check response
 			 */
-			nss_info("%p: Received response %d for type %d, interface %d", nss_ctx, ncm->response, ncm->type, ncm->interface);
+			nss_info("%px: Received response %d for type %d, interface %d", nss_ctx, ncm->response, ncm->type, ncm->interface);
 		}
 	}
 }
--- a/nss_map_t.c
+++ b/nss_map_t.c
@@ -165,12 +165,12 @@ static void nss_map_t_handler(struct nss
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >= NSS_MAP_T_MSG_MAX) {
-		nss_warning("%p: received invalid message %d for MAP-T interface", nss_ctx, ncm->type);
+		nss_warning("%px: received invalid message %d for MAP-T interface", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_map_t_msg)) {
-		nss_warning("%p: tx request for another interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: tx request for another interface: %d", nss_ctx, ncm->interface);
 		return;
 	}
 
@@ -208,7 +208,7 @@ static void nss_map_t_handler(struct nss
 	 * call map-t callback
 	 */
 	if (!cb) {
-		nss_warning("%p: No callback for map-t interface %d",
+		nss_warning("%px: No callback for map-t interface %d",
 			    nss_ctx, ncm->interface);
 		return;
 	}
@@ -259,12 +259,12 @@ nss_tx_status_t nss_map_t_tx(struct nss_
 	 * Sanity check the message
 	 */
 	if (!nss_map_t_verify_if_num(ncm->interface)) {
-		nss_warning("%p: tx request is not for a MAP-T dynamic interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: tx request is not for a MAP-T dynamic interface: %d", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
 	if (ncm->type > NSS_MAP_T_MSG_MAX) {
-		nss_warning("%p: message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
@@ -290,14 +290,14 @@ nss_tx_status_t nss_map_t_tx_sync(struct
 
 	status = nss_map_t_tx(nss_ctx, msg);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: map_t_tx_msg failed\n", nss_ctx);
+		nss_warning("%px: map_t_tx_msg failed\n", nss_ctx);
 		up(&nss_map_t_pvt.sem);
 		return status;
 	}
 	ret = wait_for_completion_timeout(&nss_map_t_pvt.complete, msecs_to_jiffies(NSS_MAP_T_TX_TIMEOUT));
 
 	if (!ret) {
-		nss_warning("%p: MAP-T tx sync failed due to timeout\n", nss_ctx);
+		nss_warning("%px: MAP-T tx sync failed due to timeout\n", nss_ctx);
 		nss_map_t_pvt.response = NSS_TX_FAILURE;
 	}
 
--- a/nss_map_t_log.c
+++ b/nss_map_t_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -38,7 +38,7 @@ static int8_t *nss_map_t_log_message_typ
 static void nss_map_t_log_rule_configure_msg(struct nss_map_t_msg *ntm)
 {
 	struct nss_map_t_instance_rule_config_msg *ntcm __maybe_unused = &ntm->msg.create_msg;
-	nss_trace("%p: NSS MAP_T Rule Configure message \n"
+	nss_trace("%px: NSS MAP_T Rule Configure message \n"
 		"MAP_T Rule Seq Number: %d\n"
 		"MAP_T Total Number of Rules: %d\n"
 		"MAP_T Local IPv6 Prefix Length: %d\n"
@@ -54,9 +54,9 @@ static void nss_map_t_log_rule_configure
 		"MAP_T Remote PSID Offset: %d\n"
 		"MAP_T Local MAP Style: %d\n"
 		"MAP_T Remote Map Style: %d\n"
-		"MAP_T Local IPv6 Prefix: %p\n"
-		"MAP_T Reserved B: %p\n"
-		"MAP_T Remote IPv6 Prefix: %p\n"
+		"MAP_T Local IPv6 Prefix: %px\n"
+		"MAP_T Reserved B: %px\n"
+		"MAP_T Remote IPv6 Prefix: %px\n"
 		"MAP_T Valid Rule: %d\n",
 		ntcm, ntcm->rule_num, ntcm->total_rules,
 		ntcm->local_ipv6_prefix_len, ntcm->local_ipv4_prefix,
@@ -77,7 +77,7 @@ static void nss_map_t_log_rule_configure
 static void nss_map_t_log_rule_deconfig_msg(struct nss_map_t_msg *ntm)
 {
 	struct nss_map_t_instance_rule_deconfig_msg *ntdm __maybe_unused = &ntm->msg.destroy_msg;
-	nss_trace("%p: NSS MAP_T Rule Deconfigure message \n"
+	nss_trace("%px: NSS MAP_T Rule Deconfigure message \n"
 		"MAP_T Interface Number: %d\n",
 		ntdm, ntdm->if_number);
 }
@@ -104,7 +104,7 @@ static void nss_map_t_log_verbose(struct
 		break;
 
 	default:
-		nss_trace("%p: Invalid message type\n", ntm);
+		nss_trace("%px: Invalid message type\n", ntm);
 		break;
 	}
 }
@@ -116,11 +116,11 @@ static void nss_map_t_log_verbose(struct
 void nss_map_t_log_tx_msg(struct nss_map_t_msg *ntm)
 {
 	if (ntm->cm.type >= NSS_MAP_T_MSG_MAX) {
-		nss_warning("%p: Invalid message type\n", ntm);
+		nss_warning("%px: Invalid message type\n", ntm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", ntm, ntm->cm.type, nss_map_t_log_message_types_str[ntm->cm.type]);
+	nss_info("%px: type[%d]:%s\n", ntm, ntm->cm.type, nss_map_t_log_message_types_str[ntm->cm.type]);
 	nss_map_t_log_verbose(ntm);
 }
 
@@ -131,18 +131,18 @@ void nss_map_t_log_tx_msg(struct nss_map
 void nss_map_t_log_rx_msg(struct nss_map_t_msg *ntm)
 {
 	if (ntm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", ntm);
+		nss_warning("%px: Invalid response\n", ntm);
 		return;
 	}
 
 	if (ntm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (ntm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", ntm, ntm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", ntm, ntm->cm.type,
 			nss_map_t_log_message_types_str[ntm->cm.type],
 			ntm->cm.response, nss_cmn_response_str[ntm->cm.response]);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s\n",
 		ntm, ntm->cm.type, nss_map_t_log_message_types_str[ntm->cm.type],
 		ntm->cm.response, nss_cmn_response_str[ntm->cm.response]);
 
--- a/nss_match.c
+++ b/nss_match.c
@@ -96,12 +96,12 @@ static nss_tx_status_t nss_match_msg_tx(
 	 * Sanity check the message
 	 */
 	if (!nss_match_verify_if_num(ncm->interface)) {
-		nss_warning("%p: Tx request for non dynamic interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: Tx request for non dynamic interface: %d", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
 	if (ncm->type > NSS_MATCH_MSG_MAX) {
-		nss_warning("%p: Message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: Message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
@@ -131,12 +131,12 @@ static void nss_match_handler(struct nss
 	 * Is this a valid request/response packet?
 	 */
 	if (nem->cm.type >= NSS_MATCH_MSG_MAX) {
-		nss_warning("%p: Received invalid message %d for MATCH interface", nss_ctx, nem->cm.type);
+		nss_warning("%px: Received invalid message %d for MATCH interface", nss_ctx, nem->cm.type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_match_msg)) {
-		nss_warning("%p: Unexpected message length: %d, on interface: %d",
+		nss_warning("%px: Unexpected message length: %d, on interface: %d",
 				nss_ctx, nss_cmn_get_msg_len(ncm), ncm->interface);
 		return;
 	}
@@ -151,7 +151,7 @@ static void nss_match_handler(struct nss
 	}
 
 	if (ncm->response == NSS_CMN_RESPONSE_NOTIFY) {
-		ncm->cb = (nss_ptr_t)nss_ctx->nss_top->if_rx_msg_callback[ncm->interface];
+		ncm->cb = (nss_ptr_t)nss_core_get_msg_handler(nss_ctx, ncm->interface);
 	}
 
 	/*
@@ -190,14 +190,14 @@ nss_tx_status_t nss_match_msg_tx_sync(st
 
 	status = nss_match_msg_tx(nss_ctx, matchm);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: nss_match_msg_tx failed\n", nss_ctx);
+		nss_warning("%px: nss_match_msg_tx failed\n", nss_ctx);
 		up(&match_pvt.sem);
 		return status;
 	}
 
 	ret = wait_for_completion_timeout(&match_pvt.complete, msecs_to_jiffies(NSS_MATCH_TX_TIMEOUT));
 	if (!ret) {
-		nss_warning("%p: MATCH tx failed due to timeout\n", nss_ctx);
+		nss_warning("%px: MATCH tx failed due to timeout\n", nss_ctx);
 		match_pvt.response = NSS_TX_FAILURE;
 	}
 
@@ -215,22 +215,27 @@ EXPORT_SYMBOL(nss_match_msg_tx_sync);
 struct nss_ctx_instance *nss_match_register_instance(int if_num, nss_match_msg_sync_callback_t notify_cb)
 {
 	struct nss_ctx_instance *nss_ctx;
+	uint32_t status;
 
 	nss_ctx = nss_match_get_context();
 	NSS_VERIFY_CTX_MAGIC(nss_ctx);
 
 	if (!nss_match_verify_if_num(if_num)) {
-		nss_warning("%p: Incorrect interface number: %d", nss_ctx, if_num);
+		nss_warning("%px: Incorrect interface number: %d", nss_ctx, if_num);
 		return NULL;
 	}
 
 	nss_core_register_handler(nss_ctx, if_num, nss_match_handler, NULL);
-	nss_top_main.if_rx_msg_callback[if_num] = (nss_if_rx_msg_callback_t)notify_cb;
+	status = nss_core_register_msg_handler(nss_ctx, if_num, (nss_if_rx_msg_callback_t)notify_cb);
+	if (status != NSS_CORE_STATUS_SUCCESS) {
+		nss_warning("%px: Not able to register handler for interface %d with NSS core\n", nss_ctx, if_num);
+		return NULL;
+	}
 
 	if (!nss_match_ifnum_add(if_num)) {
-		nss_warning("Unable to add match inteface : %u\n", if_num);
+		nss_warning("%px: Unable to add match inteface : %u\n", nss_ctx, if_num);
 		nss_core_unregister_handler(nss_ctx, if_num);
-		nss_top_main.if_rx_msg_callback[if_num] = NULL;
+		nss_core_unregister_msg_handler(nss_ctx, if_num);
 		return NULL;
 	}
 
@@ -245,17 +250,23 @@ EXPORT_SYMBOL(nss_match_register_instanc
 bool nss_match_unregister_instance(int if_num)
 {
 	struct nss_ctx_instance *nss_ctx;
+	uint32_t status;
 
 	nss_ctx = nss_match_get_context();
 	NSS_VERIFY_CTX_MAGIC(nss_ctx);
 
 	if (!nss_match_verify_if_num(if_num)) {
-		nss_warning("%p: Incorrect interface number: %d", nss_ctx, if_num);
+		nss_warning("%px: Incorrect interface number: %d", nss_ctx, if_num);
 		return false;
 	}
 
 	nss_core_unregister_handler(nss_ctx, if_num);
-	nss_top_main.if_rx_msg_callback[if_num] = NULL;
+	status = nss_core_unregister_msg_handler(nss_ctx, if_num);
+	if (status != NSS_CORE_STATUS_SUCCESS) {
+		nss_warning("%px: Not able to unregister handler for interface %d with NSS core\n", nss_ctx, if_num);
+		return false;
+	}
+
 	nss_match_ifnum_delete(if_num);
 
 	return true;
--- a/nss_match_log.c
+++ b/nss_match_log.c
@@ -72,7 +72,7 @@ static void nss_match_log_profile_config
 	struct nss_match_profile_configure_msg *nmcm __maybe_unused = &nmm->msg.configure_msg;
 	int mask_num, mask_word;
 
-	nss_trace("%p: NSS match configuration message \n"
+	nss_trace("%px: NSS match configuration message \n"
 			"Match profile type: %u \n"
 			"Match mask flag: %u \n",
 			nmcm,
@@ -94,7 +94,7 @@ static void nss_match_log_profile_config
 static void nss_match_log_vow_rule_msg(struct nss_match_msg *nmm)
 {
 	struct nss_match_rule_vow_msg *nmvrm __maybe_unused = &nmm->msg.vow_rule;
-	nss_trace("%p: NSS match VoW rule message \n"
+	nss_trace("%px: NSS match VoW rule message \n"
 			"Match rule id: %hu \n"
 			"Match mask id: %hu \n"
 			"Match action: action flag = %u, next node = %u, priority = %hu \n"
@@ -119,7 +119,7 @@ static void nss_match_log_vow_rule_msg(s
 static void nss_match_log_l2_rule_msg(struct nss_match_msg *nmm)
 {
 	struct nss_match_rule_l2_msg *nmlrm __maybe_unused = &nmm->msg.l2_rule;
-	nss_trace("%p: NSS match L2 rule message \n"
+	nss_trace("%px: NSS match L2 rule message \n"
 			"Match rule id: %hu \n"
 			"Match mask id: %hu \n"
 			"Match action: action flag = %u, next node = %u, priority = %hu \n"
@@ -169,7 +169,7 @@ static void nss_match_log_verbose(struct
 		break;
 
 	default:
-		nss_trace("%p: Invalid message type\n", nmm);
+		nss_trace("%px: Invalid message type\n", nmm);
 		break;
 	}
 }
@@ -181,11 +181,11 @@ static void nss_match_log_verbose(struct
 void nss_match_log_tx_msg(struct nss_match_msg *nmm)
 {
 	if (nmm->cm.type >= NSS_MATCH_MSG_MAX) {
-		nss_warning("%p: Invalid message type\n", nmm);
+		nss_warning("%px: Invalid message type\n", nmm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", nmm, nmm->cm.type, nss_match_log_message_types_str[nmm->cm.type]);
+	nss_info("%px: type[%d]:%s\n", nmm, nmm->cm.type, nss_match_log_message_types_str[nmm->cm.type]);
 	nss_match_log_verbose(nmm);
 }
 
@@ -196,26 +196,26 @@ void nss_match_log_tx_msg(struct nss_mat
 void nss_match_log_rx_msg(struct nss_match_msg *nmm)
 {
 	if (nmm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", nmm);
+		nss_warning("%px: Invalid response\n", nmm);
 		return;
 	}
 
 	if (nmm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (nmm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", nmm, nmm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", nmm, nmm->cm.type,
 			nss_match_log_message_types_str[nmm->cm.type],
 			nmm->cm.response, nss_cmn_response_str[nmm->cm.response]);
 		goto verbose;
 	}
 
 	if (nmm->cm.error >= NSS_MATCH_ERROR_MAX) {
-		nss_warning("%p: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
+		nss_warning("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
 			nmm, nmm->cm.type, nss_match_log_message_types_str[nmm->cm.type],
 			nmm->cm.response, nss_cmn_response_str[nmm->cm.response],
 			nmm->cm.error);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
 		nmm, nmm->cm.type, nss_match_log_message_types_str[nmm->cm.type],
 		nmm->cm.response, nss_cmn_response_str[nmm->cm.response],
 		nmm->cm.error, nss_match_log_error_types_str[nmm->cm.error]);
--- a/nss_meminfo.c
+++ b/nss_meminfo.c
@@ -53,7 +53,7 @@ static void *nss_meminfo_alloc_sdram(str
 	 */
 	addr = kmalloc(size, GFP_KERNEL | __GFP_ZERO);
 	if (!addr)
-		nss_info_always("%p: failed to alloc a sdram block of size %u\n", nss_ctx, size);
+		nss_info_always("%px: failed to alloc a sdram block of size %u\n", nss_ctx, size);
 
 	kmemleak_not_leak((void *)addr);
 	return addr;
@@ -100,7 +100,7 @@ static uint32_t nss_meminfo_alloc_imem(s
 		new_tail = (new_tail + mask) & ~mask;
 
 	if (size > (mem_ctx->imem_end - new_tail)) {
-		nss_info_always("%p: failed to alloc an IMEM block of size %u\n", nss_ctx, size);
+		nss_info_always("%px: failed to alloc an IMEM block of size %u\n", nss_ctx, size);
 		return addr;
 	}
 
@@ -147,7 +147,7 @@ static uint32_t nss_meminfo_alloc_utcm_s
 		new_tail = (new_tail + mask) & ~mask;
 
 	if (size > (mem_ctx->utcm_shared_end - new_tail)) {
-		nss_info_always("%p: failed to alloc an UTCM_SHARED block of size %u\n", nss_ctx, size);
+		nss_info_always("%px: failed to alloc an UTCM_SHARED block of size %u\n", nss_ctx, size);
 		return addr;
 	}
 
@@ -292,7 +292,7 @@ static bool nss_meminfo_init_block_lists
 		struct nss_meminfo_block *b = (struct nss_meminfo_block *)
 						kmalloc(sizeof(struct nss_meminfo_block), GFP_KERNEL);
 		if (!b) {
-			nss_info_always("%p: failed to allocate meminfo block\n", nss_ctx);
+			nss_info_always("%px: failed to allocate meminfo block\n", nss_ctx);
 			goto cleanup;
 		}
 
@@ -315,7 +315,7 @@ static bool nss_meminfo_init_block_lists
 			 */
 			dma_addr = nss_meminfo_alloc_imem(nss_ctx, r->size, r->alignment);
 			if (!dma_addr) {
-				nss_info_always("%p: failed to alloc IMEM block\n", nss_ctx);
+				nss_info_always("%px: failed to alloc IMEM block\n", nss_ctx);
 				goto cleanup;
 			}
 
@@ -328,13 +328,13 @@ static bool nss_meminfo_init_block_lists
 		case NSS_MEMINFO_MEMTYPE_SDRAM:
 			kern_addr = nss_meminfo_alloc_sdram(nss_ctx, r->size);
 			if (!kern_addr) {
-				nss_info_always("%p: failed to alloc SDRAM block\n", nss_ctx);
+				nss_info_always("%px: failed to alloc SDRAM block\n", nss_ctx);
 				goto cleanup;
 			}
 
 			dma_addr = dma_map_single(nss_ctx->dev, kern_addr, r->size, DMA_TO_DEVICE);
 			if (unlikely(dma_mapping_error(nss_ctx->dev, dma_addr))) {
-				nss_info_always("%p: failed to map SDRAM block\n", nss_ctx);
+				nss_info_always("%px: failed to map SDRAM block\n", nss_ctx);
 				goto cleanup;
 			}
 			break;
@@ -344,7 +344,7 @@ static bool nss_meminfo_init_block_lists
 			 */
 			dma_addr = nss_meminfo_alloc_utcm_shared(nss_ctx, r->size, r->alignment);
 			if (!dma_addr) {
-				nss_info_always("%p: failed to alloc UTCM_SHARED block\n", nss_ctx);
+				nss_info_always("%px: failed to alloc UTCM_SHARED block\n", nss_ctx);
 				goto cleanup;
 			}
 			break;
@@ -361,12 +361,12 @@ static bool nss_meminfo_init_block_lists
 				 */
 				r->size /= coreinfo.num_active_cores;
 				dma_addr = coreinfo.start_address + nss_ctx->id * r->size;
-				nss_info_always("%p: NSS core %d DDR from %x to %x\n", nss_ctx,
+				nss_info_always("%px: NSS core %d DDR from %x to %x\n", nss_ctx,
 						nss_ctx->id, dma_addr, dma_addr + r->size);
 			}
 			break;
 		default:
-			nss_info_always("%p: %d unsupported memory type\n", nss_ctx, mtype);
+			nss_info_always("%px: %d unsupported memory type\n", nss_ctx, mtype);
 			goto cleanup;
 		}
 
@@ -399,7 +399,7 @@ static bool nss_meminfo_init_block_lists
 
 		if (strcmp(r->name, "profile_dma_ctrl") == 0) {
 			mem_ctx->sdma_ctrl = kern_addr;
-		nss_info_always("%p: set sdma %p\n", nss_ctx, kern_addr);
+		nss_info_always("%px: set sdma %px\n", nss_ctx, kern_addr);
 		}
 
 		/*
@@ -504,7 +504,7 @@ static bool nss_meminfo_configure_n2h_h2
 	 * N2H ring allocations
 	 */
 	if (!(nss_meminfo_allocate_n2h_h2n_rings(nss_ctx, n2h_info))) {
-		nss_info_always("%p: failed to allocate/map n2h rings\n", nss_ctx);
+		nss_info_always("%px: failed to allocate/map n2h rings\n", nss_ctx);
 		return false;
 	}
 
@@ -512,7 +512,7 @@ static bool nss_meminfo_configure_n2h_h2
 	 * H2N ring allocations
 	 */
 	if (!(nss_meminfo_allocate_n2h_h2n_rings(nss_ctx, h2n_info))) {
-		nss_info_always("%p: failed to allocate/map h2n_rings\n", nss_ctx);
+		nss_info_always("%px: failed to allocate/map h2n_rings\n", nss_ctx);
 		goto cleanup;
 	}
 
@@ -537,7 +537,7 @@ static bool nss_meminfo_configure_n2h_h2
 
 		if_map->n2h_desc_if[i].size = NSS_RING_SIZE;
 		if_map->n2h_desc_if[i].desc_addr = n2h_info->dma_addr + i * sizeof(struct n2h_descriptor) * (NSS_RING_SIZE + 2);
-		nss_info("%p: N2H ring %d, size %d, addr = %x\n", nss_ctx, i, if_map->n2h_desc_if[i].size, if_map->n2h_desc_if[i].desc_addr);
+		nss_info("%px: N2H ring %d, size %d, addr = %x\n", nss_ctx, i, if_map->n2h_desc_if[i].size, if_map->n2h_desc_if[i].desc_addr);
 	}
 
 	/*
@@ -552,7 +552,7 @@ static bool nss_meminfo_configure_n2h_h2
 
 		if_map->h2n_desc_if[i].size = NSS_RING_SIZE;
 		if_map->h2n_desc_if[i].desc_addr = h2n_info->dma_addr + i * sizeof(struct h2n_descriptor) * (NSS_RING_SIZE + 2);
-		nss_info("%p: H2N ring %d, size %d, addr = %x\n", nss_ctx, i, if_map->h2n_desc_if[i].size, if_map->h2n_desc_if[i].desc_addr);
+		nss_info("%px: H2N ring %d, size %d, addr = %x\n", nss_ctx, i, if_map->h2n_desc_if[i].size, if_map->h2n_desc_if[i].desc_addr);
 	}
 
 	/*
@@ -714,7 +714,7 @@ bool nss_meminfo_init(struct nss_ctx_ins
 	meminfo_start = (uint32_t *)ioremap(nss_ctx->load + NSS_MEMINFO_MAP_START_OFFSET,
 							NSS_MEMINFO_RESERVE_AREA_SIZE);
 	if (!meminfo_start) {
-		nss_info_always("%p: cannot remap meminfo start\n", nss_ctx);
+		nss_info_always("%px: cannot remap meminfo start\n", nss_ctx);
 		return false;
 	}
 
@@ -722,14 +722,14 @@ bool nss_meminfo_init(struct nss_ctx_ins
 	 * Check meminfo start magic
 	 */
 	if ((uint16_t)meminfo_start[0] != NSS_MEMINFO_RESERVE_AREA_MAGIC) {
-		nss_info_always("%p: failed to verify meminfo start magic\n", nss_ctx);
+		nss_info_always("%px: failed to verify meminfo start magic\n", nss_ctx);
 		return false;
 	}
 
 	map = &mem_ctx->meminfo_map;
 	map->start = (uint32_t *)ioremap_cache(meminfo_start[1], NSS_MEMINFO_MAP_SIZE);
 	if (!map->start) {
-		nss_info_always("%p: failed to remap meminfo map\n", nss_ctx);
+		nss_info_always("%px: failed to remap meminfo map\n", nss_ctx);
 		return false;
 	}
 
@@ -737,7 +737,7 @@ bool nss_meminfo_init(struct nss_ctx_ins
 	 * Check meminfo map magic
 	 */
 	if ((uint16_t)map->start[0] != NSS_MEMINFO_MAP_START_MAGIC) {
-		nss_info_always("%p: failed to verify meminfo map magic\n", nss_ctx);
+		nss_info_always("%px: failed to verify meminfo map magic\n", nss_ctx);
 		return false;
 	}
 
@@ -756,7 +756,7 @@ bool nss_meminfo_init(struct nss_ctx_ins
 	 * Init UTCM_SHARED if supported
 	 */
 	if (!nss_top->hal_ops->init_utcm_shared(nss_ctx, meminfo_start)) {
-		nss_info_always("%p: failed to initialize UTCM_SHARED meminfo\n", nss_ctx);
+		nss_info_always("%px: failed to initialize UTCM_SHARED meminfo\n", nss_ctx);
 		return false;
 	}
 
@@ -764,7 +764,7 @@ bool nss_meminfo_init(struct nss_ctx_ins
 	 * Init meminfo block lists
 	 */
 	if (!nss_meminfo_init_block_lists(nss_ctx)) {
-		nss_info_always("%p: failed to initialize meminfo block lists\n", nss_ctx);
+		nss_info_always("%px: failed to initialize meminfo block lists\n", nss_ctx);
 		return false;
 	}
 
@@ -776,6 +776,6 @@ bool nss_meminfo_init(struct nss_ctx_ins
 
 	nss_meminfo_init_debugfs(nss_ctx);
 
-	nss_info_always("%p: meminfo init succeed\n", nss_ctx);
+	nss_info_always("%px: meminfo init succeed\n", nss_ctx);
 	return true;
 }
--- a/nss_mirror.c
+++ b/nss_mirror.c
@@ -68,12 +68,12 @@ static void nss_mirror_handler(struct ns
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >= NSS_MIRROR_MSG_MAX) {
-		nss_warning("%p: received invalid message %d for mirror interface", nss_ctx, ncm->type);
+		nss_warning("%px: received invalid message %d for mirror interface", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_mirror_msg)) {
-		nss_warning("%p: Length of message is greater than expected.", nss_ctx);
+		nss_warning("%px: Length of message is greater than expected.", nss_ctx);
 		return;
 	}
 
@@ -96,7 +96,7 @@ static void nss_mirror_handler(struct ns
 	 * Update the callback and app_data for NOTIFY messages.
 	 */
 	if (ncm->response == NSS_CMN_RESPONSE_NOTIFY) {
-		ncm->cb = (nss_ptr_t)nss_top_main.if_rx_msg_callback[ncm->interface];
+		ncm->cb = (nss_ptr_t)nss_core_get_msg_handler(nss_ctx, ncm->interface);
 		ncm->app_data = (nss_ptr_t)app_data;
 	}
 
@@ -110,7 +110,7 @@ static void nss_mirror_handler(struct ns
 	 * Call mirror interface callback.
 	 */
 	if (!cb) {
-		nss_warning("%p: No callback for mirror interface %d",
+		nss_warning("%px: No callback for mirror interface %d",
 			    nss_ctx, ncm->interface);
 		return;
 	}
@@ -150,12 +150,12 @@ nss_tx_status_t nss_mirror_tx_msg(struct
 	 * Sanity check the message.
 	 */
 	if (!nss_mirror_verify_if_num(ncm->interface)) {
-		nss_warning("%p: tx request for non mirror interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: tx request for non mirror interface: %d", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
 	if (ncm->type > NSS_MIRROR_MSG_MAX) {
-		nss_warning("%p: message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
@@ -183,14 +183,14 @@ nss_tx_status_t nss_mirror_tx_msg_sync(s
 
 	status = nss_mirror_tx_msg(nss_ctx, msg);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: mirror_tx_msg failed\n", nss_ctx);
+		nss_warning("%px: mirror_tx_msg failed\n", nss_ctx);
 		up(&nss_mirror_pvt.sem);
 		return status;
 	}
 
 	ret = wait_for_completion_timeout(&nss_mirror_pvt.complete, msecs_to_jiffies(NSS_MIRROR_TX_TIMEOUT));
 	if (!ret) {
-		nss_warning("%p: Mirror interface tx sync failed due to timeout\n", nss_ctx);
+		nss_warning("%px: Mirror interface tx sync failed due to timeout\n", nss_ctx);
 		nss_mirror_pvt.response = NSS_TX_FAILURE;
 	}
 
@@ -207,16 +207,20 @@ EXPORT_SYMBOL(nss_mirror_tx_msg_sync);
 void nss_mirror_unregister_if(uint32_t if_num)
 {
 	struct nss_ctx_instance *nss_ctx = (struct nss_ctx_instance *)&nss_top_main.nss[nss_top_main.mirror_handler_id];
+	uint32_t status;
 
 	nss_assert(nss_ctx);
 	nss_assert(nss_mirror_verify_if_num(if_num));
 
 	nss_core_unregister_subsys_dp(nss_ctx, if_num);
 
-	nss_top_main.if_rx_msg_callback[if_num] = NULL;
-
 	nss_core_unregister_handler(nss_ctx, if_num);
 
+	status = nss_core_unregister_msg_handler(nss_ctx, if_num);
+	if (status != NSS_CORE_STATUS_SUCCESS) {
+		nss_warning("%px: Not able to unregister handler for interface %d with NSS core\n", nss_ctx, if_num);
+	}
+
 	atomic_dec(&nss_mirror_num_instances);
 	nss_mirror_stats_reset(if_num);
 }
@@ -239,23 +243,27 @@ struct nss_ctx_instance *nss_mirror_regi
 	nss_assert(nss_mirror_verify_if_num(if_num));
 
 	if (atomic_read(&nss_mirror_num_instances) == NSS_MAX_MIRROR_DYNAMIC_INTERFACES) {
-		nss_warning("%p: Maximum number of mirror interfaces are already allocated\n", nss_ctx);
+		nss_warning("%px: Maximum number of mirror interfaces are already allocated\n", nss_ctx);
 		return NULL;
 	}
 
 	ret = nss_mirror_stats_init(if_num, netdev);
 	if (ret < 0) {
-		nss_warning("%p: Error in initializaing mirror stats.\n", nss_ctx);
+		nss_warning("%px: Error in initializaing mirror stats.\n", nss_ctx);
+		return NULL;
+	}
+
+	nss_core_register_handler(nss_ctx, if_num, nss_mirror_handler, netdev);
+	ret = nss_core_register_msg_handler(nss_ctx, if_num, event_callback);
+	if (ret != NSS_CORE_STATUS_SUCCESS) {
+		nss_core_unregister_handler(nss_ctx, if_num);
+		nss_warning("%px: Not able to register handler for mirror interface %d with NSS core\n", nss_ctx, if_num);
 		return NULL;
 	}
 
 	nss_core_register_subsys_dp(nss_ctx, if_num, data_callback, NULL, NULL, netdev, features);
 	nss_core_set_subsys_dp_type(nss_ctx, netdev, if_num, NSS_DYNAMIC_INTERFACE_TYPE_MIRROR);
 
-	nss_top_main.if_rx_msg_callback[if_num] = event_callback;
-
-	nss_core_register_handler(nss_ctx, if_num, nss_mirror_handler, netdev);
-
 	atomic_inc(&nss_mirror_num_instances);
 	return nss_ctx;
 }
--- a/nss_mirror_log.c
+++ b/nss_mirror_log.c
@@ -62,7 +62,7 @@ static void nss_mirror_log_configure_msg
 {
 	struct nss_mirror_configure_msg *config_msg __maybe_unused = &nmm->msg.config;
 
-	nss_trace("%p: NSS Mirror Config message \n"
+	nss_trace("%px: NSS Mirror Config message \n"
 		"Packet clone size: %u\n"
 		"Packet clone point: %hu\n",
 		config_msg,
@@ -78,7 +78,7 @@ static void nss_mirror_log_set_nexthop_m
 {
 	struct nss_mirror_set_nexthop_msg *nexthop_msg __maybe_unused = &nmm->msg.nexthop;
 
-	nss_trace("%p: NSS Mirror Nexthop message \n"
+	nss_trace("%px: NSS Mirror Nexthop message \n"
 		"Nexthop interface number: %u\n",
 		nexthop_msg,
 		nexthop_msg->if_num);
@@ -90,7 +90,7 @@ static void nss_mirror_log_set_nexthop_m
  */
 static void nss_mirror_log_enable_msg(struct nss_mirror_msg *nmm)
 {
-	nss_trace("%p: NSS Mirror message: Enable \n", nmm);
+	nss_trace("%px: NSS Mirror message: Enable \n", nmm);
 }
 
 /*
@@ -99,7 +99,7 @@ static void nss_mirror_log_enable_msg(st
  */
 static void nss_mirror_log_disable_msg(struct nss_mirror_msg *nmm)
 {
-	nss_trace("%p: NSS Mirror message: Disable \n", nmm);
+	nss_trace("%px: NSS Mirror message: Disable \n", nmm);
 }
 
 /*
@@ -108,7 +108,7 @@ static void nss_mirror_log_disable_msg(s
  */
 static void nss_mirror_log_reset_nexthop_msg(struct nss_mirror_msg *nmm)
 {
-	nss_trace("%p: NSS Mirror message: Reset Nexthop \n", nmm);
+	nss_trace("%px: NSS Mirror message: Reset Nexthop \n", nmm);
 }
 
 /*
@@ -142,7 +142,7 @@ static void nss_mirror_log_verbose(struc
 		break;
 
 	default:
-		nss_trace("%p: Invalid message type\n", nmm);
+		nss_trace("%px: Invalid message type\n", nmm);
 		break;
 	}
 }
@@ -154,11 +154,11 @@ static void nss_mirror_log_verbose(struc
 void nss_mirror_log_tx_msg(struct nss_mirror_msg *nmm)
 {
 	if (nmm->cm.type >= NSS_MIRROR_MSG_MAX) {
-		nss_warning("%p: Invalid message type\n", nmm);
+		nss_warning("%px: Invalid message type\n", nmm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", nmm, nmm->cm.type, nss_mirror_log_message_types_str[nmm->cm.type]);
+	nss_info("%px: type[%d]:%s\n", nmm, nmm->cm.type, nss_mirror_log_message_types_str[nmm->cm.type]);
 	nss_mirror_log_verbose(nmm);
 }
 
@@ -169,26 +169,26 @@ void nss_mirror_log_tx_msg(struct nss_mi
 void nss_mirror_log_rx_msg(struct nss_mirror_msg *nmm)
 {
 	if (nmm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", nmm);
+		nss_warning("%px: Invalid response\n", nmm);
 		return;
 	}
 
 	if (nmm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (nmm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", nmm, nmm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", nmm, nmm->cm.type,
 			nss_mirror_log_message_types_str[nmm->cm.type],
 			nmm->cm.response, nss_cmn_response_str[nmm->cm.response]);
 		goto verbose;
 	}
 
 	if (nmm->cm.error >= NSS_MIRROR_ERROR_TYPE_MAX) {
-		nss_warning("%p: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
+		nss_warning("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
 			nmm, nmm->cm.type, nss_mirror_log_message_types_str[nmm->cm.type],
 			nmm->cm.response, nss_cmn_response_str[nmm->cm.response],
 			nmm->cm.error);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
 		nmm, nmm->cm.type, nss_mirror_log_message_types_str[nmm->cm.type],
 		nmm->cm.response, nss_cmn_response_str[nmm->cm.response],
 		nmm->cm.error, nss_mirror_log_error_response_types_str[nmm->cm.error]);
--- a/nss_n2h.c
+++ b/nss_n2h.c
@@ -74,7 +74,7 @@ static void nss_n2h_interface_handler(st
 	 * Is this a valid request/response packet?
 	 */
 	if (nnm->cm.type >= NSS_METADATA_TYPE_N2H_MAX) {
-		nss_warning("%p: received invalid message %d for Offload stats interface", nss_ctx, nnm->cm.type);
+		nss_warning("%px: received invalid message %d for Offload stats interface", nss_ctx, nnm->cm.type);
 		return;
 	}
 
@@ -88,11 +88,11 @@ static void nss_n2h_interface_handler(st
 		break;
 
 	case NSS_TX_METADATA_TYPE_N2H_EMPTY_POOL_BUF_CFG:
-		nss_info("%p: empty pool buf cfg response from FW", nss_ctx);
+		nss_info("%px: empty pool buf cfg response from FW", nss_ctx);
 		break;
 
 	case NSS_TX_METADATA_TYPE_N2H_FLUSH_PAYLOADS:
-		nss_info("%p: flush payloads cmd response from FW", nss_ctx);
+		nss_info("%px: flush payloads cmd response from FW", nss_ctx);
 		break;
 
 	case NSS_RX_METADATA_TYPE_N2H_STATS_SYNC:
@@ -108,7 +108,7 @@ static void nss_n2h_interface_handler(st
 			/*
 			 * Check response
 			 */
-			nss_info("%p: Received response %d for type %d, interface %d",
+			nss_info("%px: Received response %d for type %d, interface %d",
 						nss_ctx, ncm->response, ncm->type, ncm->interface);
 		}
 	}
@@ -252,12 +252,12 @@ static void nss_n2h_set_wifi_payloads_ca
 
 		nss_n2h_wp.response = NSS_FAILURE;
 		complete(&nss_n2h_wp.complete);
-		nss_warning("%p: wifi pool configuration failed : %d\n", nss_ctx,
+		nss_warning("%px: wifi pool configuration failed : %d\n", nss_ctx,
 				nnm->cm.error);
 		return;
 	}
 
-	nss_info("%p: wifi payload configuration succeeded: %d\n", nss_ctx,
+	nss_info("%px: wifi payload configuration succeeded: %d\n", nss_ctx,
 			nnm->cm.error);
 	nss_n2h_wp.response = NSS_SUCCESS;
 	nss_n2h_wp.wifi_pool = ntohl(nnm->msg.wp.payloads);
@@ -282,7 +282,7 @@ static int nss_n2h_get_payload_info(nss_
 	nss_tx_status = nss_n2h_tx_msg(nss_ctx, nnm);
 
 	if (nss_tx_status != NSS_TX_SUCCESS) {
-		nss_warning("%p: core %d nss_tx error errorn", nss_ctx, (int)core_num);
+		nss_warning("%px: core %d nss_tx error errorn", nss_ctx, (int)core_num);
 		return NSS_FAILURE;
 	}
 
@@ -292,12 +292,12 @@ static int nss_n2h_get_payload_info(nss_
 	ret = wait_for_completion_timeout(&nss_n2h_nepbcfgp[core_num].complete,
 			msecs_to_jiffies(NSS_CONN_CFG_TIMEOUT));
 	if (ret == 0) {
-		nss_warning("%p: core %d waiting for ack timed out\n", nss_ctx, (int)core_num);
+		nss_warning("%px: core %d waiting for ack timed out\n", nss_ctx, (int)core_num);
 		return NSS_FAILURE;
 	}
 
 	if (NSS_FAILURE == nss_n2h_nepbcfgp[core_num].response) {
-		nss_warning("%p: core %d response returned failure\n", nss_ctx, (int)core_num);
+		nss_warning("%px: core %d response returned failure\n", nss_ctx, (int)core_num);
 		return NSS_FAILURE;
 	}
 
@@ -387,12 +387,12 @@ static int nss_n2h_set_empty_buf_pool(st
 	}
 
 	if ((*new_val < NSS_N2H_MIN_EMPTY_POOL_BUF_SZ)) {
-		nss_warning("%p: core %d setting %d < min number of buffer",
+		nss_warning("%px: core %d setting %d < min number of buffer",
 				nss_ctx, (int)core_num, *new_val);
 		goto failure;
 	}
 
-	nss_info("%p: core %d number of empty pool buffer is : %d\n",
+	nss_info("%px: core %d number of empty pool buffer is : %d\n",
 		nss_ctx, (int)core_num, *new_val);
 
 	nss_n2h_msg_init(&nnm, NSS_N2H_INTERFACE,
@@ -406,7 +406,7 @@ static int nss_n2h_set_empty_buf_pool(st
 	nss_tx_status = nss_n2h_tx_msg(nss_ctx, &nnm);
 
 	if (nss_tx_status != NSS_TX_SUCCESS) {
-		nss_warning("%p: core %d nss_tx error empty pool buffer: %d\n",
+		nss_warning("%px: core %d nss_tx error empty pool buffer: %d\n",
 				nss_ctx, (int)core_num, *new_val);
 		goto failure;
 	}
@@ -417,7 +417,7 @@ static int nss_n2h_set_empty_buf_pool(st
 	ret = wait_for_completion_timeout(&nss_n2h_nepbcfgp[core_num].complete,
 			msecs_to_jiffies(NSS_CONN_CFG_TIMEOUT));
 	if (ret == 0) {
-		nss_warning("%p: core %d Waiting for ack timed out\n", nss_ctx, (int)core_num);
+		nss_warning("%px: core %d Waiting for ack timed out\n", nss_ctx, (int)core_num);
 		goto failure;
 	}
 
@@ -489,12 +489,12 @@ static int nss_n2h_set_empty_paged_pool_
 	}
 
 	if ((*new_val < NSS_N2H_MIN_EMPTY_POOL_BUF_SZ)) {
-		nss_warning("%p: core %d setting %d < min number of buffer",
+		nss_warning("%px: core %d setting %d < min number of buffer",
 				nss_ctx, (int)core_num, *new_val);
 		goto failure;
 	}
 
-	nss_info("%p: core %d number of empty paged pool buffer is : %d\n",
+	nss_info("%px: core %d number of empty paged pool buffer is : %d\n",
 		nss_ctx, (int)core_num, *new_val);
 
 	nss_n2h_msg_init(&nnm, NSS_N2H_INTERFACE,
@@ -508,7 +508,7 @@ static int nss_n2h_set_empty_paged_pool_
 	nss_tx_status = nss_n2h_tx_msg(nss_ctx, &nnm);
 
 	if (nss_tx_status != NSS_TX_SUCCESS) {
-		nss_warning("%p: core %d nss_tx error empty paged pool buffer: %d\n",
+		nss_warning("%px: core %d nss_tx error empty paged pool buffer: %d\n",
 				nss_ctx, (int)core_num, *new_val);
 		goto failure;
 	}
@@ -519,7 +519,7 @@ static int nss_n2h_set_empty_paged_pool_
 	ret = wait_for_completion_timeout(&nss_n2h_nepbcfgp[core_num].complete,
 			msecs_to_jiffies(NSS_CONN_CFG_TIMEOUT));
 	if (ret == 0) {
-		nss_warning("%p: core %d Waiting for ack timed out\n", nss_ctx, (int)core_num);
+		nss_warning("%px: core %d Waiting for ack timed out\n", nss_ctx, (int)core_num);
 		goto failure;
 	}
 
@@ -590,25 +590,25 @@ static int nss_n2h_set_water_mark(struct
 
 	if ((*low < NSS_N2H_MIN_EMPTY_POOL_BUF_SZ) ||
 		(*high < NSS_N2H_MIN_EMPTY_POOL_BUF_SZ)) {
-		nss_warning("%p: core %d setting %d, %d < min number of buffer",
+		nss_warning("%px: core %d setting %d, %d < min number of buffer",
 				nss_ctx, core_num, *low, *high);
 		goto failure;
 	}
 
 	if ((*low > NSS_N2H_MAX_EMPTY_POOL_BUF_SZ) ||
 		(*high > NSS_N2H_MAX_EMPTY_POOL_BUF_SZ)) {
-		nss_warning("%p: core %d setting %d, %d is > upper limit",
+		nss_warning("%px: core %d setting %d, %d is > upper limit",
 				nss_ctx, core_num, *low, *high);
 		goto failure;
 	}
 
 	if (*low > *high) {
-		nss_warning("%p: core %d setting low %d is more than high %d",
+		nss_warning("%px: core %d setting low %d is more than high %d",
 				nss_ctx, core_num, *low, *high);
 		goto failure;
 	}
 
-	nss_info("%p: core %d number of low : %d and high : %d\n",
+	nss_info("%px: core %d number of low : %d and high : %d\n",
 		nss_ctx, core_num, *low, *high);
 
 	nss_n2h_msg_init(&nnm, NSS_N2H_INTERFACE,
@@ -623,7 +623,7 @@ static int nss_n2h_set_water_mark(struct
 	nss_tx_status = nss_n2h_tx_msg(nss_ctx, &nnm);
 
 	if (nss_tx_status != NSS_TX_SUCCESS) {
-		nss_warning("%p: core %d nss_tx error setting : %d, %d\n",
+		nss_warning("%px: core %d nss_tx error setting : %d, %d\n",
 				nss_ctx, core_num, *low, *high);
 		goto failure;
 	}
@@ -634,7 +634,7 @@ static int nss_n2h_set_water_mark(struct
 	ret = wait_for_completion_timeout(&nss_n2h_nepbcfgp[core_num].complete,
 			msecs_to_jiffies(NSS_CONN_CFG_TIMEOUT));
 	if (ret == 0) {
-		nss_warning("%p: core %d Waiting for ack timed out\n", nss_ctx,
+		nss_warning("%px: core %d Waiting for ack timed out\n", nss_ctx,
 			core_num);
 		goto failure;
 	}
@@ -704,25 +704,25 @@ static int nss_n2h_set_paged_water_mark(
 
 	if ((*low < NSS_N2H_MIN_EMPTY_POOL_BUF_SZ) ||
 		(*high < NSS_N2H_MIN_EMPTY_POOL_BUF_SZ)) {
-		nss_warning("%p: core %d setting %d, %d < min number of buffer",
+		nss_warning("%px: core %d setting %d, %d < min number of buffer",
 				nss_ctx, core_num, *low, *high);
 		goto failure;
 	}
 
 	if ((*low > NSS_N2H_MAX_EMPTY_POOL_BUF_SZ) ||
 		(*high > NSS_N2H_MAX_EMPTY_POOL_BUF_SZ)) {
-		nss_warning("%p: core %d setting %d, %d is > upper limit",
+		nss_warning("%px: core %d setting %d, %d is > upper limit",
 				nss_ctx, core_num, *low, *high);
 		goto failure;
 	}
 
 	if (*low > *high) {
-		nss_warning("%p: core %d setting low %d is more than high %d",
+		nss_warning("%px: core %d setting low %d is more than high %d",
 				nss_ctx, core_num, *low, *high);
 		goto failure;
 	}
 
-	nss_info("%p: core %d number of low : %d and high : %d\n",
+	nss_info("%px: core %d number of low : %d and high : %d\n",
 		nss_ctx, core_num, *low, *high);
 
 	nss_n2h_msg_init(&nnm, NSS_N2H_INTERFACE,
@@ -737,7 +737,7 @@ static int nss_n2h_set_paged_water_mark(
 	nss_tx_status = nss_n2h_tx_msg(nss_ctx, &nnm);
 
 	if (nss_tx_status != NSS_TX_SUCCESS) {
-		nss_warning("%p: core %d nss_tx error setting : %d, %d\n",
+		nss_warning("%px: core %d nss_tx error setting : %d, %d\n",
 				nss_ctx, core_num, *low, *high);
 		goto failure;
 	}
@@ -748,7 +748,7 @@ static int nss_n2h_set_paged_water_mark(
 	ret = wait_for_completion_timeout(&nss_n2h_nepbcfgp[core_num].complete,
 			msecs_to_jiffies(NSS_CONN_CFG_TIMEOUT));
 	if (ret == 0) {
-		nss_warning("%p: core %d Waiting for ack timed out\n", nss_ctx,
+		nss_warning("%px: core %d Waiting for ack timed out\n", nss_ctx,
 			core_num);
 		goto failure;
 	}
@@ -815,18 +815,18 @@ static int nss_n2h_cfg_wifi_pool(struct
 		goto failure;
 
 	if ((*payloads < NSS_N2H_MIN_EMPTY_POOL_BUF_SZ)) {
-		nss_warning("%p: wifi setting %d < min number of buffer",
+		nss_warning("%px: wifi setting %d < min number of buffer",
 				nss_ctx, *payloads);
 		goto failure;
 	}
 
 	if ((*payloads > NSS_N2H_MAX_EMPTY_POOL_BUF_SZ)) {
-		nss_warning("%p: wifi setting %d > max number of buffer",
+		nss_warning("%px: wifi setting %d > max number of buffer",
 				nss_ctx, *payloads);
 		goto failure;
 	}
 
-	nss_info("%p: wifi payloads : %d\n",
+	nss_info("%px: wifi payloads : %d\n",
 		nss_ctx, *payloads);
 
 	nss_n2h_msg_init(&nnm, NSS_N2H_INTERFACE,
@@ -840,7 +840,7 @@ static int nss_n2h_cfg_wifi_pool(struct
 	nss_tx_status = nss_n2h_tx_msg(nss_ctx, &nnm);
 
 	if (nss_tx_status != NSS_TX_SUCCESS) {
-		nss_warning("%p: wifi setting %d nss_tx error",
+		nss_warning("%px: wifi setting %d nss_tx error",
 				nss_ctx, *payloads);
 		goto failure;
 	}
@@ -851,7 +851,7 @@ static int nss_n2h_cfg_wifi_pool(struct
 	ret = wait_for_completion_timeout(&nss_n2h_wp.complete,
 			msecs_to_jiffies(NSS_CONN_CFG_TIMEOUT));
 	if (ret == 0) {
-		nss_warning("%p: Waiting for ack timed out\n", nss_ctx);
+		nss_warning("%px: Waiting for ack timed out\n", nss_ctx);
 		goto failure;
 	}
 
@@ -1039,7 +1039,7 @@ nss_tx_status_t nss_n2h_update_queue_con
 
 	status = nss_n2h_tx_msg(nss_ctx, &nnm);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: nss_tx error to send pnode queue config\n", nss_ctx);
+		nss_warning("%px: nss_tx error to send pnode queue config\n", nss_ctx);
 		return status;
 	}
 
@@ -1092,14 +1092,14 @@ nss_tx_status_t nss_n2h_update_queue_con
 	status = nss_n2h_tx_msg(nss_ctx, &nnm);
 
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: n2h_tx_msg failed\n", nss_ctx);
+		nss_warning("%px: n2h_tx_msg failed\n", nss_ctx);
 		up(&nss_n2h_q_cfg_pvt.sem);
 		return status;
 	}
 	ret = wait_for_completion_timeout(&nss_n2h_q_cfg_pvt.complete, msecs_to_jiffies(NSS_N2H_TX_TIMEOUT));
 
 	if (!ret) {
-		nss_warning("%p: Timeout expired for pnode queue config sync message\n", nss_ctx);
+		nss_warning("%px: Timeout expired for pnode queue config sync message\n", nss_ctx);
 		nss_n2h_q_cfg_pvt.response = NSS_TX_FAILURE;
 	}
 
@@ -1134,7 +1134,7 @@ static nss_tx_status_t nss_n2h_mitigatio
 	nss_tx_status = nss_n2h_tx_msg(nss_ctx, &nnm);
 
 	if (nss_tx_status != NSS_TX_SUCCESS) {
-		nss_warning("%p: nss_tx error setting mitigation\n", nss_ctx);
+		nss_warning("%px: nss_tx error setting mitigation\n", nss_ctx);
 		goto failure;
 	}
 
@@ -1143,7 +1143,7 @@ static nss_tx_status_t nss_n2h_mitigatio
 	 */
 	ret = wait_for_completion_timeout(&nss_n2h_mitigationcp[core_num].complete, msecs_to_jiffies(NSS_CONN_CFG_TIMEOUT));
 	if (ret == 0) {
-		nss_warning("%p: Waiting for ack timed out\n", nss_ctx);
+		nss_warning("%px: Waiting for ack timed out\n", nss_ctx);
 		goto failure;
 	}
 
@@ -1215,7 +1215,7 @@ static nss_tx_status_t nss_n2h_buf_pool_
 		if (nss_tx_status != NSS_TX_SUCCESS) {
 
 			nss_n2h_buf_pool_free(buf_pool);
-			nss_warning("%p: nss_tx error setting pbuf\n", nss_ctx);
+			nss_warning("%px: nss_tx error setting pbuf\n", nss_ctx);
 			goto failure;
 		}
 
@@ -1224,7 +1224,7 @@ static nss_tx_status_t nss_n2h_buf_pool_
 		 */
 		ret = wait_for_completion_timeout(&nss_n2h_bufcp[core_num].complete, msecs_to_jiffies(NSS_CONN_CFG_TIMEOUT));
 		if (ret == 0) {
-			nss_warning("%p: Waiting for ack timed out\n", nss_ctx);
+			nss_warning("%px: Waiting for ack timed out\n", nss_ctx);
 			goto failure;
 		}
 
@@ -1246,7 +1246,6 @@ failure:
 	return NSS_FAILURE;
 }
 
-
 /*
  * nss_mitigation_handler()
  * Enable NSS MITIGATION
@@ -1432,7 +1431,7 @@ static int nss_n2h_set_queue_limit_sync(
 	 * We dont allow shortening of the queue size at run-time
 	 */
 	if (nss_n2h_queue_limit[core_id] < current_val) {
-		nss_warning("%p: New queue limit %d less than previous value %d. Cant allow shortening\n",
+		nss_warning("%px: New queue limit %d less than previous value %d. Cant allow shortening\n",
 				nss_ctx, nss_n2h_queue_limit[core_id], current_val);
 		nss_n2h_queue_limit[core_id] = current_val;
 		return NSS_TX_FAILURE;
@@ -1453,7 +1452,7 @@ static int nss_n2h_set_queue_limit_sync(
 
 	nss_tx_status = nss_n2h_tx_msg(nss_ctx, &nim);
 	if (nss_tx_status != NSS_TX_SUCCESS) {
-		nss_warning("%p: n2h queue limit message send failed\n", nss_ctx);
+		nss_warning("%px: n2h queue limit message send failed\n", nss_ctx);
 		nss_n2h_queue_limit[core_id] = current_val;
 		up(&nss_n2h_q_lim_pvt.sem);
 		return nss_tx_status;
@@ -1461,7 +1460,7 @@ static int nss_n2h_set_queue_limit_sync(
 
 	ret = wait_for_completion_timeout(&nss_n2h_q_lim_pvt.complete, msecs_to_jiffies(NSS_N2H_TX_TIMEOUT));
 	if (!ret) {
-		nss_warning("%p: Timeout expired for queue limit sync message\n", nss_ctx);
+		nss_warning("%px: Timeout expired for queue limit sync message\n", nss_ctx);
 		nss_n2h_queue_limit[core_id] = current_val;
 		up(&nss_n2h_q_lim_pvt.sem);
 		return NSS_TX_FAILURE;
@@ -1512,11 +1511,11 @@ static void nss_n2h_host_bp_cfg_callback
 	if (nnm->cm.response != NSS_CMN_RESPONSE_ACK) {
 		nss_n2h_host_bp_cfg_pvt.response = NSS_FAILURE;
 		complete(&nss_n2h_host_bp_cfg_pvt.complete);
-		nss_warning("%p: n2h back pressure configuration failed : %d\n", nss_ctx, nnm->cm.error);
+		nss_warning("%px: n2h back pressure configuration failed : %d\n", nss_ctx, nnm->cm.error);
 		return;
 	}
 
-	nss_info("%p: n2h back pressure configuration succeeded: %d\n", nss_ctx, nnm->cm.error);
+	nss_info("%px: n2h back pressure configuration succeeded: %d\n", nss_ctx, nnm->cm.error);
 	nss_n2h_host_bp_cfg_pvt.response = NSS_SUCCESS;
 	complete(&nss_n2h_host_bp_cfg_pvt.complete);
 }
@@ -1541,7 +1540,7 @@ static nss_tx_status_t nss_n2h_host_bp_c
 
 	nss_tx_status = nss_n2h_tx_msg(nss_ctx, &nnm);
 	if (nss_tx_status != NSS_TX_SUCCESS) {
-		nss_warning("%p: nss_tx error setting back pressure\n", nss_ctx);
+		nss_warning("%px: nss_tx error setting back pressure\n", nss_ctx);
 		up(&nss_n2h_host_bp_cfg_pvt.sem);
 		return NSS_FAILURE;
 	}
@@ -1551,7 +1550,7 @@ static nss_tx_status_t nss_n2h_host_bp_c
 	 */
 	ret = wait_for_completion_timeout(&nss_n2h_host_bp_cfg_pvt.complete, msecs_to_jiffies(NSS_CONN_CFG_TIMEOUT));
 	if (ret == 0) {
-		nss_warning("%p: Waiting for ack timed out\n", nss_ctx);
+		nss_warning("%px: Waiting for ack timed out\n", nss_ctx);
 		up(&nss_n2h_host_bp_cfg_pvt.sem);
 		return NSS_FAILURE;
 	}
@@ -1599,7 +1598,7 @@ static int nss_n2h_host_bp_cfg_handler(s
 	ret_bp = nss_n2h_host_bp_cfg_sync(nss_ctx, nss_n2h_host_bp_config[core_id]);
 
 	if (ret_bp != NSS_SUCCESS) {
-		nss_warning("%p: n2h back pressure config failed\n", nss_ctx);
+		nss_warning("%px: n2h back pressure config failed\n", nss_ctx);
 		nss_n2h_host_bp_config[core_id] = current_state;
 	}
 
@@ -1903,18 +1902,18 @@ nss_tx_status_t nss_n2h_cfg_empty_pool_s
 	nss_tx_status_t nss_tx_status;
 
 	if (pool_sz < NSS_N2H_MIN_EMPTY_POOL_BUF_SZ) {
-		nss_warning("%p: setting pool size %d < min number of buffer",
+		nss_warning("%px: setting pool size %d < min number of buffer",
 				nss_ctx, pool_sz);
 		return NSS_TX_FAILURE;
 	}
 
 	if (pool_sz > NSS_N2H_MAX_EMPTY_POOL_BUF_SZ) {
-		nss_warning("%p: setting pool size %d > max number of buffer",
+		nss_warning("%px: setting pool size %d > max number of buffer",
 				nss_ctx, pool_sz);
 		return NSS_TX_FAILURE;
 	}
 
-	nss_info("%p: update number of empty buffer pool size: %d\n",
+	nss_info("%px: update number of empty buffer pool size: %d\n",
 		nss_ctx, pool_sz);
 
 	nss_n2h_msg_init(&nnm, NSS_N2H_INTERFACE,
@@ -1926,7 +1925,7 @@ nss_tx_status_t nss_n2h_cfg_empty_pool_s
 	nss_tx_status = nss_n2h_tx_msg(nss_ctx, &nnm);
 
 	if (nss_tx_status != NSS_TX_SUCCESS) {
-		nss_warning("%p: nss_tx error empty buffer pool: %d\n", nss_ctx, pool_sz);
+		nss_warning("%px: nss_tx error empty buffer pool: %d\n", nss_ctx, pool_sz);
 		return nss_tx_status;
 	}
 
@@ -1953,7 +1952,7 @@ nss_tx_status_t nss_n2h_paged_buf_pool_i
 
 	nss_tx_status = nss_n2h_tx_msg(nss_ctx, &nnm);
 	if (nss_tx_status != NSS_TX_SUCCESS) {
-		nss_warning("%p: failed to send paged buf configuration init command to NSS\n",
+		nss_warning("%px: failed to send paged buf configuration init command to NSS\n",
 				nss_ctx);
 		return NSS_TX_FAILURE;
 	}
@@ -1986,7 +1985,7 @@ nss_tx_status_t nss_n2h_flush_payloads(s
 
 	nss_tx_status = nss_n2h_tx_msg(nss_ctx, &nnm);
 	if (nss_tx_status != NSS_TX_SUCCESS) {
-		nss_warning("%p: failed to send flush payloads command to NSS\n",
+		nss_warning("%px: failed to send flush payloads command to NSS\n",
 				nss_ctx);
 
 		return NSS_TX_FAILURE;
@@ -2017,12 +2016,12 @@ nss_tx_status_t nss_n2h_tx_msg(struct ns
 	 * Sanity check the message
 	 */
 	if (ncm->interface != NSS_N2H_INTERFACE) {
-		nss_warning("%p: tx request for another interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: tx request for another interface: %d", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
 	if (ncm->type >= NSS_METADATA_TYPE_N2H_MAX) {
-		nss_warning("%p: message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
--- a/nss_oam.c
+++ b/nss_oam.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2016-2018 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016-2018, 2020 The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -45,12 +45,12 @@ static void nss_oam_rx_msg_handler(struc
 	 * Sanity check the message type
 	 */
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_oam_msg)) {
-		nss_warning("%p: recevied with invalid msg size: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: recevied with invalid msg size: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
 	if (ncm->type > NSS_OAM_MSG_TYPE_MAX) {
-		nss_warning("%p: received with invalid resp type: %d", nss_ctx, ncm->type);
+		nss_warning("%px: received with invalid resp type: %d", nss_ctx, ncm->type);
 		return;
 	}
 
@@ -66,7 +66,7 @@ static void nss_oam_rx_msg_handler(struc
 
 	cb = (nss_oam_msg_callback_t)ncm->cb;
 	if (unlikely(!cb)) {
-		nss_trace("%p: rx handler has been unregistered for i/f: %d", nss_ctx, ncm->interface);
+		nss_trace("%px: rx handler has been unregistered for i/f: %d", nss_ctx, ncm->interface);
 		return;
 	}
 	cb((void *)ncm->app_data, nom);
@@ -86,12 +86,12 @@ nss_tx_status_t nss_oam_tx_msg(struct ns
 	nss_oam_log_tx_msg(nom);
 
 	if (ncm->type > NSS_OAM_MSG_TYPE_MAX) {
-		nss_warning("%p: CMD type for oam module is invalid - %d", nss_ctx, ncm->type);
+		nss_warning("%px: CMD type for oam module is invalid - %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
 	if (ncm->interface != NSS_OAM_INTERFACE) {
-		nss_warning("%p: tx message request for another interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: tx message request for another interface: %d", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
--- a/nss_oam_log.c
+++ b/nss_oam_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -37,8 +37,8 @@ static int8_t *nss_oam_log_message_types
 static void nss_oam_log_get_fw_version_msg(struct nss_oam_msg *nom)
 {
 	struct nss_oam_fw_ver *nofm __maybe_unused = &nom->msg.fw_ver;
-	nss_trace("%p: NSS OAM Get FW Version message \n"
-		"OAM FW Version: %p\n",
+	nss_trace("%px: NSS OAM Get FW Version message \n"
+		"OAM FW Version: %px\n",
 		nofm, nofm->string);
 }
 
@@ -54,7 +54,7 @@ static void nss_oam_log_verbose(struct n
 		break;
 
 	default:
-		nss_trace("%p: Invalid message type\n", nom);
+		nss_trace("%px: Invalid message type\n", nom);
 		break;
 	}
 }
@@ -66,11 +66,11 @@ static void nss_oam_log_verbose(struct n
 void nss_oam_log_tx_msg(struct nss_oam_msg *nom)
 {
 	if (nom->cm.type >= NSS_OAM_MSG_TYPE_MAX) {
-		nss_warning("%p: Invalid message type\n", nom);
+		nss_warning("%px: Invalid message type\n", nom);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", nom, nom->cm.type, nss_oam_log_message_types_str[nom->cm.type]);
+	nss_info("%px: type[%d]:%s\n", nom, nom->cm.type, nss_oam_log_message_types_str[nom->cm.type]);
 	nss_oam_log_verbose(nom);
 }
 
@@ -81,18 +81,18 @@ void nss_oam_log_tx_msg(struct nss_oam_m
 void nss_oam_log_rx_msg(struct nss_oam_msg *nom)
 {
 	if (nom->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", nom);
+		nss_warning("%px: Invalid response\n", nom);
 		return;
 	}
 
 	if (nom->cm.response == NSS_CMN_RESPONSE_NOTIFY || (nom->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", nom, nom->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", nom, nom->cm.type,
 			nss_oam_log_message_types_str[nom->cm.type],
 			nom->cm.response, nss_cmn_response_str[nom->cm.response]);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s\n",
 		nom, nom->cm.type, nss_oam_log_message_types_str[nom->cm.type],
 		nom->cm.response, nss_cmn_response_str[nom->cm.response]);
 
--- a/nss_phys_if.c
+++ b/nss_phys_if.c
@@ -77,17 +77,17 @@ static void nss_phys_if_msg_handler(stru
 	 * Sanity check the message type
 	 */
 	if (ncm->type > NSS_PHYS_IF_MAX_MSG_TYPES) {
-		nss_warning("%p: message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (!NSS_IS_IF_TYPE(PHYSICAL, ncm->interface)) {
-		nss_warning("%p: response for another interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: response for another interface: %d", nss_ctx, ncm->interface);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_phys_if_msg)) {
-		nss_warning("%p: message length too big: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: message length too big: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
@@ -162,7 +162,7 @@ static void nss_phys_if_callback(void *a
  */
 nss_tx_status_t nss_phys_if_buf(struct nss_ctx_instance *nss_ctx, struct sk_buff *os_buf, uint32_t if_num)
 {
-	nss_trace("%p: Phys If Tx packet, id:%d, data=%p", nss_ctx, if_num, os_buf->data);
+	nss_trace("%px: Phys If Tx packet, id:%d, data=%px", nss_ctx, if_num, os_buf->data);
 
 #ifdef NSS_DRV_TSTAMP_ENABLE
 	/*
@@ -196,18 +196,18 @@ nss_tx_status_t nss_phys_if_msg(struct n
 	 * Sanity check the message
 	 */
 	if (!NSS_IS_IF_TYPE(PHYSICAL, ncm->interface)) {
-		nss_warning("%p: tx request for another interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: tx request for another interface: %d", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
 	if (ncm->type > NSS_PHYS_IF_MAX_MSG_TYPES) {
-		nss_warning("%p: message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
 	dev = nss_ctx->subsys_dp_register[ncm->interface].ndev;
 	if (!dev) {
-		nss_warning("%p: Unregister physical interface %d: no context", nss_ctx, ncm->interface);
+		nss_warning("%px: Unregister physical interface %d: no context", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
@@ -228,7 +228,7 @@ nss_tx_status_t nss_phys_if_msg_sync(str
 	status = nss_phys_if_msg(nss_ctx, nim);
 	if(status != NSS_TX_SUCCESS)
 	{
-		nss_warning("%p: nss_phys_if_msg failed\n", nss_ctx);
+		nss_warning("%px: nss_phys_if_msg failed\n", nss_ctx);
 		up(&phif.sem);
 		return status;
 	}
@@ -237,7 +237,7 @@ nss_tx_status_t nss_phys_if_msg_sync(str
 
 	if(!ret)
 	{
-		nss_warning("%p: phys_if tx failed due to timeout\n", nss_ctx);
+		nss_warning("%px: phys_if tx failed due to timeout\n", nss_ctx);
 		phif.response = NSS_TX_FAILURE;
 	}
 
@@ -326,7 +326,7 @@ nss_tx_status_t nss_phys_if_open(struct
 	struct nss_if_open *nio;
 
 	NSS_VERIFY_CTX_MAGIC(nss_ctx);
-	nss_info("%p: Phys If Open, id:%d, TxDesc: %x, RxDesc: %x\n", nss_ctx, if_num, tx_desc_ring, rx_desc_ring);
+	nss_info("%px: Phys If Open, id:%d, TxDesc: %x, RxDesc: %x\n", nss_ctx, if_num, tx_desc_ring, rx_desc_ring);
 
 	nss_cmn_msg_init(&nim.cm, if_num, NSS_PHYS_IF_OPEN,
 			sizeof(struct nss_if_open), nss_phys_if_callback, NULL);
@@ -345,7 +345,7 @@ nss_tx_status_t nss_phys_if_open(struct
 		nio->rx_forward_if = NSS_PORTID_INTERFACE;
 		nio->alignment_mode = NSS_IF_DATA_ALIGN_2BYTE;
 	} else {
-		nss_info("%p: Phys If Open, unknown mode %d\n", nss_ctx, mode);
+		nss_info("%px: Phys If Open, unknown mode %d\n", nss_ctx, mode);
 		return NSS_TX_FAILURE;
 	}
 
@@ -370,7 +370,7 @@ nss_tx_status_t nss_phys_if_close(struct
 	struct nss_phys_if_msg nim;
 
 	NSS_VERIFY_CTX_MAGIC(nss_ctx);
-	nss_info("%p: Phys If Close, id:%d \n", nss_ctx, if_num);
+	nss_info("%px: Phys If Close, id:%d \n", nss_ctx, if_num);
 
 	nss_cmn_msg_init(&nim.cm, if_num, NSS_PHYS_IF_CLOSE,
 			sizeof(struct nss_if_close), nss_phys_if_callback, NULL);
@@ -388,7 +388,7 @@ nss_tx_status_t nss_phys_if_link_state(s
 	struct nss_if_link_state_notify *nils;
 
 	NSS_VERIFY_CTX_MAGIC(nss_ctx);
-	nss_info("%p: Phys If Link State, id:%d, State: %x\n", nss_ctx, if_num, link_state);
+	nss_info("%px: Phys If Link State, id:%d, State: %x\n", nss_ctx, if_num, link_state);
 
 	nss_cmn_msg_init(&nim.cm, if_num, NSS_PHYS_IF_LINK_STATE_NOTIFY,
 			sizeof(struct nss_if_link_state_notify), nss_phys_if_callback, NULL);
@@ -408,7 +408,7 @@ nss_tx_status_t nss_phys_if_mac_addr(str
 	struct nss_if_mac_address_set *nmas;
 
 	NSS_VERIFY_CTX_MAGIC(nss_ctx);
-	nss_info("%p: Phys If MAC Address, id:%d\n", nss_ctx, if_num);
+	nss_info("%px: Phys If MAC Address, id:%d\n", nss_ctx, if_num);
 	nss_assert(addr != 0);
 
 	nss_cmn_msg_init(&nim.cm, if_num, NSS_PHYS_IF_MAC_ADDR_SET,
@@ -441,7 +441,7 @@ nss_tx_status_t nss_phys_if_change_mtu(s
 	}
 #endif
 	NSS_VERIFY_CTX_MAGIC(nss_ctx);
-	nss_info("%p: Phys If Change MTU, id:%d, mtu=%d\n", nss_ctx, if_num, mtu);
+	nss_info("%px: Phys If Change MTU, id:%d, mtu=%d\n", nss_ctx, if_num, mtu);
 
 	nss_cmn_msg_init(&nim.cm, if_num, NSS_PHYS_IF_MTU_CHANGE,
 			sizeof(struct nss_if_mtu_change), nss_phys_if_callback, NULL);
@@ -491,7 +491,6 @@ nss_tx_status_t nss_phys_if_change_mtu(s
 	nss_ctx->max_buf_size = NSS_EMPTY_BUFFER_SIZE;
 #endif
 
-
 #if (NSS_SKB_REUSE_SUPPORT == 1)
 	if (nss_ctx->max_buf_size > nss_core_get_max_reuse())
 		nss_core_set_max_reuse(ALIGN(nss_ctx->max_buf_size * 2, PAGE_SIZE));
@@ -524,7 +523,7 @@ nss_tx_status_t nss_phys_if_vsi_assign(s
 	struct nss_phys_if_msg nim;
 
 	NSS_VERIFY_CTX_MAGIC(nss_ctx);
-	nss_info("%p: Phys If VSI Assign, id:%d\n", nss_ctx, if_num);
+	nss_info("%px: Phys If VSI Assign, id:%d\n", nss_ctx, if_num);
 
 	memset(&nim, 0, sizeof(struct nss_phys_if_msg));
 
@@ -544,7 +543,7 @@ nss_tx_status_t nss_phys_if_vsi_unassign
 	struct nss_phys_if_msg nim;
 
 	NSS_VERIFY_CTX_MAGIC(nss_ctx);
-	nss_info("%p: Phys If VSI Unassign, id:%d\n", nss_ctx, if_num);
+	nss_info("%px: Phys If VSI Unassign, id:%d\n", nss_ctx, if_num);
 
 	memset(&nim, 0, sizeof(struct nss_phys_if_msg));
 
@@ -565,7 +564,7 @@ nss_tx_status_t nss_phys_if_pause_on_off
 	struct nss_if_pause_on_off *nipe;
 
 	NSS_VERIFY_CTX_MAGIC(nss_ctx);
-	nss_info("%p: phys if pause is set to %d, id:%d\n", nss_ctx, pause_on, if_num);
+	nss_info("%px: phys if pause is set to %d, id:%d\n", nss_ctx, pause_on, if_num);
 
 	nss_cmn_msg_init(&nim.cm, if_num, NSS_PHYS_IF_PAUSE_ON_OFF,
 			sizeof(struct nss_if_pause_on_off), nss_phys_if_callback, NULL);
@@ -577,6 +576,23 @@ nss_tx_status_t nss_phys_if_pause_on_off
 }
 
 /*
+ * nss_phys_if_reset_nexthop()
+ *	De-configures nexthop for an interface
+ */
+nss_tx_status_t nss_phys_if_reset_nexthop(struct nss_ctx_instance *nss_ctx, uint32_t if_num)
+{
+	struct nss_phys_if_msg nim;
+
+	NSS_VERIFY_CTX_MAGIC(nss_ctx);
+
+	nss_cmn_msg_init(&nim.cm, if_num, NSS_PHYS_IF_RESET_NEXTHOP,
+				0, nss_phys_if_callback, NULL);
+
+	return nss_phys_if_msg_sync(nss_ctx, &nim);
+}
+EXPORT_SYMBOL(nss_phys_if_reset_nexthop);
+
+/*
  * nss_phys_if_set_nexthop()
  *	Configures nexthop for an interface
  */
@@ -587,11 +603,11 @@ nss_tx_status_t nss_phys_if_set_nexthop(
 	NSS_VERIFY_CTX_MAGIC(nss_ctx);
 
 	if (nexthop >= NSS_MAX_NET_INTERFACES) {
-		nss_warning("%p: Invalid nexthop interface number: %d", nss_ctx, nexthop);
+		nss_warning("%px: Invalid nexthop interface number: %d", nss_ctx, nexthop);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
-	nss_info("%p: Phys If nexthop will be set to %d, id:%d\n", nss_ctx, nexthop, if_num);
+	nss_info("%px: Phys If nexthop will be set to %d, id:%d\n", nss_ctx, nexthop, if_num);
 
 	nss_cmn_msg_init(&nim.cm, if_num, NSS_PHYS_IF_SET_NEXTHOP,
 				sizeof(struct nss_if_set_nexthop), nss_phys_if_callback, NULL);
--- a/nss_phys_if.h
+++ b/nss_phys_if.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -124,6 +124,7 @@ enum nss_phys_if_msg_types {
 	NSS_PHYS_IF_VSI_ASSIGN = NSS_IF_VSI_ASSIGN,
 	NSS_PHYS_IF_VSI_UNASSIGN = NSS_IF_VSI_UNASSIGN,
 	NSS_PHYS_IF_SET_NEXTHOP = NSS_IF_SET_NEXTHOP,
+	NSS_PHYS_IF_RESET_NEXTHOP = NSS_IF_RESET_NEXTHOP,
 	NSS_PHYS_IF_EXTENDED_STATS_SYNC = NSS_IF_MAX_MSG_TYPES + 1,
 	NSS_PHYS_IF_MAX_MSG_TYPES
 };
--- a/nss_portid.c
+++ b/nss_portid.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2015-2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2015-2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -60,12 +60,12 @@ static void nss_portid_handler(struct ns
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >= NSS_PORTID_MAX_MSG_TYPE) {
-		nss_warning("%p: received invalid message %d for portid interface", nss_ctx, ncm->type);
+		nss_warning("%px: received invalid message %d for portid interface", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_portid_msg)) {
-		nss_warning("%p: message size incorrect: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: message size incorrect: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
@@ -88,7 +88,7 @@ static void nss_portid_handler(struct ns
 	 * to the same callback/app_data.
 	 */
 	if (ncm->response == NSS_CMN_RESPONSE_NOTIFY) {
-		ncm->cb = (nss_ptr_t)nss_ctx->nss_top->if_rx_msg_callback[ncm->interface];
+		ncm->cb = (nss_ptr_t)nss_core_get_msg_handler(nss_ctx, ncm->interface);
 		ncm->app_data = (nss_ptr_t)nss_ctx->subsys_dp_register[ncm->interface].ndev;
 	}
 
@@ -184,12 +184,12 @@ nss_tx_status_t nss_portid_tx_msg(struct
 	 * Sanity check the message
 	 */
 	if (ncm->interface != NSS_PORTID_INTERFACE) {
-		nss_warning("%p: tx request for another interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: tx request for another interface: %d", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
 	if (ncm->type > NSS_PORTID_MAX_MSG_TYPE) {
-		nss_warning("%p: message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
@@ -228,7 +228,7 @@ nss_tx_status_t nss_portid_tx_msg_sync(s
 	status = nss_portid_tx_msg(nss_ctx, msg);
 	if(status != NSS_TX_SUCCESS)
 	{
-		nss_warning("%p: nss_phys_if_msg failed\n", nss_ctx);
+		nss_warning("%px: nss_phys_if_msg failed\n", nss_ctx);
 		up(&pid.sem);
 		return status;
 	}
@@ -237,7 +237,7 @@ nss_tx_status_t nss_portid_tx_msg_sync(s
 
 	if(!ret)
 	{
-		nss_warning("%p: portid tx failed due to timeout\n", nss_ctx);
+		nss_warning("%px: portid tx failed due to timeout\n", nss_ctx);
 		pid.response = NSS_TX_FAILURE;
 	}
 
@@ -377,7 +377,7 @@ bool nss_portid_unregister_port_if(uint3
 
 	nss_ctx = nss_portid_get_ctx();
 	if (nss_portid_verify_if_num(if_num) == false) {
-		nss_warning("%p: unregister received for invalid interface %d", nss_ctx, if_num);
+		nss_warning("%px: unregister received for invalid interface %d", nss_ctx, if_num);
 		return false;
 	}
 
--- a/nss_portid_log.c
+++ b/nss_portid_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -38,7 +38,7 @@ static int8_t *nss_portid_log_message_ty
 static void nss_portid_log_configure_msg(struct nss_portid_msg *npm)
 {
 	struct nss_portid_configure_msg *npcm __maybe_unused = &npm->msg.configure;
-	nss_trace("%p: NSS PORTID Configure message \n"
+	nss_trace("%px: NSS PORTID Configure message \n"
 		"PORTID Interface Number: %d\n"
 		"PORTID Interface ID: %d\n"
 		"PORTID GMAC ID: %d\n",
@@ -53,7 +53,7 @@ static void nss_portid_log_configure_msg
 static void nss_portid_log_unconfigure_msg(struct nss_portid_msg *npm)
 {
 	struct nss_portid_unconfigure_msg *npum __maybe_unused = &npm->msg.unconfigure;
-	nss_trace("%p: NSS PORTID Configure message \n"
+	nss_trace("%px: NSS PORTID Configure message \n"
 		"PORTID Interface Number: %d\n"
 		"PORTID Interface ID: %d\n",
 		npum, npum->port_if_num,
@@ -82,7 +82,7 @@ static void nss_portid_log_verbose(struc
 		break;
 
 	default:
-		nss_trace("%p: Invalid message type\n", npm);
+		nss_trace("%px: Invalid message type\n", npm);
 		break;
 	}
 }
@@ -94,11 +94,11 @@ static void nss_portid_log_verbose(struc
 void nss_portid_log_tx_msg(struct nss_portid_msg *npm)
 {
 	if (npm->cm.type >= NSS_PORTID_MAX_MSG_TYPE) {
-		nss_warning("%p: Invalid message type\n", npm);
+		nss_warning("%px: Invalid message type\n", npm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", npm, npm->cm.type, nss_portid_log_message_types_str[npm->cm.type]);
+	nss_info("%px: type[%d]:%s\n", npm, npm->cm.type, nss_portid_log_message_types_str[npm->cm.type]);
 	nss_portid_log_verbose(npm);
 }
 
@@ -109,18 +109,18 @@ void nss_portid_log_tx_msg(struct nss_po
 void nss_portid_log_rx_msg(struct nss_portid_msg *npm)
 {
 	if (npm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", npm);
+		nss_warning("%px: Invalid response\n", npm);
 		return;
 	}
 
 	if (npm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (npm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", npm, npm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", npm, npm->cm.type,
 			nss_portid_log_message_types_str[npm->cm.type],
 			npm->cm.response, nss_cmn_response_str[npm->cm.response]);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s\n",
 		npm, npm->cm.type, nss_portid_log_message_types_str[npm->cm.type],
 		npm->cm.response, nss_cmn_response_str[npm->cm.response]);
 
--- a/nss_portid_stats.c
+++ b/nss_portid_stats.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2016-2017, 2019 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016-2017, 2019-2020 The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -140,7 +140,7 @@ void nss_portid_stats_sync(struct nss_ct
 	spin_lock_bh(&nss_portid_spinlock);
 	hdl = &nss_portid_hdl[npsm->port_id];
 	if (hdl->if_num == 0) {
-		nss_warning("%p: nss_portid recv'd stats with unconfigured port %d", nss_ctx, npsm->port_id);
+		nss_warning("%px: nss_portid recv'd stats with unconfigured port %d", nss_ctx, npsm->port_id);
 		spin_unlock_bh(&nss_portid_spinlock);
 		return;
 	}
--- a/nss_ppe.c
+++ b/nss_ppe.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2016-2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016-2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -72,12 +72,12 @@ nss_tx_status_t nss_ppe_tx_msg(struct ns
 	 * Sanity check the message
 	 */
 	if (ncm->type >= NSS_PPE_MSG_MAX) {
-		nss_warning("%p: message type out of range: %d\n", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d\n", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
 	if (!nss_ppe_verify_ifnum(ncm->interface)) {
-		nss_warning("%p: invalid interface %d\n", nss_ctx, ncm->interface);
+		nss_warning("%px: invalid interface %d\n", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
@@ -102,14 +102,14 @@ nss_tx_status_t nss_ppe_tx_msg_sync(stru
 
 	status = nss_ppe_tx_msg(nss_ctx, npm);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: ppe_tx_msg failed\n", nss_ctx);
+		nss_warning("%px: ppe_tx_msg failed\n", nss_ctx);
 		up(&ppe_pvt.sem);
 		return status;
 	}
 
 	ret = wait_for_completion_timeout(&ppe_pvt.complete, msecs_to_jiffies(NSS_PPE_TX_TIMEOUT));
 	if (!ret) {
-		nss_warning("%p: ppe msg tx failed due to timeout\n", nss_ctx);
+		nss_warning("%px: ppe msg tx failed due to timeout\n", nss_ctx);
 		ppe_pvt.response = NSS_TX_FAILURE;
 	}
 
@@ -244,7 +244,7 @@ static void nss_ppe_handler(struct nss_c
 
 	nss_ppe_msg_callback_t cb;
 
-	nss_trace("nss_ctx: %p ppe msg: %p\n", nss_ctx, msg);
+	nss_trace("nss_ctx: %px ppe msg: %px\n", nss_ctx, msg);
 	BUG_ON(!nss_ppe_verify_ifnum(ncm->interface));
 
 	/*
@@ -256,12 +256,12 @@ static void nss_ppe_handler(struct nss_c
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >= NSS_PPE_MSG_MAX) {
-		nss_warning("%p: received invalid message %d for PPE interface\n", nss_ctx, ncm->type);
+		nss_warning("%px: received invalid message %d for PPE interface\n", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_ppe_msg)) {
-		nss_warning("%p: Length of message is greater than required: %d\n", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: Length of message is greater than required: %d\n", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
--- a/nss_ppe_log.c
+++ b/nss_ppe_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -57,7 +57,7 @@ static int8_t *nss_ppe_log_error_respons
 static void nss_ppe_log_port_config_msg(struct nss_ppe_msg *npm)
 {
 	struct nss_ppe_ipsec_port_config_msg *npcm __maybe_unused = &npm->msg.ipsec_config;
-	nss_trace("%p: NSS PPE Port Configure Message:\n"
+	nss_trace("%px: NSS PPE Port Configure Message:\n"
 		"PPE NSS Interface Number: %d\n"
 		"PPE MTU: %d\n"
 		"PPE VSI Number: %d\n",
@@ -72,7 +72,7 @@ static void nss_ppe_log_port_config_msg(
 static void nss_ppe_log_port_mtu_msg(struct nss_ppe_msg *npm)
 {
 	struct nss_ppe_ipsec_port_mtu_msg *npmm __maybe_unused = &npm->msg.ipsec_mtu;
-	nss_trace("%p: NSS PPE Port Configure Message:\n"
+	nss_trace("%px: NSS PPE Port Configure Message:\n"
 		"PPE NSS Interface Number: %d\n"
 		"PPE MTU: %d\n",
 		npmm, npmm->nss_ifnum,
@@ -86,7 +86,7 @@ static void nss_ppe_log_port_mtu_msg(str
 static void nss_ppe_log_add_intf_msg(struct nss_ppe_msg *npm)
 {
 	struct nss_ppe_ipsec_add_intf_msg *npam __maybe_unused = &npm->msg.ipsec_addif;
-	nss_trace("%p: NSS PPE IPSEC add Interface Message:\n"
+	nss_trace("%px: NSS PPE IPSEC add Interface Message:\n"
 		"PPE NSS Interface Number: %d\n",
 		npam, npam->nss_ifnum);
 }
@@ -98,7 +98,7 @@ static void nss_ppe_log_add_intf_msg(str
 static void nss_ppe_log_del_intf_msg(struct nss_ppe_msg *npm)
 {
 	struct nss_ppe_ipsec_del_intf_msg *npdm __maybe_unused = &npm->msg.ipsec_delif;
-	nss_trace("%p: NSS PPE IPSEC Delete Interface Message:\n"
+	nss_trace("%px: NSS PPE IPSEC Delete Interface Message:\n"
 		"PPE NSS Interface Number: %d\n",
 		npdm, npdm->nss_ifnum);
 }
@@ -133,7 +133,7 @@ static void nss_ppe_log_verbose(struct n
 		break;
 
 	default:
-		nss_warning("%p: Invalid message type\n", npm);
+		nss_warning("%px: Invalid message type\n", npm);
 		break;
 	}
 }
@@ -145,11 +145,11 @@ static void nss_ppe_log_verbose(struct n
 void nss_ppe_log_tx_msg(struct nss_ppe_msg *npm)
 {
 	if (npm->cm.type >= NSS_PPE_MSG_MAX) {
-		nss_warning("%p: Invalid message type\n", npm);
+		nss_warning("%px: Invalid message type\n", npm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", npm, npm->cm.type, nss_ppe_log_message_types_str[npm->cm.type]);
+	nss_info("%px: type[%d]:%s\n", npm, npm->cm.type, nss_ppe_log_message_types_str[npm->cm.type]);
 	nss_ppe_log_verbose(npm);
 }
 
@@ -160,26 +160,26 @@ void nss_ppe_log_tx_msg(struct nss_ppe_m
 void nss_ppe_log_rx_msg(struct nss_ppe_msg *npm)
 {
 	if (npm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", npm);
+		nss_warning("%px: Invalid response\n", npm);
 		return;
 	}
 
 	if (npm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (npm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", npm, npm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", npm, npm->cm.type,
 			nss_ppe_log_message_types_str[npm->cm.type],
 			npm->cm.response, nss_cmn_response_str[npm->cm.response]);
 		goto verbose;
 	}
 
 	if (npm->cm.error >= PPE_ERROR_MAX) {
-		nss_warning("%p: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
+		nss_warning("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
 			npm, npm->cm.type, nss_ppe_log_message_types_str[npm->cm.type],
 			npm->cm.response, nss_cmn_response_str[npm->cm.response],
 			npm->cm.error);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
 		npm, npm->cm.type, nss_ppe_log_message_types_str[npm->cm.type],
 		npm->cm.response, nss_cmn_response_str[npm->cm.response],
 		npm->cm.error, nss_ppe_log_error_response_types_str[npm->cm.error]);
--- a/nss_ppe_vp.c
+++ b/nss_ppe_vp.c
@@ -90,12 +90,12 @@ nss_tx_status_t nss_ppe_vp_tx_msg(struct
 	 * Sanity check the message
 	 */
 	if (ncm->type >= NSS_PPE_VP_MSG_MAX) {
-		nss_warning("%p: message type out of range: %d\n", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d\n", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
 	if (!nss_ppe_vp_verify_ifnum(ncm->interface)) {
-		nss_warning("%p: invalid interface %d\n", nss_ctx, ncm->interface);
+		nss_warning("%px: invalid interface %d\n", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
@@ -117,14 +117,14 @@ nss_tx_status_t nss_ppe_vp_tx_msg_sync(s
 
 	status = nss_ppe_vp_tx_msg(nss_ctx, npvm);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: ppe_tx_msg failed\n", nss_ctx);
+		nss_warning("%px: ppe_tx_msg failed\n", nss_ctx);
 		up(&ppe_vp_pvt.sem);
 		return status;
 	}
 
 	ret = wait_for_completion_timeout(&ppe_vp_pvt.complete, msecs_to_jiffies(NSS_PPE_VP_TX_TIMEOUT));
 	if (!ret) {
-		nss_warning("%p: ppe_vp msg tx failed due to timeout\n", nss_ctx);
+		nss_warning("%px: ppe_vp msg tx failed due to timeout\n", nss_ctx);
 		ppe_vp_pvt.response = NSS_TX_FAILURE;
 	}
 
@@ -145,13 +145,13 @@ nss_tx_status_t nss_ppe_vp_tx_config_msg
 	nss_tx_status_t status;
 
 	if (type >= NSS_DYNAMIC_INTERFACE_TYPE_MAX) {
-		nss_warning("%p: Dynamic if msg drooped as type is wrong:%d\n", nss_ctx, type);
+		nss_warning("%px: Dynamic if msg drooped as type is wrong:%d\n", nss_ctx, type);
 		return -1;
 	}
 
 	npvm = kzalloc(sizeof(struct nss_ppe_vp_msg), GFP_KERNEL);
 	if (!npvm) {
-		nss_warning("%p: Unable to allocate message\n", nss_ctx);
+		nss_warning("%px: Unable to allocate message\n", nss_ctx);
 		return -1;
 	}
 
@@ -164,7 +164,7 @@ nss_tx_status_t nss_ppe_vp_tx_config_msg
 
 	status = nss_ppe_vp_tx_msg_sync(nss_ctx, npvm);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: Unable to send ppe_vp config message for type:%d\n", nss_ctx, type);
+		nss_warning("%px: Unable to send ppe_vp config message for type:%d\n", nss_ctx, type);
 	}
 
 	kfree(npvm);
@@ -181,7 +181,7 @@ static void nss_ppe_vp_handler(struct ns
 	nss_ppe_vp_msg_callback_t cb;
 	void *ctx;
 
-	nss_trace("nss_ctx: %p ppe_vp msg: %p\n", nss_ctx, msg);
+	nss_trace("nss_ctx: %px ppe_vp msg: %px\n", nss_ctx, msg);
 	BUG_ON(!nss_ppe_vp_verify_ifnum(ncm->interface));
 
 	/*
@@ -193,12 +193,12 @@ static void nss_ppe_vp_handler(struct ns
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >= NSS_PPE_VP_MSG_MAX) {
-		nss_warning("%p: received invalid message %d for PPE_VP interface\n", nss_ctx, ncm->type);
+		nss_warning("%px: received invalid message %d for PPE_VP interface\n", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_ppe_vp_msg)) {
-		nss_warning("%p: Length of message is greater than required: %d\n", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: Length of message is greater than required: %d\n", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
@@ -389,7 +389,7 @@ void nss_ppe_vp_register_handler(void)
 
 	nss_ppe_vp_dentry = nss_ppe_vp_stats_dentry_create();
 	if (nss_ppe_vp_dentry == NULL) {
-		nss_warning("%p: Not able to create debugfs entry\n", nss_ctx);
+		nss_warning("%px: Not able to create debugfs entry\n", nss_ctx);
 		return;
 	}
 
--- a/nss_ppe_vp_log.c
+++ b/nss_ppe_vp_log.c
@@ -49,7 +49,7 @@ static int8_t *nss_ppe_vp_log_error_resp
 static void nss_ppe_vp_log_config_msg(struct nss_ppe_vp_msg *npvm)
 {
 	struct nss_ppe_vp_config_msg *npcm __maybe_unused = &npvm->msg.vp_config;
-	nss_trace("%p: NSS PPE VP configuration message:\n"
+	nss_trace("%px: NSS PPE VP configuration message:\n"
 		"Dynamic interface type: %d is_vp_support_enable: %d\n",
 		npcm, npcm->type, npcm->vp_enable);
 }
@@ -72,7 +72,7 @@ static void nss_ppe_vp_log_verbose(struc
 		break;
 
 	default:
-		nss_warning("%p: Invalid message type\n", npvm);
+		nss_warning("%px: Invalid message type\n", npvm);
 		break;
 	}
 }
@@ -84,11 +84,11 @@ static void nss_ppe_vp_log_verbose(struc
 void nss_ppe_vp_log_tx_msg(struct nss_ppe_vp_msg *npvm)
 {
 	if (npvm->cm.type >= NSS_PPE_VP_MSG_MAX) {
-		nss_warning("%p: Invalid message type\n", npvm);
+		nss_warning("%px: Invalid message type\n", npvm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", npvm, npvm->cm.type, nss_ppe_vp_log_message_types_str[npvm->cm.type]);
+	nss_info("%px: type[%d]:%s\n", npvm, npvm->cm.type, nss_ppe_vp_log_message_types_str[npvm->cm.type]);
 	nss_ppe_vp_log_verbose(npvm);
 }
 
@@ -99,26 +99,26 @@ void nss_ppe_vp_log_tx_msg(struct nss_pp
 void nss_ppe_vp_log_rx_msg(struct nss_ppe_vp_msg *npvm)
 {
 	if (npvm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", npvm);
+		nss_warning("%px: Invalid response\n", npvm);
 		return;
 	}
 
 	if (npvm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (npvm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", npvm, npvm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", npvm, npvm->cm.type,
 			nss_ppe_vp_log_message_types_str[npvm->cm.type],
 			npvm->cm.response, nss_cmn_response_str[npvm->cm.response]);
 		goto verbose;
 	}
 
 	if (npvm->cm.error >= NSS_PPE_VP_MSG_ERROR_TYPE_MAX) {
-		nss_warning("%p: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
+		nss_warning("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
 			npvm, npvm->cm.type, nss_ppe_vp_log_message_types_str[npvm->cm.type],
 			npvm->cm.response, nss_cmn_response_str[npvm->cm.response],
 			npvm->cm.error);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
 		npvm, npvm->cm.type, nss_ppe_vp_log_message_types_str[npvm->cm.type],
 		npvm->cm.response, nss_cmn_response_str[npvm->cm.response],
 		npvm->cm.error, nss_ppe_vp_log_error_response_types_str[npvm->cm.error]);
--- a/nss_pppoe.c
+++ b/nss_pppoe.c
@@ -80,13 +80,13 @@ static nss_tx_status_t nss_pppoe_tx_msg(
 	 */
 	type = nss_dynamic_interface_get_type(nss_pppoe_get_context(), ncm->interface);
 	if ((ncm->interface != NSS_PPPOE_INTERFACE) && (type != NSS_DYNAMIC_INTERFACE_TYPE_PPPOE)) {
-		nss_warning("%p: tx request for not PPPoE interface: %d type: %d\n",
+		nss_warning("%px: tx request for not PPPoE interface: %d type: %d\n",
 				nss_ctx, ncm->interface, type);
 		return NSS_TX_FAILURE;
 	}
 
 	if (ncm->type >= NSS_PPPOE_MSG_MAX) {
-		nss_warning("%p: message type out of range: %d\n", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d\n", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
@@ -139,12 +139,12 @@ static void nss_pppoe_handler(struct nss
 	 * Sanity check the message type
 	 */
 	if (ncm->type >= NSS_PPPOE_MSG_MAX) {
-		nss_warning("%p: message type out of range: %d\n", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d\n", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_pppoe_msg)) {
-		nss_warning("%p: message length is invalid: %d\n", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: message length is invalid: %d\n", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
@@ -165,7 +165,7 @@ static void nss_pppoe_handler(struct nss
 		nss_pppoe_stats_notify(nss_ctx, ncm->interface);
 		break;
 	default:
-		nss_warning("%p: Received response %d for type %d, interface %d\n",
+		nss_warning("%px: Received response %d for type %d, interface %d\n",
 				nss_ctx, ncm->response, ncm->type, ncm->interface);
 	}
 
@@ -227,7 +227,7 @@ int nss_pppoe_br_accel_mode_handler(stru
 
 	new_val = nss_pppoe_br_accel_mode;
 	if ((new_val < NSS_PPPOE_BR_ACCEL_MODE_DIS) || (new_val >= NSS_PPPOE_BR_ACCEL_MODE_MAX)) {
-		nss_warning("%p: value out of range: %d\n", nss_ctx, new_val);
+		nss_warning("%px: value out of range: %d\n", nss_ctx, new_val);
 		nss_pppoe_br_accel_mode = current_value;
 		nss_pppoe_br_help(new_val);
 		return -EINVAL;
@@ -242,7 +242,7 @@ int nss_pppoe_br_accel_mode_handler(stru
 
 	status = nss_pppoe_tx_msg_sync(nss_ctx, &npm);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: Send acceleration mode message failed\n", nss_ctx);
+		nss_warning("%px: Send acceleration mode message failed\n", nss_ctx);
 		nss_pppoe_br_accel_mode = current_value;
 		return -EIO;
 	}
@@ -278,14 +278,14 @@ nss_tx_status_t nss_pppoe_tx_msg_sync(st
 
 	status = nss_pppoe_tx_msg(nss_ctx, msg);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: nss_pppoe_tx_msg failed\n", nss_ctx);
+		nss_warning("%px: nss_pppoe_tx_msg failed\n", nss_ctx);
 		up(&pppoe_pvt.sem);
 		return status;
 	}
 
 	ret = wait_for_completion_timeout(&pppoe_pvt.complete, msecs_to_jiffies(NSS_PPPOE_TX_TIMEOUT));
 	if (!ret) {
-		nss_warning("%p: PPPoE msg tx failed due to timeout\n", nss_ctx);
+		nss_warning("%px: PPPoE msg tx failed due to timeout\n", nss_ctx);
 		pppoe_pvt.response = NSS_TX_FAILURE;
 	}
 
--- a/nss_pppoe_log.c
+++ b/nss_pppoe_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -38,7 +38,7 @@ static int8_t *nss_pppoe_log_message_typ
 static void nss_pppoe_log_session_create_msg(struct nss_pppoe_msg *npm)
 {
 	struct nss_pppoe_create_msg *npcm __maybe_unused = &npm->msg.create;
-	nss_trace("%p: NSS PPPOE Session Create message \n"
+	nss_trace("%px: NSS PPPOE Session Create message \n"
 		"PPPOE Base Interface Number: %d\n"
 		"PPPOE MTU: %d\n"
 		"PPPOE Server MAC: %pM\n"
@@ -56,7 +56,7 @@ static void nss_pppoe_log_session_create
 static void nss_pppoe_log_session_destroy_msg(struct nss_pppoe_msg *npm)
 {
 	struct nss_pppoe_destroy_msg *npdm __maybe_unused = &npm->msg.destroy;
-	nss_trace("%p: NSS PPPOE Session Destroy message \n"
+	nss_trace("%px: NSS PPPOE Session Destroy message \n"
 		"PPPOE Session ID: %d\n"
 		"PPPOE Server MAC: %pM\n"
 		"PPPOE Local MAC: %pM\n",
@@ -86,7 +86,7 @@ static void nss_pppoe_log_verbose(struct
 		break;
 
 	default:
-		nss_trace("%p: Invalid message type\n", npm);
+		nss_trace("%px: Invalid message type\n", npm);
 		break;
 	}
 }
@@ -98,11 +98,11 @@ static void nss_pppoe_log_verbose(struct
 void nss_pppoe_log_tx_msg(struct nss_pppoe_msg *npm)
 {
 	if (npm->cm.type >= NSS_PPPOE_MSG_MAX) {
-		nss_warning("%p: Invalid message type\n", npm);
+		nss_warning("%px: Invalid message type\n", npm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", npm, npm->cm.type, nss_pppoe_log_message_types_str[npm->cm.type]);
+	nss_info("%px: type[%d]:%s\n", npm, npm->cm.type, nss_pppoe_log_message_types_str[npm->cm.type]);
 	nss_pppoe_log_verbose(npm);
 }
 
@@ -113,18 +113,18 @@ void nss_pppoe_log_tx_msg(struct nss_ppp
 void nss_pppoe_log_rx_msg(struct nss_pppoe_msg *npm)
 {
 	if (npm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", npm);
+		nss_warning("%px: Invalid response\n", npm);
 		return;
 	}
 
 	if (npm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (npm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", npm, npm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", npm, npm->cm.type,
 			nss_pppoe_log_message_types_str[npm->cm.type],
 			npm->cm.response, nss_cmn_response_str[npm->cm.response]);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s\n",
 		npm, npm->cm.type, nss_pppoe_log_message_types_str[npm->cm.type],
 		npm->cm.response, nss_cmn_response_str[npm->cm.response]);
 
--- a/nss_pptp.c
+++ b/nss_pptp.c
@@ -184,12 +184,12 @@ static void nss_pptp_handler(struct nss_
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >= NSS_PPTP_MSG_MAX) {
-		nss_warning("%p: received invalid message %d for PPTP interface", nss_ctx, ncm->type);
+		nss_warning("%px: received invalid message %d for PPTP interface", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_pptp_msg)) {
-		nss_warning("%p: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
@@ -235,7 +235,7 @@ static void nss_pptp_handler(struct nss_
 	 * call pptp tunnel callback
 	 */
 	if (!cb) {
-		nss_warning("%p: Event received for pptp tunnel interface %d before registration", nss_ctx, ncm->interface);
+		nss_warning("%px: Event received for pptp tunnel interface %d before registration", nss_ctx, ncm->interface);
 		return;
 	}
 
@@ -259,12 +259,12 @@ static nss_tx_status_t nss_pptp_tx_msg(s
 	 * Sanity check the message
 	 */
 	if (!nss_is_dynamic_interface(ncm->interface)) {
-		nss_warning("%p: tx request for non dynamic interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: tx request for non dynamic interface: %d", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
 	if (ncm->type > NSS_PPTP_MSG_MAX) {
-		nss_warning("%p: message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
@@ -322,7 +322,7 @@ nss_tx_status_t nss_pptp_tx_msg_sync(str
 
 	status = nss_pptp_tx_msg(nss_ctx, msg);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: pptp_tx_msg failed\n", nss_ctx);
+		nss_warning("%px: pptp_tx_msg failed\n", nss_ctx);
 		up(&pptp_pvt.sem);
 		return status;
 	}
@@ -330,7 +330,7 @@ nss_tx_status_t nss_pptp_tx_msg_sync(str
 	ret = wait_for_completion_timeout(&pptp_pvt.complete, msecs_to_jiffies(NSS_PPTP_TX_TIMEOUT));
 
 	if (!ret) {
-		nss_warning("%p: PPTP msg tx failed due to timeout\n", nss_ctx);
+		nss_warning("%px: PPTP msg tx failed due to timeout\n", nss_ctx);
 		pptp_pvt.response = NSS_TX_FAILURE;
 	}
 
@@ -345,7 +345,7 @@ nss_tx_status_t nss_pptp_tx_msg_sync(str
  */
 nss_tx_status_t nss_pptp_tx_buf(struct nss_ctx_instance *nss_ctx, uint32_t if_num, struct sk_buff *skb)
 {
-	nss_trace("%p: pptp If Tx packet, id:%d, data=%p", nss_ctx, if_num, skb->data);
+	nss_trace("%px: pptp If Tx packet, id:%d, data=%px", nss_ctx, if_num, skb->data);
 
 	return nss_core_send_packet(nss_ctx, skb, if_num, H2N_BIT_FLAG_BUFFER_REUSABLE);
 }
--- a/nss_pptp_log.c
+++ b/nss_pptp_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -38,7 +38,7 @@ static int8_t *nss_pptp_log_message_type
 static void nss_pptp_log_configure_msg(struct nss_pptp_msg *npm)
 {
 	struct nss_pptp_session_configure_msg *npcm __maybe_unused = &npm->msg.session_configure_msg;
-	nss_trace("%p: NSS PPTP Session Configure message\n"
+	nss_trace("%px: NSS PPTP Session Configure message\n"
 		"PPTP Source Call ID: %x\n"
 		"PPTP Destination Call ID: %x\n"
 		"PPTP Source IP: %pI4\n"
@@ -55,7 +55,7 @@ static void nss_pptp_log_configure_msg(s
 static void nss_pptp_log_deconfigure_msg(struct nss_pptp_msg *npm)
 {
 	struct nss_pptp_session_deconfigure_msg *npdm __maybe_unused = &npm->msg.session_deconfigure_msg;
-	nss_trace("%p: NSS PPTP Session Configure message \n"
+	nss_trace("%px: NSS PPTP Session Configure message \n"
 		"PPTP Source Call ID: %x\n",
 		npdm, npdm->src_call_id);
 }
@@ -82,7 +82,7 @@ static void nss_pptp_log_verbose(struct
 		break;
 
 	default:
-		nss_trace("%p: Invalid message type\n", npm);
+		nss_trace("%px: Invalid message type\n", npm);
 		break;
 	}
 }
@@ -94,11 +94,11 @@ static void nss_pptp_log_verbose(struct
 void nss_pptp_log_tx_msg(struct nss_pptp_msg *npm)
 {
 	if (npm->cm.type >= NSS_PPTP_MSG_MAX) {
-		nss_warning("%p: Invalid message type\n", npm);
+		nss_warning("%px: Invalid message type\n", npm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", npm, npm->cm.type, nss_pptp_log_message_types_str[npm->cm.type]);
+	nss_info("%px: type[%d]:%s\n", npm, npm->cm.type, nss_pptp_log_message_types_str[npm->cm.type]);
 	nss_pptp_log_verbose(npm);
 }
 
@@ -109,18 +109,18 @@ void nss_pptp_log_tx_msg(struct nss_pptp
 void nss_pptp_log_rx_msg(struct nss_pptp_msg *npm)
 {
 	if (npm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", npm);
+		nss_warning("%px: Invalid response\n", npm);
 		return;
 	}
 
 	if (npm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (npm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", npm, npm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", npm, npm->cm.type,
 			nss_pptp_log_message_types_str[npm->cm.type],
 			npm->cm.response, nss_cmn_response_str[npm->cm.response]);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s\n",
 		npm, npm->cm.type, nss_pptp_log_message_types_str[npm->cm.type],
 		npm->cm.response, nss_cmn_response_str[npm->cm.response]);
 
--- a/nss_profiler.c
+++ b/nss_profiler.c
@@ -32,23 +32,23 @@ static void nss_profiler_rx_msg_handler(
 	nss_profiler_callback_t cb = nss_ctx->nss_top->profiler_callback[nss_ctx->id];
 
 	if (ncm->type >= NSS_PROFILER_MAX_MSG_TYPES) {
-		nss_warning("%p: message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (ncm->type <= NSS_PROFILER_FLOWCTRL_MSG) {
 		if (ncm->len > sizeof(pm->payload.pcmdp)) {
-			nss_warning("%p: reply for cmd %d size is wrong %d : %d\n", nss_ctx, ncm->type, ncm->len, ncm->interface);
+			nss_warning("%px: reply for cmd %d size is wrong %d : %d\n", nss_ctx, ncm->type, ncm->len, ncm->interface);
 			return;
 		}
 	} else if (ncm->type <= NSS_PROFILER_DEBUG_REPLY_MSG) {
 		if (ncm->len > sizeof(pm->payload.pdm)) {
-			nss_warning("%p: reply for debug %d is too big %d\n", nss_ctx, ncm->type, ncm->len);
+			nss_warning("%px: reply for debug %d is too big %d\n", nss_ctx, ncm->type, ncm->len);
 			return;
 		}
 	} else if (ncm->type <= NSS_PROFILER_COUNTERS_MSG) {
 		if (ncm->len < (sizeof(pm->payload.pcmdp) - (PROFILE_MAX_APP_COUNTERS - pm->payload.pcmdp.num_counters) * sizeof(pm->payload.pcmdp.counters[0])) || ncm->len > sizeof(pm->payload.pcmdp)) {
-			nss_warning("%p: %d params data is too big %d : %d\n", nss_ctx, ncm->type, ncm->len, ncm->interface);
+			nss_warning("%px: %d params data is too big %d : %d\n", nss_ctx, ncm->type, ncm->len, ncm->interface);
 			return;
 		}
 	}
@@ -57,7 +57,7 @@ static void nss_profiler_rx_msg_handler(
 	 * status per request callback
 	 */
 	if (ncm->response != NSS_CMN_RESPONSE_NOTIFY && ncm->cb) {
-		nss_info("%p: reply CB %p for %d %d\n", nss_ctx, (void *)ncm->cb, ncm->type, ncm->response);
+		nss_info("%px: reply CB %px for %d %d\n", nss_ctx, (void *)ncm->cb, ncm->type, ncm->response);
 		cb = (nss_profiler_callback_t)ncm->cb;
 	}
 
@@ -65,7 +65,7 @@ static void nss_profiler_rx_msg_handler(
 	 * sample related callback
 	 */
 	if (!cb || !ctx) {
-		nss_warning("%p: Event received for profiler interface before registration", nss_ctx);
+		nss_warning("%px: Event received for profiler interface before registration", nss_ctx);
 		return;
 	}
 
@@ -84,22 +84,22 @@ nss_tx_status_t nss_profiler_if_tx_buf(v
 	struct nss_profiler_data_msg *pdm = (struct nss_profiler_data_msg *)buf;
 	nss_tx_status_t ret;
 
-	nss_trace("%p: Profiler If Tx, buf=%p", nss_ctx, buf);
+	nss_trace("%px: Profiler If Tx, buf=%px", nss_ctx, buf);
 
 	if (sizeof(npm->payload) < len) {
-		nss_warning("%p: (%u)Bad message length(%u)", nss_ctx, NSS_PROFILER_INTERFACE, len);
+		nss_warning("%px: (%u)Bad message length(%u)", nss_ctx, NSS_PROFILER_INTERFACE, len);
 		return NSS_TX_FAILURE_TOO_LARGE;
 	}
 
 	if (NSS_NBUF_PAYLOAD_SIZE < (len + sizeof(npm->cm))) {
-		nss_warning("%p: (%u)Message length(%u) is larger than payload size (%u)",
+		nss_warning("%px: (%u)Message length(%u) is larger than payload size (%u)",
 			nss_ctx, NSS_PROFILER_INTERFACE, (uint32_t)(len + sizeof(npm->cm)), NSS_NBUF_PAYLOAD_SIZE);
 		return NSS_TX_FAILURE_TOO_LARGE;
 	}
 
 	npm = kzalloc(sizeof(*npm), GFP_KERNEL);
 	if (!npm) {
-		nss_warning("%p: Failed to allocate memory for message\n", nss_ctx);
+		nss_warning("%px: Failed to allocate memory for message\n", nss_ctx);
 		return NSS_TX_FAILURE;
 	}
 
@@ -166,7 +166,7 @@ bool nss_profile_dma_register_cb(struct
 				void (*cb)(void*), void *arg)
 {
 	struct nss_profile_sdma_ctrl *ctrl = (struct nss_profile_sdma_ctrl *)nss_ctx->meminfo_ctx.sdma_ctrl;
-	nss_info("%p dma_register_cb %d: %p %p\n", ctrl, id, cb, arg);
+	nss_info("%px dma_register_cb %d: %px %px\n", ctrl, id, cb, arg);
 	if (!ctrl)
 		return false;
 
--- a/nss_project.c
+++ b/nss_project.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -81,7 +81,7 @@ static void nss_project_wt_stats_enable_
 		return;
 	}
 
-	nss_info("%p: Received response ACK for worker thread stats enable msg.\n", nss_ctx);
+	nss_info("%px: Received response ACK for worker thread stats enable msg.\n", nss_ctx);
 
 	/*
 	 * If statistics have already been allocated, nothing else to do.
@@ -93,7 +93,7 @@ static void nss_project_wt_stats_enable_
 	stats_temp = nss_project_alloc_wt_stats(stats_enable->worker_thread_count,
 						stats_enable->irq_count);
 	if (unlikely(!stats_temp)) {
-		nss_warning("%p: Unable to allocate worker thread statistics.\n", nss_ctx);
+		nss_warning("%px: Unable to allocate worker thread statistics.\n", nss_ctx);
 		return;
 	}
 
@@ -116,7 +116,7 @@ static nss_tx_status_t nss_project_wt_st
 
 	npm = kzalloc(sizeof(*npm), GFP_KERNEL);
 	if (!npm) {
-		nss_warning("%p: Failed to allocate buffer for message\n", nss_ctx);
+		nss_warning("%px: Failed to allocate buffer for message\n", nss_ctx);
 		return NSS_TX_FAILURE;
 	}
 
@@ -147,17 +147,17 @@ static void nss_project_wt_stats_update(
 	int i;
 
 	if (unlikely(!nss_ctx->wt_stats)) {
-		nss_warning("%p: Worker thread statistics not yet allocated.\n", nss_ctx);
+		nss_warning("%px: Worker thread statistics not yet allocated.\n", nss_ctx);
 		return;
 	}
 
 	if (unlikely(stats_notify->threadno >= nss_ctx->worker_thread_count)) {
-		nss_warning("%p: Invalid WT number %d\n", nss_ctx, stats_notify->threadno);
+		nss_warning("%px: Invalid WT number %d\n", nss_ctx, stats_notify->threadno);
 		return;
 	}
 
 	if (unlikely(stats_notify->stats_written > NSS_PROJECT_IRQS_PER_MESSAGE)) {
-		nss_warning("%p: Invalid worker thread stats written count %d\n",
+		nss_warning("%px: Invalid worker thread stats written count %d\n",
 				nss_ctx, stats_notify->stats_written);
 		return;
 	}
@@ -165,7 +165,7 @@ static void nss_project_wt_stats_update(
 	wt_stats = &(nss_ctx->wt_stats[stats_notify->threadno]);
 
 	if (unlikely(!wt_stats->irq_stats)) {
-		nss_warning("%p: Worker thread statistics not allocated for thread %d\n",
+		nss_warning("%px: Worker thread statistics not allocated for thread %d\n",
 				nss_ctx, stats_notify->threadno);
 		return;
 	}
@@ -174,7 +174,7 @@ static void nss_project_wt_stats_update(
 	for (i = 0; i < stats_notify->stats_written; ++i) {
 		int irq = stats_notify->stats[i].irq;
 		if (unlikely(irq >= nss_ctx->irq_count)) {
-			nss_warning("%p: Invalid IRQ number %d\n", nss_ctx, irq);
+			nss_warning("%px: Invalid IRQ number %d\n", nss_ctx, irq);
 			continue;
 		}
 
@@ -197,12 +197,12 @@ static void nss_project_msg_handler(stru
 	 * Sanity checks on message
 	 */
 	if (npm->cm.type >= NSS_PROJECT_MSG_MAX) {
-		nss_warning("%p: message type out of range: %d\n", nss_ctx, npm->cm.type);
+		nss_warning("%px: message type out of range: %d\n", nss_ctx, npm->cm.type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(&(npm->cm)) > sizeof(struct nss_project_msg)) {
-		nss_warning("%p: message length is invalid: %d\n", nss_ctx, nss_cmn_get_msg_len(&(npm->cm)));
+		nss_warning("%px: message length is invalid: %d\n", nss_ctx, nss_cmn_get_msg_len(&(npm->cm)));
 		return;
 	}
 
--- a/nss_pvxlan.c
+++ b/nss_pvxlan.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -84,13 +84,13 @@ static bool nss_pvxlan_hdl_instance_free
 	h = nss_pvxlan_hdl[if_num - NSS_DYNAMIC_IF_START];
 	if (!h) {
 		spin_unlock(&nss_pvxlan_spinlock);
-		nss_warning("%p: Instance does not exist: %d", nss_ctx, if_num);
+		nss_warning("%px: Instance does not exist: %d", nss_ctx, if_num);
 		return false;
 	}
 
 	if (h->if_num != if_num) {
 		spin_unlock(&nss_pvxlan_spinlock);
-		nss_warning("%p: Not correct if_num: %d", nss_ctx, if_num);
+		nss_warning("%px: Not correct if_num: %d", nss_ctx, if_num);
 		return false;
 	}
 
@@ -114,7 +114,7 @@ static bool nss_pvxlan_hdl_instance_allo
 	 */
 	h = kzalloc(sizeof(struct nss_pvxlan_handle), GFP_ATOMIC);
 	if (!h) {
-		nss_warning("%p: no memory for allocating PVxLAN handle instance for interface : %d", nss_ctx, if_num);
+		nss_warning("%px: no memory for allocating PVxLAN handle instance for interface : %d", nss_ctx, if_num);
 		return false;
 	}
 	h->if_num = if_num;
@@ -123,7 +123,7 @@ static bool nss_pvxlan_hdl_instance_allo
 	if (nss_pvxlan_hdl[if_num - NSS_DYNAMIC_IF_START] != NULL) {
 		spin_unlock(&nss_pvxlan_spinlock);
 		kfree(h);
-		nss_warning("%p: The handle has been taken by another thread :%d", nss_ctx, if_num);
+		nss_warning("%px: The handle has been taken by another thread :%d", nss_ctx, if_num);
 		return false;
 	}
 
@@ -175,12 +175,12 @@ static void nss_pvxlan_msg_handler(struc
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >= NSS_PVXLAN_MSG_TYPE_MAX) {
-		nss_warning("%p: received invalid message %d for PVXLAN interface", nss_ctx, ncm->type);
+		nss_warning("%px: received invalid message %d for PVXLAN interface", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_pvxlan_msg)) {
-		nss_warning("%p: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
@@ -196,7 +196,6 @@ static void nss_pvxlan_msg_handler(struc
 		break;
 	}
 
-
 	/*
 	 * Update the callback and app_data for NOTIFY messages.
 	 */
@@ -218,7 +217,7 @@ static void nss_pvxlan_msg_handler(struc
 	 * Do we have a callback
 	 */
 	if (!cb) {
-		nss_trace("%p: cb is null for interface %d", nss_ctx, ncm->interface);
+		nss_trace("%px: cb is null for interface %d", nss_ctx, ncm->interface);
 		return;
 	}
 
@@ -265,14 +264,14 @@ nss_tx_status_t nss_pvxlan_tx_msg_sync(s
 
 	status = nss_pvxlan_tx_msg(nss_ctx, nvxm);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: pvxlan_tx_msg failed\n", nss_ctx);
+		nss_warning("%px: pvxlan_tx_msg failed\n", nss_ctx);
 		up(&pvxlan_pvt.sem);
 		return status;
 	}
 
 	ret = wait_for_completion_timeout(&pvxlan_pvt.complete, msecs_to_jiffies(NSS_PVXLAN_TX_TIMEOUT));
 	if (!ret) {
-		nss_warning("%p: pvxlan tx sync failed due to timeout\n", nss_ctx);
+		nss_warning("%px: pvxlan tx sync failed due to timeout\n", nss_ctx);
 		pvxlan_pvt.response = NSS_TX_FAILURE;
 	}
 
@@ -311,7 +310,7 @@ bool nss_pvxlan_unregister(uint32_t if_n
 
 	nss_ctx = nss_pvxlan_get_ctx();
 	if (!nss_pvxlan_verify_if_num(if_num)) {
-		nss_warning("%p: data unregister received for invalid interface %d", nss_ctx, if_num);
+		nss_warning("%px: data unregister received for invalid interface %d", nss_ctx, if_num);
 		return false;
 	}
 
@@ -350,19 +349,19 @@ struct nss_ctx_instance *nss_pvxlan_regi
 
 	nss_ctx = nss_pvxlan_get_ctx();
 	if (!nss_pvxlan_verify_if_num(if_num)) {
-		nss_warning("%p: data register received for invalid interface %d", nss_ctx, if_num);
+		nss_warning("%px: data register received for invalid interface %d", nss_ctx, if_num);
 		return NULL;
 	}
 
 	core_status = nss_core_register_handler(nss_ctx, if_num, nss_pvxlan_msg_handler, NULL);
 	if (core_status != NSS_CORE_STATUS_SUCCESS) {
-		nss_warning("%p: nss core register handler failed for if_num:%d with error :%d", nss_ctx, if_num, core_status);
+		nss_warning("%px: nss core register handler failed for if_num:%d with error :%d", nss_ctx, if_num, core_status);
 		return NULL;
 	}
 
 	if (!nss_pvxlan_hdl_instance_alloc(nss_ctx, if_num, notify_cb, (void *)netdev)) {
 		nss_core_unregister_handler(nss_ctx, if_num);
-		nss_warning("%p: couldn't allocate handle instance for if_num:%d", nss_ctx, if_num);
+		nss_warning("%px: couldn't allocate handle instance for if_num:%d", nss_ctx, if_num);
 		return NULL;
 	}
 
@@ -380,7 +379,7 @@ struct nss_ctx_instance *nss_pvxlan_regi
 	spin_unlock_bh(&nss_pvxlan_tunnel_stats_debug_lock);
 
 	if (i == NSS_PVXLAN_MAX_INTERFACES) {
-		nss_warning("%p: No available debug stats instance :%d", nss_ctx, if_num);
+		nss_warning("%px: No available debug stats instance :%d", nss_ctx, if_num);
 		nss_pvxlan_hdl_instance_free(nss_ctx, if_num);
 		nss_core_unregister_handler(nss_ctx, if_num);
 		return NULL;
@@ -402,7 +401,7 @@ int nss_pvxlan_ifnum_with_core_id(int if
 	NSS_VERIFY_CTX_MAGIC(nss_ctx);
 
 	if (!nss_is_dynamic_interface(if_num)) {
-		nss_warning("%p: Invalid if_num: %d, must be a dynamic interface\n", nss_ctx, if_num);
+		nss_warning("%px: Invalid if_num: %d, must be a dynamic interface\n", nss_ctx, if_num);
 		return 0;
 	}
 	return NSS_INTERFACE_NUM_APPEND_COREID(nss_ctx, if_num);
--- a/nss_pvxlan_log.c
+++ b/nss_pvxlan_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -58,10 +58,10 @@ static int8_t *nss_pvxlan_log_error_resp
  */
 static void nss_pvxlan_log_rule_msg(struct nss_pvxlan_rule_msg *npvrm)
 {
-	nss_trace("%p: NSS PVXLAN Rule message \n"
-		"Encap Rule Src IP: %p\n"
+	nss_trace("%px: NSS PVXLAN Rule message \n"
+		"Encap Rule Src IP: %px\n"
 		"Encap Rule Src Port: %d\n"
-		"Encap Rule Dst Ip: %p\n"
+		"Encap Rule Dst Ip: %px\n"
 		"Encap Rule Dst Port: %d\n"
 		"RPS: %d\n"
 		"Flags: %x\n"
@@ -81,7 +81,7 @@ static void nss_pvxlan_log_rule_msg(stru
  */
 static void nss_pvxlan_log_mac_msg(struct nss_pvxlan_mac_msg *npvcm)
 {
-	nss_trace("%p: NSS PVXLAN MAC message \n"
+	nss_trace("%px: NSS PVXLAN MAC message \n"
 		"PVxLAN Mac Addr: %x : %x : %x"
 		"PVxLAN Flags: %u\n"
 		"PVxLAN VNet ID: %u\n"
@@ -121,7 +121,7 @@ static void nss_pvxlan_log_rule_uncfg_ms
 static void nss_pvxlan_log_enable_msg(struct nss_pvxlan_msg *npvm)
 {
 	struct nss_pvxlan_tunnel_state_msg *npvrm __maybe_unused = &npvm->msg.enable;
-	nss_trace("%p: NSS PVXLAN Tunnel state message: Enable \n", npvrm);
+	nss_trace("%px: NSS PVXLAN Tunnel state message: Enable \n", npvrm);
 }
 
 /*
@@ -130,7 +130,7 @@ static void nss_pvxlan_log_enable_msg(st
  */
 static void nss_pvxlan_log_disable_msg(struct nss_pvxlan_msg *npvm)
 {
-	nss_trace("%p: NSS PVXLAN Tunnel state message: Disable \n", npvm);
+	nss_trace("%px: NSS PVXLAN Tunnel state message: Disable \n", npvm);
 }
 
 /*
@@ -188,7 +188,7 @@ static void nss_pvxlan_log_verbose(struc
 		break;
 
 	default:
-		nss_trace("%p: Invalid message type\n", npvm);
+		nss_trace("%px: Invalid message type\n", npvm);
 		break;
 	}
 }
@@ -200,11 +200,11 @@ static void nss_pvxlan_log_verbose(struc
 void nss_pvxlan_log_tx_msg(struct nss_pvxlan_msg *npvm)
 {
 	if (npvm->cm.type >= NSS_PVXLAN_MSG_TYPE_MAX) {
-		nss_warning("%p: Invalid message type\n", npvm);
+		nss_warning("%px: Invalid message type\n", npvm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", npvm, npvm->cm.type, nss_pvxlan_log_message_types_str[npvm->cm.type]);
+	nss_info("%px: type[%d]:%s\n", npvm, npvm->cm.type, nss_pvxlan_log_message_types_str[npvm->cm.type]);
 	nss_pvxlan_log_verbose(npvm);
 }
 
@@ -215,26 +215,26 @@ void nss_pvxlan_log_tx_msg(struct nss_pv
 void nss_pvxlan_log_rx_msg(struct nss_pvxlan_msg *npvm)
 {
 	if (npvm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", npvm);
+		nss_warning("%px: Invalid response\n", npvm);
 		return;
 	}
 
 	if (npvm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (npvm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", npvm, npvm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", npvm, npvm->cm.type,
 			nss_pvxlan_log_message_types_str[npvm->cm.type],
 			npvm->cm.response, nss_cmn_response_str[npvm->cm.response]);
 		goto verbose;
 	}
 
 	if (npvm->cm.error >= NSS_PVXLAN_ERROR_MAX) {
-		nss_warning("%p: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
+		nss_warning("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
 			npvm, npvm->cm.type, nss_pvxlan_log_message_types_str[npvm->cm.type],
 			npvm->cm.response, nss_cmn_response_str[npvm->cm.response],
 			npvm->cm.error);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
 		npvm, npvm->cm.type, nss_pvxlan_log_message_types_str[npvm->cm.type],
 		npvm->cm.response, nss_cmn_response_str[npvm->cm.response],
 		npvm->cm.error, nss_pvxlan_log_error_response_types_str[npvm->cm.error]);
--- a/nss_pvxlan_stats.c
+++ b/nss_pvxlan_stats.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -166,7 +166,7 @@ void nss_pvxlan_stats_sync(struct nss_ct
 
 	if (!s) {
 		spin_unlock_bh(&nss_pvxlan_tunnel_stats_debug_lock);
-		nss_warning("%p: Tunnel not found: %u", nss_ctx, if_num);
+		nss_warning("%px: Tunnel not found: %u", nss_ctx, if_num);
 		return;
 	}
 
--- a/nss_qrfs.c
+++ b/nss_qrfs.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -52,7 +52,7 @@ static void nss_qrfs_msg_handler(struct
 	nss_qrfs_log_rx_msg(nqm);
 
 	if (!nss_qrfs_verify_if_num(ncm->interface)) {
-		nss_warning("%p: invalid interface %d for QRFS\n", nss_ctx, ncm->interface);
+		nss_warning("%px: invalid interface %d for QRFS\n", nss_ctx, ncm->interface);
 		return;
 	}
 
@@ -60,12 +60,12 @@ static void nss_qrfs_msg_handler(struct
 	 * Is this a valid request/response?
 	 */
 	if (ncm->type >= NSS_QRFS_MSG_MAX) {
-		nss_warning("%p: invalid message %d for QRFS\n", nss_ctx, ncm->type);
+		nss_warning("%px: invalid message %d for QRFS\n", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_qrfs_msg)) {
-		nss_warning("%p: message length is greater than required: %d\n", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: message length is greater than required: %d\n", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
@@ -128,7 +128,7 @@ static bool nss_qrfs_get_flow_keys(struc
 
 	res = skb_flow_dissect(skb, &keys);
 	if (!res) {
-		nss_warning("%p: failed to get flow keys\n", nss_ctx);
+		nss_warning("%px: failed to get flow keys\n", nss_ctx);
 		return res;
 	}
 
@@ -146,7 +146,7 @@ static bool nss_qrfs_get_flow_keys(struc
 	nqfrm->ip_version = 6;
 	ip6hdr = (struct ipv6hdr *)skb_network_header(skb);
 	if (!ip6hdr) {
-		nss_warning("%p: failed to get IPv6 address\n", nss_ctx);
+		nss_warning("%px: failed to get IPv6 address\n", nss_ctx);
 		return false;
 	}
 
@@ -164,7 +164,7 @@ static bool nss_qrfs_get_flow_keys(struc
 
 	res = skb_flow_dissect_flow_keys(skb, &keys, 0);
 	if (!res) {
-		nss_warning("%p: failed to get flow keys\n", nss_ctx);
+		nss_warning("%px: failed to get flow keys\n", nss_ctx);
 		return res;
 	}
 
@@ -197,19 +197,19 @@ static void nss_qrfs_flow_add_msg_callba
 	struct nss_qrfs_flow_rule_msg *nqfrm;
 
 	if (nqm->cm.type != NSS_QRFS_MSG_FLOW_ADD) {
-		nss_warning("%p: invalid flow response message %d\n", nss_ctx, nqm->cm.type);
+		nss_warning("%px: invalid flow response message %d\n", nss_ctx, nqm->cm.type);
 		return;
 	}
 
 	nqfrm = &nqm->msg.flow_add;
 
 	if ((nqfrm->ip_version != 4) && (nqfrm->ip_version != 6)) {
-		nss_warning("%p: invalid IP version %d\n", nss_ctx, nqfrm->ip_version);
+		nss_warning("%px: invalid IP version %d\n", nss_ctx, nqfrm->ip_version);
 		return;
 	}
 
 	if (nqm->cm.response != NSS_CMN_RESPONSE_ACK) {
-		nss_warning("%p: flow add configuration error: %d for NSS core %d\n",
+		nss_warning("%px: flow add configuration error: %d for NSS core %d\n",
 				nss_ctx, nqm->cm.error, nss_ctx->id);
 	}
 }
@@ -224,19 +224,19 @@ static void nss_qrfs_flow_delete_msg_cal
 	struct nss_qrfs_flow_rule_msg *nqfrm;
 
 	if (nqm->cm.type != NSS_QRFS_MSG_FLOW_DELETE) {
-		nss_warning("%p: invalid flow response message %d\n", nss_ctx, nqm->cm.type);
+		nss_warning("%px: invalid flow response message %d\n", nss_ctx, nqm->cm.type);
 		return;
 	}
 
 	nqfrm = &nqm->msg.flow_delete;
 
 	if ((nqfrm->ip_version != 4) && (nqfrm->ip_version != 6)) {
-		nss_warning("%p: invalid IP version %d\n", nss_ctx, nqfrm->ip_version);
+		nss_warning("%px: invalid IP version %d\n", nss_ctx, nqfrm->ip_version);
 		return;
 	}
 
 	if (nqm->cm.response != NSS_CMN_RESPONSE_ACK) {
-		nss_warning("%p: flow delete configuration error: %d for NSS core %d\n",
+		nss_warning("%px: flow delete configuration error: %d for NSS core %d\n",
 				nss_ctx, nqm->cm.error, nss_ctx->id);
 	}
 }
@@ -267,12 +267,12 @@ static nss_tx_status_t nss_qrfs_tx_msg(s
 	 * Sanity check the message
 	 */
 	if (!nss_qrfs_verify_if_num(ncm->interface)) {
-		nss_warning("%p: interface is not QRFS interface: %d\n", nss_ctx, ncm->interface);
+		nss_warning("%px: interface is not QRFS interface: %d\n", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
 	if (ncm->type >= NSS_QRFS_MSG_MAX) {
-		nss_warning("%p: message type is out of range: %d\n", nss_ctx, ncm->type);
+		nss_warning("%px: message type is out of range: %d\n", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
@@ -405,7 +405,7 @@ nss_tx_status_t nss_qrfs_set_flow_rule(s
 		}
 
 		if (status != NSS_TX_SUCCESS) {
-			nss_warning("%p: failed to send flow rule to NSS core %d\n", nss_ctx, i);
+			nss_warning("%px: failed to send flow rule to NSS core %d\n", nss_ctx, i);
 			return NSS_TX_FAILURE;
 		}
 	}
--- a/nss_qrfs_log.c
+++ b/nss_qrfs_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -54,7 +54,7 @@ static int8_t *nss_qrfs_log_error_respon
  */
 static void nss_qrfs_log_flow_rule_msg(struct nss_qrfs_flow_rule_msg *nqfm)
 {
-	nss_trace("%p: NSS QRFS Flow Rule Message:\n"
+	nss_trace("%px: NSS QRFS Flow Rule Message:\n"
 		"QRFS Source Port: %d\n"
 		"QRFS Destination Port: %d\n"
 		"QRFS IP Version: %d\n"
@@ -86,7 +86,7 @@ static void nss_qrfs_log_flow_rule_msg(s
  */
 static void nss_qrfs_log_mac_rule_msg(struct nss_qrfs_mac_rule_msg *nqmm)
 {
-	nss_trace("%p: NSS QRFS MAC Rule Message:\n"
+	nss_trace("%px: NSS QRFS MAC Rule Message:\n"
 		"QRFS MAC: %pM\n"
 		"QRFS CPU ID: %d\n"
 		"QRFS Physical Interface Number: %d\n",
@@ -118,7 +118,7 @@ static void nss_qrfs_log_verbose(struct
 		break;
 
 	default:
-		nss_warning("%p: Invalid message type\n", nqm);
+		nss_warning("%px: Invalid message type\n", nqm);
 		break;
 	}
 }
@@ -130,11 +130,11 @@ static void nss_qrfs_log_verbose(struct
 void nss_qrfs_log_tx_msg(struct nss_qrfs_msg *nqm)
 {
 	if (nqm->cm.type >= NSS_QRFS_MSG_MAX) {
-		nss_warning("%p: Invalid message type\n", nqm);
+		nss_warning("%px: Invalid message type\n", nqm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", nqm, nqm->cm.type, nss_qrfs_log_message_types_str[nqm->cm.type]);
+	nss_info("%px: type[%d]:%s\n", nqm, nqm->cm.type, nss_qrfs_log_message_types_str[nqm->cm.type]);
 	nss_qrfs_log_verbose(nqm);
 }
 
@@ -145,26 +145,26 @@ void nss_qrfs_log_tx_msg(struct nss_qrfs
 void nss_qrfs_log_rx_msg(struct nss_qrfs_msg *nqm)
 {
 	if (nqm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", nqm);
+		nss_warning("%px: Invalid response\n", nqm);
 		return;
 	}
 
 	if (nqm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (nqm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", nqm, nqm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", nqm, nqm->cm.type,
 			nss_qrfs_log_message_types_str[nqm->cm.type],
 			nqm->cm.response, nss_cmn_response_str[nqm->cm.response]);
 		goto verbose;
 	}
 
 	if (nqm->cm.error >= NSS_QRFS_ERROR_MAX) {
-		nss_warning("%p: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
+		nss_warning("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
 			nqm, nqm->cm.type, nss_qrfs_log_message_types_str[nqm->cm.type],
 			nqm->cm.response, nss_cmn_response_str[nqm->cm.response],
 			nqm->cm.error);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
 		nqm, nqm->cm.type, nss_qrfs_log_message_types_str[nqm->cm.type],
 		nqm->cm.response, nss_cmn_response_str[nqm->cm.response],
 		nqm->cm.error, nss_qrfs_log_error_response_types_str[nqm->cm.error]);
--- a/nss_qvpn.c
+++ b/nss_qvpn.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -41,7 +41,7 @@ static bool nss_qvpn_verify_if_num(uint3
 	if_type = nss_dynamic_interface_get_type(nss_qvpn_get_context(), if_num);
 	if ((if_type != NSS_DYNAMIC_INTERFACE_TYPE_QVPN_INNER) &&
 	    (if_type != NSS_DYNAMIC_INTERFACE_TYPE_QVPN_OUTER)) {
-		nss_warning("%p: if_num = %u interface type returned is %d\n", nss_qvpn_get_context(), if_num, if_type);
+		nss_warning("%px: if_num = %u interface type returned is %d\n", nss_qvpn_get_context(), if_num, if_type);
 		return false;
 	}
 
@@ -94,12 +94,12 @@ static void nss_qvpn_handler(struct nss_
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >= NSS_QVPN_MSG_TYPE_MAX) {
-		nss_warning("%p: received invalid message %d for qvpn interface", nss_ctx, ncm->type);
+		nss_warning("%px: received invalid message %d for qvpn interface", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_qvpn_msg)) {
-		nss_warning("%p: length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
@@ -122,7 +122,7 @@ static void nss_qvpn_handler(struct nss_
 	 * to the same callback/app_data.
 	 */
 	if (ncm->response == NSS_CMN_RESPONSE_NOTIFY) {
-		ncm->cb = (nss_ptr_t)nss_top_main.if_rx_msg_callback[ncm->interface];
+		ncm->cb = (nss_ptr_t)nss_core_get_msg_handler(nss_ctx, ncm->interface);
 		ncm->app_data = (nss_ptr_t)nss_ctx->nss_rx_interface_handlers[nss_ctx->id][ncm->interface].app_data;
 	}
 
@@ -131,7 +131,7 @@ static void nss_qvpn_handler(struct nss_
 	 */
 	cb = (nss_qvpn_msg_callback_t)ncm->cb;
 	if (unlikely(!cb)) {
-		nss_trace("%p: rx handler unregistered for i/f: %u\n", nss_ctx, ncm->interface);
+		nss_trace("%px: rx handler unregistered for i/f: %u\n", nss_ctx, ncm->interface);
 		return;
 	}
 
@@ -187,12 +187,12 @@ nss_tx_status_t nss_qvpn_tx_msg(struct n
 	 * Sanity check the message
 	 */
 	if (!nss_qvpn_verify_if_num(ncm->interface)) {
-		nss_warning("%p: tx request for interface that is not a qvpn: %u\n", nss_ctx, ncm->interface);
+		nss_warning("%px: tx request for interface that is not a qvpn: %u\n", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
 	if (ncm->type >= NSS_QVPN_MSG_TYPE_MAX) {
-		nss_warning("%p: message type out of range: %d\n", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d\n", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
@@ -219,12 +219,12 @@ nss_tx_status_t nss_qvpn_tx_msg_sync(str
 	NSS_VERIFY_CTX_MAGIC(nss_ctx);
 
 	if (len > sizeof(nqm.msg)) {
-		nss_warning("%p: Incorrect message length=%u for type %d and if_num=%u\n", nss_ctx, len, type, if_num);
+		nss_warning("%px: Incorrect message length=%u for type %d and if_num=%u\n", nss_ctx, len, type, if_num);
 		return NSS_TX_FAILURE_TOO_LARGE;
 	}
 
 	if (!resp) {
-		nss_warning("%p: Invalid input, resp=NULL\n", nss_ctx);
+		nss_warning("%px: Invalid input, resp=NULL\n", nss_ctx);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
@@ -235,13 +235,13 @@ nss_tx_status_t nss_qvpn_tx_msg_sync(str
 
 	status = nss_qvpn_tx_msg(nss_ctx, &nqm);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: qvpn_tx_msg failed\n", nss_ctx);
+		nss_warning("%px: qvpn_tx_msg failed\n", nss_ctx);
 		goto done;
 	}
 
 	ret = wait_for_completion_timeout(&qvpn_pvt.complete, msecs_to_jiffies(NSS_QVPN_TX_TIMEOUT));
 	if (!ret) {
-		nss_warning("%p: qvpn msg tx failed due to timeout\n", nss_ctx);
+		nss_warning("%px: qvpn msg tx failed due to timeout\n", nss_ctx);
 		status = NSS_TX_FAILURE_SYNC_TIMEOUT;
 		goto done;
 	}
@@ -267,7 +267,7 @@ EXPORT_SYMBOL(nss_qvpn_tx_msg_sync);
 nss_tx_status_t nss_qvpn_tx_buf(struct nss_ctx_instance *nss_ctx, uint32_t if_num, struct sk_buff *skb)
 {
 	if (!nss_qvpn_verify_if_num(if_num)) {
-		nss_warning("%p: tx request for interface that is not a qvpn: %u\n", nss_ctx, if_num);
+		nss_warning("%px: tx request for interface that is not a qvpn: %u\n", nss_ctx, if_num);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
@@ -294,13 +294,18 @@ struct nss_ctx_instance *nss_qvpn_regist
 					      struct net_device *netdev, uint32_t features, void *app_ctx)
 {
 	struct nss_ctx_instance *nss_ctx = nss_qvpn_get_context();
+	uint32_t status;
 
 	nss_assert(nss_ctx);
 	nss_assert(nss_qvpn_verify_if_num(if_num));
 
 	nss_core_register_subsys_dp(nss_ctx, if_num, qvpn_data_callback, NULL, app_ctx, netdev, features);
 	nss_core_register_handler(nss_ctx, if_num, nss_qvpn_handler, app_ctx);
-	nss_top_main.if_rx_msg_callback[if_num] = qvpn_event_callback;
+	status = nss_core_register_msg_handler(nss_ctx, if_num, qvpn_event_callback);
+	if (status != NSS_CORE_STATUS_SUCCESS) {
+		nss_warning("%px: Not able to register handler for interface %d with NSS core\n", nss_ctx, if_num);
+		return NULL;
+	}
 
 	set_bit(if_num, qvpn_pvt.if_map);
 	return nss_ctx;
@@ -314,15 +319,24 @@ EXPORT_SYMBOL(nss_qvpn_register_if);
 void nss_qvpn_unregister_if(uint32_t if_num)
 {
 	struct nss_ctx_instance *nss_ctx = nss_qvpn_get_context();
+	uint32_t status;
 
 	nss_assert(nss_qvpn_verify_if_num(if_num));
 
 	clear_bit(if_num, qvpn_pvt.if_map);
 
 	nss_core_unregister_subsys_dp(nss_ctx, if_num);
-	nss_core_unregister_handler(nss_ctx, if_num);
+	status = nss_core_unregister_msg_handler(nss_ctx, if_num);
+	if (status != NSS_CORE_STATUS_SUCCESS) {
+		nss_warning("%px: Failed to unregister handler for IPsec NSS I/F:%u\n", nss_ctx, if_num);
+		return;
+	}
 
-	nss_top_main.if_rx_msg_callback[if_num] = NULL;
+	status = nss_core_unregister_handler(nss_ctx, if_num);
+	if (status != NSS_CORE_STATUS_SUCCESS) {
+		nss_warning("%px: Failed to unregister handler for IPsec NSS I/F:%u\n", nss_ctx, if_num);
+		return;
+	}
 }
 EXPORT_SYMBOL(nss_qvpn_unregister_if);
 
@@ -336,7 +350,7 @@ int nss_qvpn_ifnum_with_core_id(int if_n
 
 	NSS_VERIFY_CTX_MAGIC(nss_ctx);
 	if (nss_qvpn_verify_if_num(if_num) == false) {
-		nss_info("%p: if_num: %u is not QVPN interface\n", nss_ctx, if_num);
+		nss_info("%px: if_num: %u is not QVPN interface\n", nss_ctx, if_num);
 		return 0;
 	}
 	return NSS_INTERFACE_NUM_APPEND_COREID(nss_ctx, if_num);
--- a/nss_qvpn_log.c
+++ b/nss_qvpn_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -69,10 +69,10 @@ static int8_t *nss_qvpn_log_error_respon
 static void nss_qvpn_log_tun_config_msg(struct nss_qvpn_msg *ncm)
 {
 	struct nss_qvpn_tunnel_config_msg *nqtcm __maybe_unused = &ncm->msg.tunnel_config;
-	nss_trace("%p: NSS QVPN tunnel config message \n"
+	nss_trace("%px: NSS QVPN tunnel config message \n"
 		"Sibling interface: %d"
 		"Total number of commands: %d"
-		"Commands: %p"
+		"Commands: %px"
 		"Source IP: %x:%x:%x:%x\n"
 		"Source Port: %d\n"
 		"Destination IP:  %x:%x:%x:%x\n"
@@ -86,8 +86,8 @@ static void nss_qvpn_log_tun_config_msg(
 		"VPN header head size: %d\n"
 		"VPN header head offset: %d\n"
 		"VPN header tail size: %d\n"
-		"VPN header head: %p\n"
-		"VPN header tail: %p\n",
+		"VPN header head: %px\n"
+		"VPN header tail: %px\n",
 		nqtcm,
 		nqtcm->sibling_if,
 		nqtcm->total_cmds,
@@ -115,7 +115,7 @@ static void nss_qvpn_log_tun_config_msg(
  */
 static void nss_qvpn_log_tun_deconfig_msg(struct nss_qvpn_msg *ncm)
 {
-	nss_trace("%p: NSS QVPN deconfigure message \n", ncm);
+	nss_trace("%px: NSS QVPN deconfigure message \n", ncm);
 }
 
 /*
@@ -125,9 +125,9 @@ static void nss_qvpn_log_tun_deconfig_ms
 static void nss_qvpn_log_crypto_key_add_msg(struct nss_qvpn_msg *ncm)
 {
 	struct nss_qvpn_crypto_key_add_msg *nqckam __maybe_unused = &ncm->msg.key_add;
-	nss_trace("%p: NSS QVPN crypto key add message \n"
+	nss_trace("%px: NSS QVPN crypto key add message \n"
 		"Crypto index: %d\n"
-		"Crypto session ID: %p",
+		"Crypto session ID: %px",
 		nqckam,
 		nqckam->crypto_idx,
 		nqckam->session_id);
@@ -140,9 +140,9 @@ static void nss_qvpn_log_crypto_key_add_
 static void nss_qvpn_log_crypto_key_activate_msg(struct nss_qvpn_msg *ncm)
 {
 	struct nss_qvpn_crypto_key_activate_msg *nqckam __maybe_unused = &ncm->msg.key_activate;
-	nss_trace("%p: NSS QVPN crypto key activate message \n"
+	nss_trace("%px: NSS QVPN crypto key activate message \n"
 		"Crypto index: %d\n"
-		"Crypto VPN header head: %p",
+		"Crypto VPN header head: %px",
 		nqckam,
 		nqckam->crypto_idx,
 		nqckam->vpn_hdr_head);
@@ -155,7 +155,7 @@ static void nss_qvpn_log_crypto_key_acti
 static void nss_qvpn_log_crypto_key_del_msg(struct nss_qvpn_msg *ncm)
 {
 	struct nss_qvpn_crypto_key_del_msg *nqckdm __maybe_unused = &ncm->msg.key_del;
-	nss_trace("%p: NSS QVPN crypto key delete message \n"
+	nss_trace("%px: NSS QVPN crypto key delete message \n"
 		"Crypto index: %d\n",
 		nqckdm,
 		nqckdm->crypto_idx);
@@ -168,7 +168,7 @@ static void nss_qvpn_log_crypto_key_del_
 static void nss_qvpn_log_crypto_key_deactivate_msg(struct nss_qvpn_msg *ncm)
 {
 	struct nss_qvpn_crypto_key_del_msg *nqckdm __maybe_unused = &ncm->msg.key_del;
-	nss_trace("%p: NSS QVPN crypto key deactivate message \n"
+	nss_trace("%px: NSS QVPN crypto key deactivate message \n"
 		"Crypto index: %d\n",
 		nqckdm,
 		nqckdm->crypto_idx);
@@ -206,7 +206,7 @@ static void nss_qvpn_log_verbose(struct
 		break;
 
 	default:
-		nss_trace("%p: Invalid message type\n", ncm);
+		nss_trace("%px: Invalid message type\n", ncm);
 		break;
 	}
 }
@@ -218,11 +218,11 @@ static void nss_qvpn_log_verbose(struct
 void nss_qvpn_log_tx_msg(struct nss_qvpn_msg *ncm)
 {
 	if (ncm->cm.type >= NSS_QVPN_MSG_TYPE_MAX) {
-		nss_warning("%p: Invalid message type\n", ncm);
+		nss_warning("%px: Invalid message type\n", ncm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", ncm, ncm->cm.type, nss_qvpn_log_message_types_str[ncm->cm.type]);
+	nss_info("%px: type[%d]:%s\n", ncm, ncm->cm.type, nss_qvpn_log_message_types_str[ncm->cm.type]);
 	nss_qvpn_log_verbose(ncm);
 }
 
@@ -233,26 +233,26 @@ void nss_qvpn_log_tx_msg(struct nss_qvpn
 void nss_qvpn_log_rx_msg(struct nss_qvpn_msg *ncm)
 {
 	if (ncm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", ncm);
+		nss_warning("%px: Invalid response\n", ncm);
 		return;
 	}
 
 	if (ncm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (ncm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", ncm, ncm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", ncm, ncm->cm.type,
 			nss_qvpn_log_message_types_str[ncm->cm.type],
 			ncm->cm.response, nss_cmn_response_str[ncm->cm.response]);
 		goto verbose;
 	}
 
 	if (ncm->cm.error >= NSS_QVPN_ERROR_TYPE_MAX) {
-		nss_warning("%p: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
+		nss_warning("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
 			ncm, ncm->cm.type, nss_qvpn_log_message_types_str[ncm->cm.type],
 			ncm->cm.response, nss_cmn_response_str[ncm->cm.response],
 			ncm->cm.error);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
 		ncm, ncm->cm.type, nss_qvpn_log_message_types_str[ncm->cm.type],
 		ncm->cm.response, nss_cmn_response_str[ncm->cm.response],
 		ncm->cm.error, nss_qvpn_log_error_response_types_str[ncm->cm.error]);
--- a/nss_rmnet_rx.c
+++ b/nss_rmnet_rx.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -70,7 +70,7 @@ static void nss_rmnet_rx_msg_handler(str
 	 * Sanity check the message type
 	 */
 	if (ncm->type > NSS_RMNET_RX_MAX_MSG_TYPES) {
-		nss_warning("%p: message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
 		return;
 	}
 
@@ -82,7 +82,7 @@ static void nss_rmnet_rx_msg_handler(str
 	}
 
 	if (!nss_rmnet_rx_verify_if_num(ncm->interface)) {
-		nss_warning("%p: response for another interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: response for another interface: %d", nss_ctx, ncm->interface);
 		return;
 	}
 
@@ -91,7 +91,7 @@ static void nss_rmnet_rx_msg_handler(str
 	spin_lock_bh(&nss_rmnet_rx_lock);
 	if (!rmnet_rx_handle[if_num]) {
 		spin_unlock_bh(&nss_rmnet_rx_lock);
-		nss_warning("%p: rmnet_rx handle is NULL\n", nss_ctx);
+		nss_warning("%px: rmnet_rx handle is NULL\n", nss_ctx);
 		return;
 	}
 
@@ -148,7 +148,7 @@ static void nss_rmnet_rx_callback(void *
 	struct nss_rmnet_rx_pvt *nvip = handle->pvt;
 
 	if (ncm->response != NSS_CMN_RESPONSE_ACK) {
-		nss_warning("%p: rmnet_rx Error response %d\n", handle->nss_ctx, ncm->response);
+		nss_warning("%px: rmnet_rx Error response %d\n", handle->nss_ctx, ncm->response);
 		nvip->response = NSS_TX_FAILURE;
 		complete(&nvip->complete);
 		return;
@@ -174,7 +174,7 @@ static nss_tx_status_t nss_rmnet_rx_tx_m
 
 	status = nss_rmnet_rx_tx_msg(nss_ctx, nvim);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: nss_rmnet_rx_msg failed\n", nss_ctx);
+		nss_warning("%px: nss_rmnet_rx_msg failed\n", nss_ctx);
 		up(&nwip->sem);
 		return status;
 	}
@@ -182,7 +182,7 @@ static nss_tx_status_t nss_rmnet_rx_tx_m
 	ret = wait_for_completion_timeout(&nwip->complete,
 						msecs_to_jiffies(NSS_RMNET_RX_TX_TIMEOUT));
 	if (!ret) {
-		nss_warning("%p: rmnet_rx tx failed due to timeout\n", nss_ctx);
+		nss_warning("%px: rmnet_rx tx failed due to timeout\n", nss_ctx);
 		nwip->response = NSS_TX_FAILURE;
 	}
 
@@ -219,7 +219,7 @@ static int nss_rmnet_rx_handle_destroy_s
 	int32_t index_h2n;
 
 	if (!nss_rmnet_rx_verify_if_num(if_num_n2h) || !nss_rmnet_rx_verify_if_num(if_num_h2n)) {
-		nss_warning("%p: bad interface numbers %d %d\n", handle->nss_ctx, if_num_n2h, if_num_h2n);
+		nss_warning("%px: bad interface numbers %d %d\n", handle->nss_ctx, if_num_n2h, if_num_h2n);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
@@ -228,13 +228,13 @@ static int nss_rmnet_rx_handle_destroy_s
 
 	status = nss_dynamic_interface_dealloc_node(if_num_n2h, NSS_DYNAMIC_INTERFACE_TYPE_RMNET_RX_N2H);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: Dynamic interface destroy failed status %d\n", handle->nss_ctx, status);
+		nss_warning("%px: Dynamic interface destroy failed status %d\n", handle->nss_ctx, status);
 		return status;
 	}
 
 	status = nss_dynamic_interface_dealloc_node(if_num_h2n, NSS_DYNAMIC_INTERFACE_TYPE_RMNET_RX_H2N);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: Dynamic interface destroy failed status %d\n", handle->nss_ctx, status);
+		nss_warning("%px: Dynamic interface destroy failed status %d\n", handle->nss_ctx, status);
 		return status;
 	}
 
@@ -260,7 +260,7 @@ static struct nss_rmnet_rx_handle *nss_r
 	struct nss_rmnet_rx_handle *handle;
 
 	if (!nss_rmnet_rx_verify_if_num(if_num_n2h) || !nss_rmnet_rx_verify_if_num(if_num_h2n)) {
-		nss_warning("%p: bad interface numbers %d %d\n", nss_ctx, if_num_n2h, if_num_h2n);
+		nss_warning("%px: bad interface numbers %d %d\n", nss_ctx, if_num_n2h, if_num_h2n);
 		return NULL;
 	}
 
@@ -270,7 +270,7 @@ static struct nss_rmnet_rx_handle *nss_r
 	handle = (struct nss_rmnet_rx_handle *)kzalloc(sizeof(struct nss_rmnet_rx_handle),
 									GFP_KERNEL);
 	if (!handle) {
-		nss_warning("%p: handle memory alloc failed\n", nss_ctx);
+		nss_warning("%px: handle memory alloc failed\n", nss_ctx);
 		*cmd_rsp = NSS_RMNET_RX_ALLOC_FAILURE;
 		goto error1;
 	}
@@ -281,7 +281,7 @@ static struct nss_rmnet_rx_handle *nss_r
 	handle->pvt = (struct nss_rmnet_rx_pvt *)kzalloc(sizeof(struct nss_rmnet_rx_pvt),
 								GFP_KERNEL);
 	if (!handle->pvt) {
-		nss_warning("%p: failure allocating memory for nss_rmnet_rx_pvt\n", nss_ctx);
+		nss_warning("%px: failure allocating memory for nss_rmnet_rx_pvt\n", nss_ctx);
 		*cmd_rsp = NSS_RMNET_RX_ALLOC_FAILURE;
 		goto error2;
 	}
@@ -289,7 +289,7 @@ static struct nss_rmnet_rx_handle *nss_r
 	handle->stats_n2h = (uint64_t *)kzalloc(sizeof(uint64_t) * NSS_RMNET_RX_STATS_MAX,
 								GFP_KERNEL);
 	if (!handle->stats_n2h) {
-		nss_warning("%p: failure allocating memory for N2H stats\n", nss_ctx);
+		nss_warning("%px: failure allocating memory for N2H stats\n", nss_ctx);
 		*cmd_rsp = NSS_RMNET_RX_ALLOC_FAILURE;
 		goto error3;
 	}
@@ -297,7 +297,7 @@ static struct nss_rmnet_rx_handle *nss_r
 	handle->stats_h2n = (uint64_t *)kzalloc(sizeof(uint64_t) * NSS_RMNET_RX_STATS_MAX,
 								GFP_KERNEL);
 	if (!handle->stats_h2n) {
-		nss_warning("%p: failure allocating memory for H2N stats\n", nss_ctx);
+		nss_warning("%px: failure allocating memory for H2N stats\n", nss_ctx);
 		*cmd_rsp = NSS_RMNET_RX_ALLOC_FAILURE;
 		goto error4;
 	}
@@ -337,14 +337,14 @@ static uint32_t nss_rmnet_rx_register_ha
 
 	ret = nss_core_register_handler(nss_ctx, if_num_n2h, nss_rmnet_rx_msg_handler, NULL);
 	if (ret != NSS_CORE_STATUS_SUCCESS) {
-		nss_warning("%p: Failed to register message handler for redir_n2h interface %d\n", nss_ctx, if_num_n2h);
+		nss_warning("%px: Failed to register message handler for redir_n2h interface %d\n", nss_ctx, if_num_n2h);
 		return NSS_RMNET_RX_REG_FAILURE;
 	}
 
 	ret = nss_core_register_handler(nss_ctx, if_num_h2n, nss_rmnet_rx_msg_handler, NULL);
 	if (ret != NSS_CORE_STATUS_SUCCESS) {
 		nss_core_unregister_handler(nss_ctx, if_num_n2h);
-		nss_warning("%p: Failed to register message handler for redir_h2n interface %d\n", nss_ctx, if_num_h2n);
+		nss_warning("%px: Failed to register message handler for redir_h2n interface %d\n", nss_ctx, if_num_h2n);
 		return NSS_RMNET_RX_REG_FAILURE;
 	}
 
@@ -382,14 +382,14 @@ nss_tx_status_t nss_rmnet_rx_destroy_syn
 	nss_ctx = handle->nss_ctx;
 
 	if (unlikely(nss_ctx->state != NSS_CORE_STATE_INITIALIZED)) {
-		nss_warning("%p: Interface could not be destroyed as core not ready\n", nss_ctx);
+		nss_warning("%px: Interface could not be destroyed as core not ready\n", nss_ctx);
 		return NSS_TX_FAILURE_NOT_READY;
 	}
 
 	spin_lock_bh(&nss_top_main.lock);
 	if (!nss_ctx->subsys_dp_register[if_num_n2h].ndev || !nss_ctx->subsys_dp_register[if_num_h2n].ndev) {
 		spin_unlock_bh(&nss_top_main.lock);
-		nss_warning("%p: Unregister virt interface %d %d: no context\n", nss_ctx, if_num_n2h, if_num_h2n);
+		nss_warning("%px: Unregister virt interface %d %d: no context\n", nss_ctx, if_num_n2h, if_num_h2n);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
@@ -402,19 +402,19 @@ nss_tx_status_t nss_rmnet_rx_destroy_syn
 
 	status = nss_rmnet_rx_handle_destroy_sync(handle);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: handle destroy failed for if_num_n2h %d and if_num_h2n %d\n", nss_ctx, if_num_n2h, if_num_h2n);
+		nss_warning("%px: handle destroy failed for if_num_n2h %d and if_num_h2n %d\n", nss_ctx, if_num_n2h, if_num_h2n);
 		return NSS_TX_FAILURE;
 	}
 
 	ret = nss_core_unregister_handler(nss_ctx, if_num_n2h);
 	if (ret != NSS_CORE_STATUS_SUCCESS) {
-		nss_warning("%p: Not able to unregister handler for redir_n2h interface %d with NSS core\n", nss_ctx, if_num_n2h);
+		nss_warning("%px: Not able to unregister handler for redir_n2h interface %d with NSS core\n", nss_ctx, if_num_n2h);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
 	ret = nss_core_unregister_handler(nss_ctx, if_num_h2n);
 	if (ret != NSS_CORE_STATUS_SUCCESS) {
-		nss_warning("%p: Not able to unregister handler for redir_h2n interface %d with NSS core\n", nss_ctx, if_num_h2n);
+		nss_warning("%px: Not able to unregister handler for redir_h2n interface %d with NSS core\n", nss_ctx, if_num_h2n);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
@@ -436,26 +436,26 @@ struct nss_rmnet_rx_handle *nss_rmnet_rx
 	int32_t if_num_n2h, if_num_h2n;
 
 	if (unlikely(nss_ctx->state != NSS_CORE_STATE_INITIALIZED)) {
-		nss_warning("%p: Interface could not be created as core not ready\n", nss_ctx);
+		nss_warning("%px: Interface could not be created as core not ready\n", nss_ctx);
 		return NULL;
 	}
 
 	if_num_n2h = nss_dynamic_interface_alloc_node(NSS_DYNAMIC_INTERFACE_TYPE_RMNET_RX_N2H);
 	if (if_num_n2h < 0) {
-		nss_warning("%p: failure allocating redir_n2h\n", nss_ctx);
+		nss_warning("%px: failure allocating redir_n2h\n", nss_ctx);
 		return NULL;
 	}
 
 	if_num_h2n = nss_dynamic_interface_alloc_node(NSS_DYNAMIC_INTERFACE_TYPE_RMNET_RX_H2N);
 	if (if_num_h2n < 0) {
-		nss_warning("%p: failure allocating redir_h2n\n", nss_ctx);
+		nss_warning("%px: failure allocating redir_h2n\n", nss_ctx);
 		nss_dynamic_interface_dealloc_node(if_num_n2h, NSS_DYNAMIC_INTERFACE_TYPE_RMNET_RX_N2H);
 		return NULL;
 	}
 
 	handle = nss_rmnet_rx_handle_create_sync(nss_ctx, if_num_n2h, if_num_h2n, &ret);
 	if (!handle) {
-		nss_warning("%p: rmnet_rx handle creation failed ret %d\n", nss_ctx, ret);
+		nss_warning("%px: rmnet_rx handle creation failed ret %d\n", nss_ctx, ret);
 		nss_dynamic_interface_dealloc_node(if_num_n2h, NSS_DYNAMIC_INTERFACE_TYPE_RMNET_RX_N2H);
 		nss_dynamic_interface_dealloc_node(if_num_h2n, NSS_DYNAMIC_INTERFACE_TYPE_RMNET_RX_H2N);
 		return NULL;
@@ -466,7 +466,7 @@ struct nss_rmnet_rx_handle *nss_rmnet_rx
 	 */
 	ret = nss_rmnet_rx_register_handler_sync(nss_ctx, handle);
 	if (ret != NSS_RMNET_RX_SUCCESS) {
-		nss_warning("%p: Registration handler failed reason: %d\n", nss_ctx, ret);
+		nss_warning("%px: Registration handler failed reason: %d\n", nss_ctx, ret);
 		goto error1;
 	}
 
@@ -481,7 +481,7 @@ struct nss_rmnet_rx_handle *nss_rmnet_rx
 
 	ret = nss_rmnet_rx_tx_msg_sync(handle, &nvim);
 	if (ret != NSS_TX_SUCCESS) {
-		nss_warning("%p: nss_rmnet_rx_tx_msg_sync failed %u\n", nss_ctx, ret);
+		nss_warning("%px: nss_rmnet_rx_tx_msg_sync failed %u\n", nss_ctx, ret);
 		goto error2;
 	}
 
@@ -492,7 +492,7 @@ struct nss_rmnet_rx_handle *nss_rmnet_rx
 
 	ret = nss_rmnet_rx_tx_msg_sync(handle, &nvim);
 	if (ret != NSS_TX_SUCCESS) {
-		nss_warning("%p: nss_rmnet_rx_tx_msg_sync failed %u\n", nss_ctx, ret);
+		nss_warning("%px: nss_rmnet_rx_tx_msg_sync failed %u\n", nss_ctx, ret);
 		goto error2;
 	}
 
@@ -544,17 +544,17 @@ nss_tx_status_t nss_rmnet_rx_tx_buf(stru
 	}
 
 	if (!nss_rmnet_rx_verify_if_num(if_num)) {
-		nss_warning("%p: bad interface number %d\n", nss_ctx, if_num);
+		nss_warning("%px: bad interface number %d\n", nss_ctx, if_num);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
-	nss_trace("%p: RmnetRx packet, if_num:%d, skb:%p", nss_ctx, if_num, skb);
+	nss_trace("%px: RmnetRx packet, if_num:%d, skb:%px", nss_ctx, if_num, skb);
 
 	/*
 	 * Sanity check the SKB to ensure that it's suitable for us
 	 */
 	if (unlikely(skb->len <= ETH_HLEN)) {
-		nss_warning("%p: Rmnet Rx packet: %p too short", nss_ctx, skb);
+		nss_warning("%px: Rmnet Rx packet: %px too short", nss_ctx, skb);
 		return NSS_TX_FAILURE_TOO_SHORT;
 	}
 
@@ -580,12 +580,12 @@ nss_tx_status_t nss_rmnet_rx_tx_msg(stru
 	 * Sanity check the message
 	 */
 	if (!nss_rmnet_rx_verify_if_num(ncm->interface)) {
-		nss_warning("%p: tx request for another interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: tx request for another interface: %d", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
 	if (ncm->type > NSS_RMNET_RX_MAX_MSG_TYPES) {
-		nss_warning("%p: message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
@@ -714,7 +714,7 @@ int32_t nss_rmnet_rx_get_ifnum_with_core
 
 	NSS_VERIFY_CTX_MAGIC(nss_ctx);
 	if (nss_rmnet_rx_verify_if_num(if_num) == false) {
-		nss_info("%p: if_num: %u is not RMNET interface\n", nss_ctx, if_num);
+		nss_info("%px: if_num: %u is not RMNET interface\n", nss_ctx, if_num);
 		return -1;
 	}
 	return NSS_INTERFACE_NUM_APPEND_COREID(nss_ctx, if_num);
--- a/nss_rmnet_rx_stats.c
+++ b/nss_rmnet_rx_stats.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -113,13 +113,13 @@ static ssize_t nss_rmnet_rx_stats_read(s
 	uint64_t *stats_shadow;
 	char *lbuf = kzalloc(size_al, GFP_KERNEL);
 	if (unlikely(!lbuf)) {
-		nss_warning("%p: Could not allocate memory for local statistics buffer", data);
+		nss_warning("%px: Could not allocate memory for local statistics buffer", data);
 		return 0;
 	}
 
 	stats_shadow = kzalloc(NSS_RMNET_RX_STATS_MAX * sizeof(uint64_t), GFP_KERNEL);
 	if (unlikely(!stats_shadow)) {
-		nss_warning("%p: Could not allocate memory for local shadow buffer", data);
+		nss_warning("%px: Could not allocate memory for local shadow buffer", data);
 		kfree(lbuf);
 		return 0;
 	}
@@ -143,7 +143,6 @@ static ssize_t nss_rmnet_rx_stats_read(s
 			continue;
 		}
 
-
 		size_wr += nss_stats_print("rmnet_rx", "interface", if_num,
 				nss_rmnet_rx_stats_str, stats_shadow, NSS_RMNET_RX_STATS_MAX,
 				lbuf, size_wr, size_al);
--- a/nss_rps.c
+++ b/nss_rps.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2013-2017, 2019 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2013-2017, 2019-2020 The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -188,12 +188,12 @@ static void nss_rps_cfg_callback(void *a
 		 */
 		nss_rps_cfg_pvt.response = NSS_FAILURE;
 		complete(&nss_rps_cfg_pvt.complete);
-		nss_warning("%p: RPS configuration failed : %d\n", nss_ctx,
+		nss_warning("%px: RPS configuration failed : %d\n", nss_ctx,
 								   nnm->cm.error);
 		return;
 	}
 
-	nss_info("%p: RPS configuration succeeded: %d\n", nss_ctx,
+	nss_info("%px: RPS configuration succeeded: %d\n", nss_ctx,
 							   nnm->cm.error);
 	nss_ctx->rps_en = nnm->msg.rps_cfg.enable;
 	nss_rps_cfg_pvt.response = NSS_SUCCESS;
@@ -215,12 +215,12 @@ static void nss_rps_pri_map_cfg_callback
 		 */
 		nss_rps_cfg_pvt.response = NSS_FAILURE;
 		complete(&nss_rps_cfg_pvt.complete);
-		nss_warning("%p: RPS pri_map configuration failed : %d\n",
+		nss_warning("%px: RPS pri_map configuration failed : %d\n",
 				app_data, nnm->cm.error);
 		return;
 	}
 
-	nss_info("%p: RPS pri_map configuration succeeded: %d\n",
+	nss_info("%px: RPS pri_map configuration succeeded: %d\n",
 			app_data, nnm->cm.error);
 
 	nss_rps_cfg_pvt.response = NSS_SUCCESS;
@@ -248,7 +248,7 @@ static nss_tx_status_t nss_rps_cfg(struc
 	nss_tx_status = nss_n2h_tx_msg(nss_ctx, &nnm);
 
 	if (nss_tx_status != NSS_TX_SUCCESS) {
-		nss_warning("%p: nss_tx error setting rps\n", nss_ctx);
+		nss_warning("%px: nss_tx error setting rps\n", nss_ctx);
 
 		up(&nss_rps_cfg_pvt.sem);
 		return NSS_FAILURE;
@@ -259,7 +259,7 @@ static nss_tx_status_t nss_rps_cfg(struc
 	 */
 	ret = wait_for_completion_timeout(&nss_rps_cfg_pvt.complete, msecs_to_jiffies(NSS_CONN_CFG_TIMEOUT));
 	if (ret == 0) {
-		nss_warning("%p: Waiting for ack timed out\n", nss_ctx);
+		nss_warning("%px: Waiting for ack timed out\n", nss_ctx);
 		up(&nss_rps_cfg_pvt.sem);
 		return NSS_FAILURE;
 	}
@@ -297,7 +297,7 @@ static nss_tx_status_t nss_rps_ipv4_hash
 	nss_tx_status = nss_ipv4_tx_sync(nss_ctx, &nim);
 
 	if (nss_tx_status != NSS_TX_SUCCESS) {
-		nss_warning("%p: nss_tx error setting rps\n", nss_ctx);
+		nss_warning("%px: nss_tx error setting rps\n", nss_ctx);
 
 		up(&nss_rps_cfg_pvt.sem);
 		return NSS_FAILURE;
@@ -326,7 +326,7 @@ static nss_tx_status_t nss_rps_ipv6_hash
 	nss_tx_status = nss_ipv6_tx_sync(nss_ctx, &nim);
 
 	if (nss_tx_status != NSS_TX_SUCCESS) {
-		nss_warning("%p: nss_tx error setting rps\n", nss_ctx);
+		nss_warning("%px: nss_tx error setting rps\n", nss_ctx);
 
 		up(&nss_rps_cfg_pvt.sem);
 		return NSS_FAILURE;
@@ -365,7 +365,7 @@ static nss_tx_status_t nss_rps_pri_map_c
 	nss_tx_status = nss_n2h_tx_msg(nss_ctx, &nnm);
 
 	if (nss_tx_status != NSS_TX_SUCCESS) {
-		nss_warning("%p: nss_tx error setting rps\n", nss_ctx);
+		nss_warning("%px: nss_tx error setting rps\n", nss_ctx);
 
 		up(&nss_rps_cfg_pvt.sem);
 		return NSS_FAILURE;
@@ -376,7 +376,7 @@ static nss_tx_status_t nss_rps_pri_map_c
 	 */
 	ret = wait_for_completion_timeout(&nss_rps_cfg_pvt.complete, msecs_to_jiffies(NSS_CONN_CFG_TIMEOUT));
 	if (ret == 0) {
-		nss_warning("%p: Waiting for ack timed out\n", nss_ctx);
+		nss_warning("%px: Waiting for ack timed out\n", nss_ctx);
 		up(&nss_rps_cfg_pvt.sem);
 		return NSS_FAILURE;
 	}
@@ -438,7 +438,7 @@ static int nss_rps_cfg_handler(struct ct
 		 * TODO: Flush queues in NSS FW.
 		 */
 		if (ret_rps != NSS_SUCCESS) {
-			nss_warning("%p: rps enabling failed\n", nss_ctx);
+			nss_warning("%px: rps enabling failed\n", nss_ctx);
 			nss_rps_config = current_state;
 			return ret_rps;
 		}
@@ -474,7 +474,7 @@ static int nss_rps_hash_bitmap_cfg_handl
 		ret_ipv4 = nss_rps_ipv4_hash_bitmap_cfg(nss_ctx, nss_rps_hash_bitmap);
 
 		if (ret_ipv4 != NSS_SUCCESS) {
-			nss_warning("%p: ipv4 hash_bitmap config message failed\n", nss_ctx);
+			nss_warning("%px: ipv4 hash_bitmap config message failed\n", nss_ctx);
 			nss_rps_hash_bitmap = current_state;
 			return ret_ipv4;
 		}
@@ -482,10 +482,10 @@ static int nss_rps_hash_bitmap_cfg_handl
 		ret_ipv6 = nss_rps_ipv6_hash_bitmap_cfg(nss_ctx, nss_rps_hash_bitmap);
 
 		if (ret_ipv6 != NSS_SUCCESS) {
-			nss_warning("%p: ipv6 hash_bitmap config message failed\n", nss_ctx);
+			nss_warning("%px: ipv6 hash_bitmap config message failed\n", nss_ctx);
 			nss_rps_hash_bitmap = current_state;
 			if (nss_rps_ipv4_hash_bitmap_cfg(nss_ctx, nss_rps_hash_bitmap != NSS_SUCCESS)) {
-				nss_warning("%p: ipv4 and ipv6 have different hash_bitmaps.\n", nss_ctx);
+				nss_warning("%px: ipv4 and ipv6 have different hash_bitmaps.\n", nss_ctx);
 			}
 			return ret_ipv6;
 		}
@@ -526,7 +526,7 @@ static int nss_rps_pri_map_cfg_handler(s
 	ret_pri_map = nss_rps_pri_map_cfg(nss_ctx, nss_rps_pri_map);
 	if (ret_pri_map != NSS_SUCCESS) {
 		nss_rps_pri_map[current_state.pri] = current_state.core;
-		nss_warning("%p: pri_map config message failed\n", nss_ctx);
+		nss_warning("%px: pri_map config message failed\n", nss_ctx);
 	}
 
 	return ret_pri_map;
--- a/nss_shaper.c
+++ b/nss_shaper.c
@@ -23,7 +23,7 @@
 void *nss_shaper_register_shaping(void)
 {
 	if (nss_top_main.shaping_handler_id == (uint8_t)-1) {
-		nss_warning("%p: SHAPING IS NOT ENABLED", __func__);
+		nss_warning("%px: SHAPING IS NOT ENABLED", __func__);
 		return NULL;
 	}
 	return (void *)&nss_top_main.nss[nss_top_main.shaping_handler_id];
@@ -46,7 +46,7 @@ void *nss_shaper_register_shaper_bounce_
 	struct nss_top_instance *nss_top = &nss_top_main;
 	struct nss_shaper_bounce_registrant *reg;
 
-	nss_info("Shaper bounce interface register: %u, cb: %p, app_data: %p, owner: %p",
+	nss_info("Shaper bounce interface register: %u, cb: %px, app_data: %px, owner: %px",
 			if_num, cb, app_data, owner);
 
 	/*
@@ -61,7 +61,7 @@ void *nss_shaper_register_shaper_bounce_
 	 * Shaping enabled?
 	 */
 	if (nss_top_main.shaping_handler_id == (uint8_t)-1) {
-		nss_warning("%p: SHAPING IS NOT ENABLED", __func__);
+		nss_warning("%px: SHAPING IS NOT ENABLED", __func__);
 		return NULL;
 	}
 
@@ -69,7 +69,7 @@ void *nss_shaper_register_shaper_bounce_
 	 * Can we hold the module?
 	 */
 	if (!try_module_get(owner)) {
-		nss_warning("%p: Unable to hold owner", __func__);
+		nss_warning("%px: Unable to hold owner", __func__);
 		return NULL;
 	}
 
@@ -151,7 +151,7 @@ void *nss_shaper_register_shaper_bounce_
 	struct nss_ctx_instance *nss_ctx;
 	struct nss_shaper_bounce_registrant *reg;
 
-	nss_info("Shaper bounce bridge register: %u, cb: %p, app_data: %p, owner: %p",
+	nss_info("Shaper bounce bridge register: %u, cb: %px, app_data: %px, owner: %px",
 			if_num, cb, app_data, owner);
 
 	/*
@@ -166,7 +166,7 @@ void *nss_shaper_register_shaper_bounce_
 	 * Shaping enabled?
 	 */
 	if (nss_top_main.shaping_handler_id == (uint8_t)-1) {
-		nss_warning("%p: SHAPING IS NOT ENABLED", __func__);
+		nss_warning("%px: SHAPING IS NOT ENABLED", __func__);
 		return NULL;
 	}
 
@@ -174,7 +174,7 @@ void *nss_shaper_register_shaper_bounce_
 	 * Can we hold the module?
 	 */
 	if (!try_module_get(owner)) {
-		nss_warning("%p: Unable to hold owner", __func__);
+		nss_warning("%px: Unable to hold owner", __func__);
 		return NULL;
 	}
 
@@ -277,7 +277,6 @@ nss_tx_status_t nss_shaper_bounce_interf
 		BUG_ON(false);
 	}
 
-
 	/*
 	 * Must have existing registrant
 	 */
@@ -334,7 +333,7 @@ nss_tx_status_t nss_shaper_bounce_bridge
 	}
 	spin_unlock_bh(&nss_top->lock);
 
-	nss_info("%s: Bridge bounce skb: %p, if_num: %u, ctx: %p", __func__, skb, if_num, nss_ctx);
+	nss_info("%s: Bridge bounce skb: %px, if_num: %u, ctx: %px", __func__, skb, if_num, nss_ctx);
 	status = nss_core_send_buffer(nss_ctx, if_num, skb, NSS_IF_H2N_DATA_QUEUE,
 					H2N_BUFFER_SHAPER_BOUNCE_BRIDGE, 0);
 	if (status != NSS_CORE_STATUS_SUCCESS) {
--- a/nss_sjack.c
+++ b/nss_sjack.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -40,12 +40,12 @@ static void nss_sjack_handler(struct nss
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >=  NSS_SJACK_MAX_MSG_TYPE) {
-		nss_warning("%p: received invalid message %d for sjack interface", nss_ctx, ncm->type);
+		nss_warning("%px: received invalid message %d for sjack interface", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_sjack_msg)) {
-		nss_warning("%p: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
@@ -54,7 +54,7 @@ static void nss_sjack_handler(struct nss
 	 * to the same callback/app_data.
 	 */
 	if (ncm->response == NSS_CMN_RESPONSE_NOTIFY) {
-		ncm->cb = (nss_ptr_t)nss_ctx->nss_top->if_rx_msg_callback[ncm->interface];
+		ncm->cb = (nss_ptr_t)nss_core_get_msg_handler(nss_ctx, ncm->interface);
 	}
 
 	/*
@@ -104,12 +104,12 @@ nss_tx_status_t nss_sjack_tx_msg(struct
 	 * Sanity check the message
 	 */
 	if (ncm->interface != NSS_SJACK_INTERFACE) {
-		nss_warning("%p: tx request for another interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: tx request for another interface: %d", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
 	if (ncm->type > NSS_SJACK_MAX_MSG_TYPE) {
-		nss_warning("%p: message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
@@ -123,13 +123,18 @@ struct nss_ctx_instance *nss_sjack_regis
 						nss_sjack_msg_callback_t event_callback)
 {
 	struct nss_ctx_instance *nss_ctx = (struct nss_ctx_instance *)&nss_top_main.nss[nss_top_main.sjack_handler_id];
+	uint32_t status;
 
 	nss_assert(nss_ctx);
 	nss_assert(if_num == NSS_SJACK_INTERFACE);
 
 	nss_core_register_subsys_dp(nss_ctx, if_num, NULL, NULL, NULL, netdev, 0);
 
-	nss_top_main.if_rx_msg_callback[if_num] = event_callback;
+	status = nss_core_register_msg_handler(nss_ctx, NSS_SJACK_INTERFACE, event_callback);
+	if (status != NSS_CORE_STATUS_SUCCESS) {
+		nss_warning("%px: Not able to register handler for interface %d with NSS core\n", nss_ctx, if_num);
+		return NULL;
+	}
 
 	return nss_ctx;
 }
@@ -140,12 +145,18 @@ struct nss_ctx_instance *nss_sjack_regis
 void nss_sjack_unregister_if(uint32_t if_num)
 {
 	struct nss_ctx_instance *nss_ctx = (struct nss_ctx_instance *)&nss_top_main.nss[nss_top_main.sjack_handler_id];
+	uint32_t status;
 
 	nss_assert(nss_ctx);
 	nss_assert(if_num == NSS_SJACK_INTERFACE);
 
 	nss_core_unregister_subsys_dp(nss_ctx, if_num);
-	nss_top_main.if_rx_msg_callback[if_num] = NULL;
+
+	status = nss_core_unregister_msg_handler(nss_ctx, if_num);
+	if (status != NSS_CORE_STATUS_SUCCESS) {
+		nss_warning("%px: Not able to unregister handler for interface %d with NSS core\n", nss_ctx, if_num);
+		return;
+	}
 
 	return;
 }
--- a/nss_sjack_log.c
+++ b/nss_sjack_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -38,7 +38,7 @@ static int8_t *nss_sjack_log_message_typ
 static void nss_sjack_log_configure_msg(struct nss_sjack_msg *nsm)
 {
 	struct nss_sjack_configure_msg *nscm __maybe_unused = &nsm->msg.configure;
-	nss_trace("%p: NSS SJACK Configure message \n"
+	nss_trace("%px: NSS SJACK Configure message \n"
 		"SJACK Ingress Interface Number: %d\n"
 		"SJACK Engress Interface Number: %d\n"
 		"SJACK Tunnel ID: %d\n"
@@ -59,7 +59,7 @@ static void nss_sjack_log_configure_msg(
 static void nss_sjack_log_unconfigure_msg(struct nss_sjack_msg *nsm)
 {
 	struct nss_sjack_unconfigure_msg *nsum __maybe_unused = &nsm->msg.unconfigure;
-	nss_trace("%p: NSS SJACK UnConfigure message \n"
+	nss_trace("%px: NSS SJACK UnConfigure message \n"
 		"SJACK Ingress Interface Number: %d\n",
 		nsum, nsum->ingress_if_num);
 }
@@ -86,7 +86,7 @@ static void nss_sjack_log_verbose(struct
 		break;
 
 	default:
-		nss_trace("%p: Invalid message type\n", nsm);
+		nss_trace("%px: Invalid message type\n", nsm);
 		break;
 	}
 }
@@ -98,11 +98,11 @@ static void nss_sjack_log_verbose(struct
 void nss_sjack_log_tx_msg(struct nss_sjack_msg *nsm)
 {
 	if (nsm->cm.type >= NSS_SJACK_MAX_MSG_TYPE) {
-		nss_warning("%p: Invalid message type\n", nsm);
+		nss_warning("%px: Invalid message type\n", nsm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", nsm, nsm->cm.type, nss_sjack_log_message_types_str[nsm->cm.type]);
+	nss_info("%px: type[%d]:%s\n", nsm, nsm->cm.type, nss_sjack_log_message_types_str[nsm->cm.type]);
 	nss_sjack_log_verbose(nsm);
 }
 
@@ -113,18 +113,18 @@ void nss_sjack_log_tx_msg(struct nss_sja
 void nss_sjack_log_rx_msg(struct nss_sjack_msg *nsm)
 {
 	if (nsm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", nsm);
+		nss_warning("%px: Invalid response\n", nsm);
 		return;
 	}
 
 	if (nsm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (nsm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", nsm, nsm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", nsm, nsm->cm.type,
 			nss_sjack_log_message_types_str[nsm->cm.type],
 			nsm->cm.response, nss_cmn_response_str[nsm->cm.response]);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s\n",
 		nsm, nsm->cm.type, nss_sjack_log_message_types_str[nsm->cm.type],
 		nsm->cm.response, nss_cmn_response_str[nsm->cm.response]);
 
--- a/nss_tls.c
+++ b/nss_tls.c
@@ -152,18 +152,18 @@ static void nss_tls_handler(struct nss_c
 
 	NSS_VERIFY_CTX_MAGIC(nss_ctx);
 
-	nss_trace("%p: handle event for interface num :%u", nss_ctx, ncm->interface);
+	nss_trace("%px: handle event for interface num :%u", nss_ctx, ncm->interface);
 
 	/*
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >= NSS_TLS_MSG_MAX) {
-		nss_warning("%p:Bad message type(%d) for TLS interface %d", nss_ctx, ncm->type, ncm->interface);
+		nss_warning("%px:Bad message type(%d) for TLS interface %d", nss_ctx, ncm->type, ncm->interface);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_tls_msg)) {
-		nss_warning("%p:Bad message length(%d)", nss_ctx, ncm->len);
+		nss_warning("%px:Bad message length(%d)", nss_ctx, ncm->len);
 		return;
 	}
 
@@ -174,7 +174,7 @@ static void nss_tls_handler(struct nss_c
 	 * Update the callback and app_data for NOTIFY messages
 	 */
 	if (ncm->response == NSS_CMN_RESPONSE_NOTIFY) {
-		ncm->cb = (nss_ptr_t)nss_top_main.if_rx_msg_callback[ncm->interface];
+		ncm->cb = (nss_ptr_t)nss_core_get_msg_handler(nss_ctx, ncm->interface);
 		ncm->app_data = (nss_ptr_t)nss_ctx->nss_rx_interface_handlers[nss_ctx->id][ncm->interface].app_data;
 	}
 
@@ -198,11 +198,11 @@ static void nss_tls_handler(struct nss_c
 	 * Call TLS session callback
 	 */
 	if (!cb) {
-		nss_warning("%p: No callback for tls session interface %d", nss_ctx, ncm->interface);
+		nss_warning("%px: No callback for tls session interface %d", nss_ctx, ncm->interface);
 		return;
 	}
 
-	nss_trace("%p: calling tlsmgr event handler(%u)", nss_ctx, ncm->interface);
+	nss_trace("%px: calling tlsmgr event handler(%u)", nss_ctx, ncm->interface);
 	cb(app_data, ncm);
 }
 
@@ -242,7 +242,7 @@ nss_tx_status_t nss_tls_tx_buf(struct sk
 	NSS_VERIFY_CTX_MAGIC(nss_ctx);
 
 	if (unlikely(nss_ctx->state != NSS_CORE_STATE_INITIALIZED)) {
-		nss_warning("%p: tx_data packet dropped as core not ready", nss_ctx);
+		nss_warning("%px: tx_data packet dropped as core not ready", nss_ctx);
 		return NSS_TX_FAILURE_NOT_READY;
 	}
 
@@ -252,11 +252,11 @@ nss_tx_status_t nss_tls_tx_buf(struct sk
 		break;
 
 	case NSS_CORE_STATUS_FAILURE_QUEUE: /* queue full condition */
-		nss_warning("%p: H2N queue full for tx_buf", nss_ctx);
+		nss_warning("%px: H2N queue full for tx_buf", nss_ctx);
 		return NSS_TX_FAILURE_QUEUE;
 
 	default:
-		nss_warning("%p: general failure for tx_buf", nss_ctx);
+		nss_warning("%px: general failure for tx_buf", nss_ctx);
 		return NSS_TX_FAILURE;
 	}
 
@@ -278,12 +278,12 @@ nss_tx_status_t nss_tls_tx_msg(struct ns
 	struct nss_cmn_msg *ncm = &msg->cm;
 
 	if (ncm->type >= NSS_TLS_MSG_MAX) {
-		nss_warning("%p: tls message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: tls message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
 	if (!nss_tls_verify_ifnum(nss_ctx, ncm->interface)) {
-		nss_warning("%p: tls message interface is bad: %u", nss_ctx, ncm->interface);
+		nss_warning("%px: tls message interface is bad: %u", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
@@ -312,7 +312,7 @@ nss_tx_status_t nss_tls_tx_msg_sync(stru
 	 * Length of the message should be the based on type
 	 */
 	if (len > sizeof(struct nss_tls_msg)) {
-		nss_warning("%p: Invalid message length(%u), type (%d), I/F(%u)\n", nss_ctx, len, type, if_num);
+		nss_warning("%px: Invalid message length(%u), type (%d), I/F(%u)\n", nss_ctx, len, type, if_num);
 		return NSS_TX_FAILURE;
 	}
 
@@ -329,13 +329,13 @@ nss_tx_status_t nss_tls_tx_msg_sync(stru
 
 	status = nss_tls_tx_msg(nss_ctx, local_ntcm);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: Failed to send message\n", nss_ctx);
+		nss_warning("%px: Failed to send message\n", nss_ctx);
 		goto done;
 	}
 
 	ret = wait_for_completion_timeout(&tls_pvt.complete, msecs_to_jiffies(NSS_TLS_TX_TIMEOUT));
 	if (!ret) {
-		nss_warning("%p: Failed to receive response, timeout(%d)\n", nss_ctx, ret);
+		nss_warning("%px: Failed to receive response, timeout(%d)\n", nss_ctx, ret);
 		status = NSS_TX_FAILURE_NOT_READY;
 		goto done;
 	}
@@ -363,7 +363,6 @@ done:
 }
 EXPORT_SYMBOL(nss_tls_tx_msg_sync);
 
-
 /*
  * nss_tls_notify_register()
  *	Register a handler for notification from NSS firmware.
@@ -377,11 +376,16 @@ struct nss_ctx_instance *nss_tls_notify_
 
 	ret = nss_core_register_handler(nss_ctx, if_num, nss_tls_handler, app_data);
 	if (ret != NSS_CORE_STATUS_SUCCESS) {
-		nss_warning("%p: unable to register event handler for interface(%u)", nss_ctx, if_num);
+		nss_warning("%px: unable to register event handler for interface(%u)", nss_ctx, if_num);
 		return NULL;
 	}
 
-	nss_top_main.if_rx_msg_callback[if_num] = ev_cb;
+	ret = nss_core_register_msg_handler(nss_ctx, if_num, ev_cb);
+	if (ret != NSS_CORE_STATUS_SUCCESS) {
+		nss_core_unregister_handler(nss_ctx, if_num);
+		nss_warning("%px: unable to register event handler for interface(%u)", nss_ctx, if_num);
+		return NULL;
+	}
 
 	return nss_ctx;
 }
@@ -398,13 +402,17 @@ void nss_tls_notify_unregister(uint32_t
 
 	BUG_ON(!nss_ctx);
 
-	ret = nss_core_unregister_handler(nss_ctx, if_num);
+	ret = nss_core_unregister_msg_handler(nss_ctx, if_num);
 	if (ret != NSS_CORE_STATUS_SUCCESS) {
-		nss_warning("%p: unable to un register event handler for interface(%u)", nss_ctx, if_num);
+		nss_warning("%px: unable to un register event handler for interface(%u)", nss_ctx, if_num);
 		return;
 	}
 
-	nss_top_main.if_rx_msg_callback[if_num] = NULL;
+	ret = nss_core_unregister_handler(nss_ctx, if_num);
+	if (ret != NSS_CORE_STATUS_SUCCESS) {
+		nss_warning("%px: unable to un register event handler for interface(%u)", nss_ctx, if_num);
+		return;
+	}
 
 	return;
 }
@@ -426,12 +434,12 @@ struct nss_ctx_instance *nss_tls_registe
 	uint32_t ret;
 
 	if (!nss_tls_verify_ifnum(nss_ctx, if_num)) {
-		nss_warning("%p: TLS Interface is not dynamic:%u", nss_ctx, if_num);
+		nss_warning("%px: TLS Interface is not dynamic:%u", nss_ctx, if_num);
 		return NULL;
 	}
 
 	if (nss_ctx->subsys_dp_register[if_num].ndev) {
-		nss_warning("%p: Cannot find free slot for TLS NSS I/F:%u", nss_ctx, if_num);
+		nss_warning("%px: Cannot find free slot for TLS NSS I/F:%u", nss_ctx, if_num);
 		return NULL;
 	}
 
@@ -440,11 +448,16 @@ struct nss_ctx_instance *nss_tls_registe
 
 	ret = nss_core_register_handler(nss_ctx, if_num, nss_tls_handler, app_data);
 	if (ret != NSS_CORE_STATUS_SUCCESS) {
-		nss_warning("%p: unable to register event handler for interface(%u)", nss_ctx, if_num);
+		nss_warning("%px: unable to register event handler for interface(%u)", nss_ctx, if_num);
 		return NULL;
 	}
 
-	nss_top_main.if_rx_msg_callback[if_num] = ev_cb;
+	ret = nss_core_register_msg_handler(nss_ctx, if_num, ev_cb);
+	if (ret != NSS_CORE_STATUS_SUCCESS) {
+		nss_core_unregister_handler(nss_ctx, if_num);
+		nss_warning("%px: unable to register event handler for interface(%u)", nss_ctx, if_num);
+		return NULL;
+	}
 
 	/*
 	 * Atomically set the bitmap for the interface number
@@ -461,9 +474,10 @@ EXPORT_SYMBOL(nss_tls_register_if);
 void nss_tls_unregister_if(uint32_t if_num)
 {
 	struct nss_ctx_instance *nss_ctx = nss_tls_get_context();
+	uint32_t ret;
 
 	if (!nss_ctx->subsys_dp_register[if_num].ndev) {
-		nss_warning("%p: Cannot find registered netdev for TLS NSS I/F:%u", nss_ctx, if_num);
+		nss_warning("%px: Cannot find registered netdev for TLS NSS I/F:%u", nss_ctx, if_num);
 		return;
 	}
 
@@ -472,8 +486,13 @@ void nss_tls_unregister_if(uint32_t if_n
 	 */
 	clear_bit(if_num, tls_pvt.if_map);
 
+	ret = nss_core_unregister_msg_handler(nss_ctx, if_num);
+	if (ret != NSS_CORE_STATUS_SUCCESS) {
+		nss_warning("%px: unable to un register event handler for interface(%u)", nss_ctx, if_num);
+		return;
+	}
+
 	nss_core_unregister_handler(nss_ctx, if_num);
-	nss_top_main.if_rx_msg_callback[if_num] = NULL;
 
 	nss_core_unregister_subsys_dp(nss_ctx, if_num);
 }
--- a/nss_tls_log.c
+++ b/nss_tls_log.c
@@ -63,7 +63,7 @@ static int8_t *nss_tls_log_error_respons
  */
 static void nss_tls_node_config_msg(struct nss_tls_msg *ntm)
 {
-	nss_trace("%p: NSS TLS Node Configure Message:\n"
+	nss_trace("%px: NSS TLS Node Configure Message:\n"
 			"TLS Interface: %d\n", ntm, ntm->cm.interface);
 }
 
@@ -74,7 +74,7 @@ static void nss_tls_node_config_msg(stru
 static void nss_tls_ctx_config_msg(struct nss_tls_msg *ntm)
 {
 	struct nss_tls_ctx_config *ntccm __maybe_unused = &ntm->msg.ctx_cfg;
-	nss_trace("%p: NSS TLS Context Configure Message:\n"
+	nss_trace("%px: NSS TLS Context Configure Message:\n"
 		"TLS Except if_num: %d\n",
 		ntccm, ntccm->except_ifnum);
 }
@@ -86,7 +86,7 @@ static void nss_tls_ctx_config_msg(struc
 static void nss_tls_cipher_update_msg(struct nss_tls_msg *ntm)
 {
 	struct nss_tls_cipher_update *ntcum __maybe_unused = &ntm->msg.cipher_update;
-	nss_trace("%p: NSS TLS Cipher Update message\n"
+	nss_trace("%px: NSS TLS Cipher Update message\n"
 		"TLS crypto index: %d\n",
 		ntcum, ntcum->crypto_idx);
 }
@@ -111,7 +111,7 @@ static void nss_tls_log_verbose(struct n
 		break;
 
 	default:
-		nss_warning("%p: Invalid message type\n", ntm);
+		nss_warning("%px: Invalid message type\n", ntm);
 		break;
 	}
 }
@@ -123,11 +123,11 @@ static void nss_tls_log_verbose(struct n
 void nss_tls_log_tx_msg(struct nss_tls_msg *ntm)
 {
 	if (ntm->cm.type >= NSS_TLS_MSG_MAX) {
-		nss_warning("%p: Invalid message type\n", ntm);
+		nss_warning("%px: Invalid message type\n", ntm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", ntm, ntm->cm.type, nss_tls_log_message_types_str[ntm->cm.type]);
+	nss_info("%px: type[%d]:%s\n", ntm, ntm->cm.type, nss_tls_log_message_types_str[ntm->cm.type]);
 	nss_tls_log_verbose(ntm);
 }
 
@@ -138,26 +138,26 @@ void nss_tls_log_tx_msg(struct nss_tls_m
 void nss_tls_log_rx_msg(struct nss_tls_msg *ntm)
 {
 	if (ntm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", ntm);
+		nss_warning("%px: Invalid response\n", ntm);
 		return;
 	}
 
 	if (ntm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (ntm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", ntm, ntm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", ntm, ntm->cm.type,
 			nss_tls_log_message_types_str[ntm->cm.type],
 			ntm->cm.response, nss_cmn_response_str[ntm->cm.response]);
 		goto verbose;
 	}
 
 	if (ntm->cm.error >= NSS_TLS_ERROR_MAX) {
-		nss_warning("%p: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
+		nss_warning("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
 			ntm, ntm->cm.type, nss_tls_log_message_types_str[ntm->cm.type],
 			ntm->cm.response, nss_cmn_response_str[ntm->cm.response],
 			ntm->cm.error);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
 		ntm, ntm->cm.type, nss_tls_log_message_types_str[ntm->cm.type],
 		ntm->cm.response, nss_cmn_response_str[ntm->cm.response],
 		ntm->cm.error, nss_tls_log_error_response_types_str[ntm->cm.error]);
--- a/nss_trustsec_tx.c
+++ b/nss_trustsec_tx.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2016-2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016-2018, 2020 The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -31,7 +31,7 @@ static struct nss_trustsec_tx_pvt {
 
 /*
  * nss_trustsec_tx_handler()
- * 	Handle NSS -> HLOS messages for trustsec_tx
+ *	Handle NSS -> HLOS messages for trustsec_tx
  */
 static void nss_trustsec_tx_handler(struct nss_ctx_instance *nss_ctx, struct nss_cmn_msg *ncm,
 				__attribute__((unused))void *app_data)
@@ -49,13 +49,13 @@ static void nss_trustsec_tx_handler(stru
 	/*
 	 * Is this a valid request/response packet?
 	 */
-	if (ncm->type >= NSS_TRUSTSEC_TX_MAX_MSG_TYPE) {
-		nss_warning("%p: received invalid message %d for trustsec_tx interface", nss_ctx, ncm->type);
+	if (ncm->type >= NSS_TRUSTSEC_TX_MSG_MAX) {
+		nss_warning("%px: received invalid message %d for trustsec_tx interface", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_trustsec_tx_msg)) {
-		nss_warning("%p: message size incorrect: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: message size incorrect: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
@@ -65,7 +65,7 @@ static void nss_trustsec_tx_handler(stru
 	nss_core_log_msg_failures(nss_ctx, ncm);
 
 	switch (ncm->type) {
-	case NSS_TRUSTSEC_TX_STATS_SYNC_MSG:
+	case NSS_TRUSTSEC_TX_MSG_STATS_SYNC:
 		/*
 		 * Update trustsec_tx statistics.
 		 */
@@ -78,7 +78,7 @@ static void nss_trustsec_tx_handler(stru
 	 * to the same callback/app_data.
 	 */
 	if (ncm->response == NSS_CMN_RESPONSE_NOTIFY) {
-		ncm->cb = (nss_ptr_t)nss_ctx->nss_top->if_rx_msg_callback[ncm->interface];
+		ncm->cb = (nss_ptr_t)nss_core_get_msg_handler(nss_ctx, ncm->interface);
 		ncm->app_data = (nss_ptr_t)nss_ctx->subsys_dp_register[ncm->interface].ndev;
 	}
 
@@ -99,7 +99,7 @@ static void nss_trustsec_tx_handler(stru
 
 /*
  * nss_trustsec_tx_msg()
- * 	Transmit a trustsec_tx message to NSSFW
+ *	Transmit a trustsec_tx message to NSSFW
  */
 nss_tx_status_t nss_trustsec_tx_msg(struct nss_ctx_instance *nss_ctx, struct nss_trustsec_tx_msg *msg)
 {
@@ -114,12 +114,12 @@ nss_tx_status_t nss_trustsec_tx_msg(stru
 	 * Sanity check the message
 	 */
 	if (ncm->interface != NSS_TRUSTSEC_TX_INTERFACE) {
-		nss_warning("%p: tx request for another interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: tx request for another interface: %d", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
-	if (ncm->type > NSS_TRUSTSEC_TX_MAX_MSG_TYPE) {
-		nss_warning("%p: message type out of range: %d", nss_ctx, ncm->type);
+	if (ncm->type > NSS_TRUSTSEC_TX_MSG_MAX) {
+		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
@@ -160,14 +160,14 @@ nss_tx_status_t nss_trustsec_tx_msg_sync
 
 	status = nss_trustsec_tx_msg(nss_ctx, msg);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: nss_trustsec_tx_msg failed\n", nss_ctx);
+		nss_warning("%px: nss_trustsec_tx_msg failed\n", nss_ctx);
 		up(&ttx.sem);
 		return status;
 	}
 
 	ret = wait_for_completion_timeout(&ttx.complete, msecs_to_jiffies(NSS_TRUSTSEC_TX_TIMEOUT));
 	if (!ret) {
-		nss_warning("%p: trustsec_tx tx failed due to timeout\n", nss_ctx);
+		nss_warning("%px: trustsec_tx tx failed due to timeout\n", nss_ctx);
 		ttx.response = NSS_TX_FAILURE;
 	}
 
@@ -200,28 +200,55 @@ void nss_trustsec_tx_msg_init(struct nss
 EXPORT_SYMBOL(nss_trustsec_tx_msg_init);
 
 /*
+ * nss_trustsec_tx_update_nexthop()
+ */
+nss_tx_status_t nss_trustsec_tx_update_nexthop(uint32_t src, uint32_t dest, uint16_t sgt)
+{
+	struct nss_ctx_instance *ctx = nss_trustsec_tx_get_ctx();
+	struct nss_trustsec_tx_msg ttx_msg = {{0}};
+	struct nss_trustsec_tx_update_nexthop_msg *ttxunh;
+	nss_tx_status_t status;
+
+	ttxunh = &ttx_msg.msg.upd_nexthop;
+	ttxunh->src = src;
+	ttxunh->dest = dest;
+	ttxunh->sgt = sgt;
+
+	nss_trustsec_tx_msg_init(&ttx_msg, NSS_TRUSTSEC_TX_INTERFACE, NSS_TRUSTSEC_TX_MSG_UPDATE_NEXTHOP,
+			sizeof(*ttxunh), NULL, NULL);
+
+	BUG_ON(in_atomic());
+	status = nss_trustsec_tx_msg_sync(ctx, &ttx_msg);
+	if (status != NSS_TX_SUCCESS) {
+		nss_warning("%px: configure trustsec_tx failed: %d\n", ctx, status);
+	}
+
+	return status;
+}
+EXPORT_SYMBOL(nss_trustsec_tx_update_nexthop);
+
+/*
  * nss_trustsec_tx_configure_sgt()
  */
 nss_tx_status_t nss_trustsec_tx_configure_sgt(uint32_t src, uint32_t dest, uint16_t sgt)
 {
 	struct nss_ctx_instance *ctx = nss_trustsec_tx_get_ctx();
-	struct nss_trustsec_tx_msg ttx_msg;
+	struct nss_trustsec_tx_msg ttx_msg = {{0}};
 	struct nss_trustsec_tx_configure_msg *ttxcfg;
 	nss_tx_status_t status;
 
-	memset(&ttx_msg, 0, sizeof(struct nss_trustsec_tx_msg));
 	ttxcfg = &ttx_msg.msg.configure;
 	ttxcfg->src = src;
 	ttxcfg->dest = dest;
 	ttxcfg->sgt = sgt;
 
-	nss_trustsec_tx_msg_init(&ttx_msg, NSS_TRUSTSEC_TX_INTERFACE, NSS_TRUSTSEC_TX_CONFIGURE_MSG,
-			sizeof(struct nss_trustsec_tx_configure_msg),
-			NULL, NULL);
+	nss_trustsec_tx_msg_init(&ttx_msg, NSS_TRUSTSEC_TX_INTERFACE, NSS_TRUSTSEC_TX_MSG_CONFIGURE,
+			sizeof(*ttxcfg), NULL, NULL);
 
+	BUG_ON(in_atomic());
 	status = nss_trustsec_tx_msg_sync(ctx, &ttx_msg);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: configure trustsec_tx failed: %d\n", ctx, status);
+		nss_warning("%px: configure trustsec_tx failed: %d\n", ctx, status);
 	}
 
 	return status;
@@ -234,22 +261,21 @@ EXPORT_SYMBOL(nss_trustsec_tx_configure_
 nss_tx_status_t nss_trustsec_tx_unconfigure_sgt(uint32_t src, uint16_t sgt)
 {
 	struct nss_ctx_instance *ctx = nss_trustsec_tx_get_ctx();
-	struct nss_trustsec_tx_msg ttx_msg;
+	struct nss_trustsec_tx_msg ttx_msg = {{0}};
 	struct nss_trustsec_tx_unconfigure_msg *ttxucfg;
 	nss_tx_status_t status;
 
-	memset(&ttx_msg, 0, sizeof(struct nss_trustsec_tx_msg));
 	ttxucfg = &ttx_msg.msg.unconfigure;
 	ttxucfg->src = src;
 	ttxucfg->sgt = sgt;
 
-	nss_trustsec_tx_msg_init(&ttx_msg, NSS_TRUSTSEC_TX_INTERFACE, NSS_TRUSTSEC_TX_UNCONFIGURE_MSG,
-			sizeof(struct nss_trustsec_tx_unconfigure_msg),
-			NULL, NULL);
+	nss_trustsec_tx_msg_init(&ttx_msg, NSS_TRUSTSEC_TX_INTERFACE, NSS_TRUSTSEC_TX_MSG_UNCONFIGURE,
+			sizeof(*ttxucfg), NULL, NULL);
 
+	BUG_ON(in_atomic());
 	status = nss_trustsec_tx_msg_sync(ctx, &ttx_msg);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: unconfigure trustsec_tx failed: %d\n", ctx, status);
+		nss_warning("%px: unconfigure trustsec_tx failed: %d\n", ctx, status);
 	}
 
 	return status;
--- a/nss_trustsec_tx_log.c
+++ b/nss_trustsec_tx_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, 2020 The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -25,10 +25,11 @@
  * nss_trustsec_tx_log_message_types_str
  *	TRUSTSEC_TX message strings
  */
-static int8_t *nss_trustsec_tx_log_message_types_str[NSS_TRUSTSEC_TX_MAX_MSG_TYPE] __maybe_unused = {
+static int8_t *nss_trustsec_tx_log_message_types_str[NSS_TRUSTSEC_TX_MSG_MAX] __maybe_unused = {
 	"TRUSTSEC_TX Configure Message",
 	"TRUSTSEC_TX Unconfigure Message",
 	"TRUSTSEC_TX Stats Sync",
+	"TRUSTSEC_TX Update next Hop",
 };
 
 /*
@@ -40,6 +41,7 @@ static int8_t *nss_trustsec_tx_log_error
 	"TRUSTSEC_TX Reconfigure Source Interface"
 	"TRUSTSEC_TX Destination Interface Not Found",
 	"TRUSTSEC_TX Not Configured",
+	"TRUSTSEC_TX SGT Mismatch",
 	"TRUSTSEC_TX Unknown Error",
 };
 
@@ -50,7 +52,7 @@ static int8_t *nss_trustsec_tx_log_error
 static void nss_trustsec_tx_log_configure_msg(struct nss_trustsec_tx_msg *ntm)
 {
 	struct nss_trustsec_tx_configure_msg *ntcm __maybe_unused = &ntm->msg.configure;
-	nss_trace("%p: NSS TRUSTSEC_TX Configure Message:\n"
+	nss_trace("%px: NSS TRUSTSEC_TX Configure Message:\n"
 		"TRUSTSEC_TX Source: %d\n"
 		"TRUSTSEC_TX Destination: %d\n"
 		"TRUSTSEC_TX Security Group Tag: %d\n",
@@ -65,35 +67,54 @@ static void nss_trustsec_tx_log_configur
 static void nss_trustsec_tx_log_unconfigure_msg(struct nss_trustsec_tx_msg *ntm)
 {
 	struct nss_trustsec_tx_unconfigure_msg *ntcm __maybe_unused = &ntm->msg.unconfigure;
-	nss_trace("%p: NSS TRUSTSEC_TX Unconfigure Message:\n"
+	nss_trace("%px: NSS TRUSTSEC_TX Unconfigure Message:\n"
 		"TRUSTSEC_TX Source: %d\n"
 		"TRUSTSEC_TX Security Group Tag: %d\n",
 		ntcm, ntcm->src, ntcm->sgt);
 }
 
 /*
+ * nss_trustsec_tx_log_update_nexthop_msg()
+ *	Log NSS TRUSTSEC_TX update nexthop message.
+ */
+static void nss_trustsec_tx_log_update_nexthop_msg(struct nss_trustsec_tx_msg *ntm)
+{
+	struct nss_trustsec_tx_update_nexthop_msg *ntunm __maybe_unused = &ntm->msg.upd_nexthop;
+	nss_trace("%px: NSS TRUSTSEC_TX Update Next Hop Message:\n"
+		"TRUSTSEC_TX Source: %d\n"
+		"TRUSTSEC_TX Destination: %d\n"
+		"TRUSTSEC_TX Security Group Tag: %d\n",
+		ntunm, ntunm->src,
+		ntunm->dest, ntunm->sgt);
+}
+
+/*
  * nss_trustsec_tx_log_verbose()
  *	Log message contents.
  */
 static void nss_trustsec_tx_log_verbose(struct nss_trustsec_tx_msg *ntm)
 {
 	switch (ntm->cm.type) {
-	case NSS_TRUSTSEC_TX_CONFIGURE_MSG:
+	case NSS_TRUSTSEC_TX_MSG_CONFIGURE:
 		nss_trustsec_tx_log_configure_msg(ntm);
 		break;
 
-	case NSS_TRUSTSEC_TX_UNCONFIGURE_MSG:
+	case NSS_TRUSTSEC_TX_MSG_UNCONFIGURE:
 		nss_trustsec_tx_log_unconfigure_msg(ntm);
 		break;
 
-	case NSS_TRUSTSEC_TX_STATS_SYNC_MSG:
+	case NSS_TRUSTSEC_TX_MSG_UPDATE_NEXTHOP:
+		nss_trustsec_tx_log_update_nexthop_msg(ntm);
+		break;
+
+	case NSS_TRUSTSEC_TX_MSG_STATS_SYNC:
 		/*
 		 * No log for valid stats message.
 		 */
 		break;
 
 	default:
-		nss_warning("%p: Invalid message type\n", ntm);
+		nss_warning("%px: Invalid message type\n", ntm);
 		break;
 	}
 }
@@ -104,12 +125,12 @@ static void nss_trustsec_tx_log_verbose(
  */
 void nss_trustsec_tx_log_tx_msg(struct nss_trustsec_tx_msg *ntm)
 {
-	if (ntm->cm.type >= NSS_TRUSTSEC_TX_MAX_MSG_TYPE) {
-		nss_warning("%p: Invalid message type\n", ntm);
+	if (ntm->cm.type >= NSS_TRUSTSEC_TX_MSG_MAX) {
+		nss_warning("%px: Invalid message type\n", ntm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", ntm, ntm->cm.type, nss_trustsec_tx_log_message_types_str[ntm->cm.type]);
+	nss_info("%px: type[%d]:%s\n", ntm, ntm->cm.type, nss_trustsec_tx_log_message_types_str[ntm->cm.type]);
 	nss_trustsec_tx_log_verbose(ntm);
 }
 
@@ -120,26 +141,26 @@ void nss_trustsec_tx_log_tx_msg(struct n
 void nss_trustsec_tx_log_rx_msg(struct nss_trustsec_tx_msg *ntm)
 {
 	if (ntm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", ntm);
+		nss_warning("%px: Invalid response\n", ntm);
 		return;
 	}
 
 	if (ntm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (ntm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", ntm, ntm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", ntm, ntm->cm.type,
 			nss_trustsec_tx_log_message_types_str[ntm->cm.type],
 			ntm->cm.response, nss_cmn_response_str[ntm->cm.response]);
 		goto verbose;
 	}
 
 	if (ntm->cm.error >= NSS_TRUSTSEC_TX_ERR_UNKNOWN) {
-		nss_warning("%p: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
+		nss_warning("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
 			ntm, ntm->cm.type, nss_trustsec_tx_log_message_types_str[ntm->cm.type],
 			ntm->cm.response, nss_cmn_response_str[ntm->cm.response],
 			ntm->cm.error);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
 		ntm, ntm->cm.type, nss_trustsec_tx_log_message_types_str[ntm->cm.type],
 		ntm->cm.response, nss_cmn_response_str[ntm->cm.response],
 		ntm->cm.error, nss_trustsec_tx_log_error_response_types_str[ntm->cm.error]);
--- a/nss_tstamp.c
+++ b/nss_tstamp.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2015-2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2015-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -80,7 +80,6 @@ static bool nss_tstamp_verify_if_num(uin
 	return (if_num == NSS_TSTAMP_TX_INTERFACE) || (if_num == NSS_TSTAMP_RX_INTERFACE);
 }
 
-
 /*
  * nss_tstamp_interface_handler()
  *	Handle NSS -> HLOS messages for TSTAMP Statistics
@@ -92,7 +91,7 @@ static void nss_tstamp_interface_handler
 	nss_tstamp_msg_callback_t cb;
 
 	if (!nss_tstamp_verify_if_num(ncm->interface)) {
-		nss_warning("%p: invalid interface %d for tstamp_tx", nss_ctx, ncm->interface);
+		nss_warning("%px: invalid interface %d for tstamp_tx", nss_ctx, ncm->interface);
 		return;
 	}
 
@@ -100,12 +99,12 @@ static void nss_tstamp_interface_handler
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >= NSS_TSTAMP_MSG_TYPE_MAX) {
-		nss_warning("%p: received invalid message %d for tstamp", nss_ctx, ncm->type);
+		nss_warning("%px: received invalid message %d for tstamp", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_tstamp_msg)) {
-		nss_warning("%p: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
@@ -119,7 +118,7 @@ static void nss_tstamp_interface_handler
 		nss_tstamp_stats_sync(nss_ctx, &ntm->msg.stats, ncm->interface);
 		break;
 	default:
-		nss_warning("%p: Unknown message type %d",
+		nss_warning("%px: Unknown message type %d",
 				 nss_ctx, ncm->type);
 		return;
 	}
@@ -208,7 +207,7 @@ static struct net_device *nss_tstamp_get
 		break;
 
 	default:
-		nss_warning("%p:could not get dev for the skb\n", skb);
+		nss_warning("%px:could not get dev for the skb\n", skb);
 		return NULL;
 	}
 
@@ -322,7 +321,7 @@ nss_tx_status_t nss_tstamp_tx_buf(struct
 	char *align_data;
 	uint32_t hdr_sz;
 
-	nss_trace("%p: Tstamp If Tx packet, id:%d, data=%p", nss_ctx, NSS_TSTAMP_RX_INTERFACE, skb->data);
+	nss_trace("%px: Tstamp If Tx packet, id:%d, data=%px", nss_ctx, NSS_TSTAMP_RX_INTERFACE, skb->data);
 
 	/*
 	 * header size + alignment size
@@ -340,7 +339,7 @@ nss_tx_status_t nss_tstamp_tx_buf(struct
 		if (skb->end - skb->tail >= extra_head)
 			extra_tail = -extra_head;
 		if (pskb_expand_head(skb, extra_head, extra_tail, GFP_KERNEL)) {
-			nss_trace("%p: expand head room failed", nss_ctx);
+			nss_trace("%px: expand head room failed", nss_ctx);
 			return NSS_TX_FAILURE;
 		}
 	}
@@ -356,7 +355,6 @@ nss_tx_status_t nss_tstamp_tx_buf(struct
 }
 EXPORT_SYMBOL(nss_tstamp_tx_buf);
 
-
 /*
  * nss_tstamp_register_netdev()
  *	register dummy netdevice for tstamp interface
--- a/nss_tun6rd.c
+++ b/nss_tun6rd.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -39,12 +39,12 @@ static void nss_tun6rd_handler(struct ns
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >= NSS_TUN6RD_MAX) {
-		nss_warning("%p: received invalid message %d for Tun6RD interface", nss_ctx, ncm->type);
+		nss_warning("%px: received invalid message %d for Tun6RD interface", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_tun6rd_msg)) {
-		nss_warning("%p: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
@@ -78,7 +78,7 @@ static void nss_tun6rd_handler(struct ns
 	 * call 6rd tunnel callback
 	 */
 	if (!ctx) {
-		nss_warning("%p: Event received for 6rd tunnel interface %d before registration", nss_ctx, ncm->interface);
+		nss_warning("%px: Event received for 6rd tunnel interface %d before registration", nss_ctx, ncm->interface);
 		return;
 	}
 
@@ -102,12 +102,12 @@ nss_tx_status_t nss_tun6rd_tx(struct nss
 	 * Sanity check the message
 	 */
 	if (!nss_is_dynamic_interface(ncm->interface)) {
-		nss_warning("%p: tx request for another interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: tx request for another interface: %d", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
 	if (ncm->type > NSS_TUN6RD_MAX) {
-		nss_warning("%p: message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
--- a/nss_tun6rd_log.c
+++ b/nss_tun6rd_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018-2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -38,7 +38,7 @@ static int8_t *nss_tun6rd_log_message_ty
 static void nss_tun6rd_log_attach_pnode_msg(struct nss_tun6rd_msg *ntm)
 {
 	struct nss_tun6rd_attach_tunnel_msg *ntam __maybe_unused = &ntm->msg.tunnel;
-	nss_trace("%p: NSS TUN6RD Attach Tunnel message \n"
+	nss_trace("%px: NSS TUN6RD Attach Tunnel message \n"
 		"TUN6RD Source Address: %pI4\n"
 		"TUN6RD Destination Address: %pI4\n"
 		"TUN6RD Type of Service: %d\n"
@@ -56,7 +56,7 @@ static void nss_tun6rd_log_attach_pnode_
 static void nss_tun6rd_log_set_peer_msg(struct nss_tun6rd_msg *ntm)
 {
 	struct nss_tun6rd_set_peer_msg *ntspm __maybe_unused = &ntm->msg.peer;
-	nss_trace("%p: NSS TUN6RD Set Peer message \n"
+	nss_trace("%px: NSS TUN6RD Set Peer message \n"
 		"TUN6RD IPv6 Address: %pI6\n"
 		"TUN6RD Destination: %pI4\n",
 		ntspm, ntspm->ipv6_address,
@@ -85,7 +85,7 @@ static void nss_tun6rd_log_verbose(struc
 		break;
 
 	default:
-		nss_trace("%p: Invalid message type\n", ntm);
+		nss_trace("%px: Invalid message type\n", ntm);
 		break;
 	}
 }
@@ -97,11 +97,11 @@ static void nss_tun6rd_log_verbose(struc
 void nss_tun6rd_log_tx_msg(struct nss_tun6rd_msg *ntm)
 {
 	if (ntm->cm.type >= NSS_TUN6RD_MAX) {
-		nss_warning("%p: Invalid message type\n", ntm);
+		nss_warning("%px: Invalid message type\n", ntm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", ntm, ntm->cm.type, nss_tun6rd_log_message_types_str[ntm->cm.type]);
+	nss_info("%px: type[%d]:%s\n", ntm, ntm->cm.type, nss_tun6rd_log_message_types_str[ntm->cm.type]);
 	nss_tun6rd_log_verbose(ntm);
 }
 
@@ -112,18 +112,18 @@ void nss_tun6rd_log_tx_msg(struct nss_tu
 void nss_tun6rd_log_rx_msg(struct nss_tun6rd_msg *ntm)
 {
 	if (ntm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", ntm);
+		nss_warning("%px: Invalid response\n", ntm);
 		return;
 	}
 
 	if (ntm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (ntm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", ntm, ntm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", ntm, ntm->cm.type,
 			nss_tun6rd_log_message_types_str[ntm->cm.type],
 			ntm->cm.response, nss_cmn_response_str[ntm->cm.response]);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s\n",
 		ntm, ntm->cm.type, nss_tun6rd_log_message_types_str[ntm->cm.type],
 		ntm->cm.response, nss_cmn_response_str[ntm->cm.response]);
 
--- a/nss_tunipip6.c
+++ b/nss_tunipip6.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -17,6 +17,19 @@
 #include "nss_tx_rx_common.h"
 #include "nss_tunipip6_log.h"
 
+#define NSS_TUNIPIP6_TX_TIMEOUT 3000
+
+/*
+ * Data structure used to handle sync message.
+ */
+static struct nss_tunipip6_pvt {
+	struct semaphore sem;           /* Semaphore structure. */
+	struct completion complete;     /* Completion structure. */
+	int response;                   /* Response from FW. */
+	void *cb;                       /* Original cb for msgs. */
+	void *app_data;                 /* Original app_data for msgs. */
+} tunipip6_pvt;
+
 /*
  * nss_tunipip6_verify_if_num
  *	Verify the interface is a valid interface
@@ -57,12 +70,12 @@ static void nss_tunipip6_handler(struct
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >= NSS_TUNIPIP6_MAX) {
-		nss_warning("%p: received invalid message %d for DS-Lite interface", nss_ctx, ncm->type);
+		nss_warning("%px: received invalid message %d for DS-Lite interface", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_tunipip6_msg)) {
-		nss_warning("%p: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
@@ -96,7 +109,7 @@ static void nss_tunipip6_handler(struct
 	 * call ipip6 tunnel callback
 	 */
 	if (!ctx) {
-		 nss_warning("%p: Event received for DS-Lite tunnel interface %d before registration", nss_ctx, ncm->interface);
+		 nss_warning("%px: Event received for DS-Lite tunnel interface %d before registration", nss_ctx, ncm->interface);
 		return;
 	}
 
@@ -120,12 +133,12 @@ nss_tx_status_t nss_tunipip6_tx(struct n
 	 * Sanity check the message
 	 */
 	if (!nss_tunipip6_verify_if_num(ncm->interface)) {
-		nss_warning("%p: tx request for another interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: tx request for another interface: %d", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
 	if (ncm->type > NSS_TUNIPIP6_MAX) {
-		nss_warning("%p: message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
@@ -134,6 +147,60 @@ nss_tx_status_t nss_tunipip6_tx(struct n
 EXPORT_SYMBOL(nss_tunipip6_tx);
 
 /*
+ * nss_tunipip6_callback()
+ *	Callback to handle the completion of NSS->HLOS messages.
+ */
+static void nss_tunipip6_callback(void *app_data, struct nss_tunipip6_msg *nclm)
+{
+	tunipip6_pvt.response = NSS_TX_SUCCESS;
+	tunipip6_pvt.cb = NULL;
+	tunipip6_pvt.app_data = NULL;
+
+	if (nclm->cm.response != NSS_CMN_RESPONSE_ACK) {
+		nss_warning("%px: tunipip6 Error response %d Error: %d\n", app_data, nclm->cm.response, nclm->cm.error);
+		tunipip6_pvt.response = nclm->cm.response;
+	}
+
+	/*
+	 * Write memory barrier.
+	 */
+	smp_wmb();
+	complete(&tunipip6_pvt.complete);
+}
+
+/*
+ * nss_tunipip6_tx_sync()
+ * 	Transmit a tunipip6 message to NSSFW synchronously.
+ */
+nss_tx_status_t nss_tunipip6_tx_sync(struct nss_ctx_instance *nss_ctx, struct nss_tunipip6_msg *msg)
+{
+	nss_tx_status_t status;
+	int ret;
+
+	down(&tunipip6_pvt.sem);
+	msg->cm.cb = (nss_ptr_t)nss_tunipip6_callback;
+	msg->cm.app_data = (nss_ptr_t)NULL;
+
+	status = nss_tunipip6_tx(nss_ctx, msg);
+	if (status != NSS_TX_SUCCESS) {
+		nss_warning("%px: tunipip6_tx_msg failed\n", nss_ctx);
+		up(&tunipip6_pvt.sem);
+		return status;
+	}
+
+	ret = wait_for_completion_timeout(&tunipip6_pvt.complete, msecs_to_jiffies(NSS_TUNIPIP6_TX_TIMEOUT));
+	if (!ret) {
+		nss_warning("%px: tunipip6 tx sync failed due to timeout\n", nss_ctx);
+		tunipip6_pvt.response = NSS_TX_FAILURE;
+	}
+
+	status = tunipip6_pvt.response;
+	up(&tunipip6_pvt.sem);
+	return status;
+}
+EXPORT_SYMBOL(nss_tunipip6_tx_sync);
+
+/*
  * **********************************
  *  Register/Unregister/Miscellaneous APIs
  * **********************************
@@ -197,6 +264,8 @@ void nss_tunipip6_register_handler()
 	struct nss_ctx_instance *nss_ctx = nss_tunipip6_get_context();
 
 	nss_core_register_handler(nss_ctx, NSS_TUNIPIP6_INTERFACE, nss_tunipip6_handler, NULL);
+	sema_init(&tunipip6_pvt.sem, 1);
+	init_completion(&tunipip6_pvt.complete);
 }
 
 /*
--- a/nss_tunipip6_log.c
+++ b/nss_tunipip6_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -26,47 +26,63 @@
  *	NSS TUNIPIP6 message strings
  */
 static int8_t *nss_tunipip6_log_message_types_str[NSS_TUNIPIP6_MAX] __maybe_unused = {
-	"TUNIPIP6 Interface Create",
+	"TUNIPIP6 Encap Interface Create",
+	"TUNIPIP6 Decap Interface Create",
 	"TUNIPIP6 Stats",
+	"TUNIPIP6 FMR add",
+	"TUNIPIP6 FMR delete",
+	"TUNIPIP6 FMR flush",
+	"TUNIPIP6 BMR add",
+	"TUNIPIP6 BMR delete",
 };
 
 /*
+ * nss_tunipip6_log_map_rule()
+ *	Log NSS TUNIPIP6 map rule.
+ */
+static void nss_tunipip6_log_map_rule(struct nss_tunipip6_msg *ntm)
+{
+	struct nss_tunipip6_map_rule *nmr __maybe_unused = &ntm->msg.map_rule;
+	nss_trace("%px: NSS TUNIPIP6 Interface Create message \n"
+		"TUNIPIP6 Map Rule IPv6 prefix: %pI6\n"
+		"TUNIPIP6 Map Rule IPv6 prefix length: %d\n"
+		"TUNIPIP6 Map Rule IPv4 prefix: %pI4\n"
+		"TUNIPIP6 Map Rule IPv4 prefix length: %d\n"
+		"TUNIPIP6 Map Rule IPv6 suffix: %pI6\n"
+		"TUNIPIP6 Map Rule IPv6 suffix length: %d\n"
+		"TUNIPIP6 Map Rule EA length: %d\n"
+		"TUNIPIP6 Map Rule PSID offset: %d\n",
+		nmr, nmr->ip6_prefix,
+		nmr->ip6_prefix_len,&nmr->ip4_prefix,
+		nmr->ip4_prefix_len, nmr->ip6_suffix,
+		nmr->ip6_suffix_len, nmr->ea_len,
+		nmr->psid_offset);
+}
+
+/*
  * nss_tunipip6_log_if_create_msg()
  *	Log NSS TUNIPIP6 Interface Create
  */
 static void nss_tunipip6_log_if_create_msg(struct nss_tunipip6_msg *ntm)
 {
 	struct nss_tunipip6_create_msg *ntcm __maybe_unused = &ntm->msg.tunipip6_create;
-	int32_t i;
-	nss_trace("%p: NSS TUNIPIP6 Interface Create message \n"
+	nss_trace("%px: NSS TUNIPIP6 Interface Create message \n"
 		"TUNIPIP6 Source Address: %pI6\n"
 		"TUNIPIP6 Destination Address: %pI6\n"
 		"TUNIPIP6 Flow Label: %d\n"
 		"TUNIPIP6 Flags: %d\n"
 		"TUNIPIP6 Hop Limit: %d\n"
 		"TUNIPIP6 Draft03 Specification: %d\n"
-		"TUNIPIP6 FMR Number: %d\n",
+		"TUNIPIP6 TTL inherit: %s\n"
+		"TUNIPIP6 TOS inherit: %s\n"
+		"TUNIPIP6 Frag ID Update: %s\n",
 		ntcm, ntcm->saddr,
 		ntcm->daddr, ntcm->flowlabel,
 		ntcm->flags, ntcm->hop_limit,
-		ntcm->draft03, ntcm->fmr_number);
-	/*
-	 * Continuation of the log.
-	 */
-	for (i = 0; i < NSS_TUNIPIP6_MAX_FMR_NUMBER; i++) {
-		nss_trace("TUNIPIP6 FMR[%d] IPv6 Prefix: %pI6\n"
-			"TUNIPIP6 FMR[%d] IPv4 Prefix: %pI4\n"
-			"TUNIPIP6 FMR[%d] IPv6 Prefix Length: %d\n"
-			"TUNIPIP6 FMR[%d] IPv4 Prefix Length: %d\n"
-			"TUNIPIP6 FMR[%d] Embedded Address Length: %d\n"
-			"TUNIPIP6 FMR[%d] offset: %d",
-			i, ntcm->fmr[i].ip6_prefix,
-			i, &ntcm->fmr[i].ip4_prefix,
-			i, ntcm->fmr[i].ip6_prefix_len,
-			i, ntcm->fmr[i].ip4_prefix_len,
-			i, ntcm->fmr[i].ea_len,
-			i, ntcm->fmr[i].offset);
-	}
+		ntcm->draft03,
+		ntcm->ttl_inherit ? "true":"false",
+		ntcm->tos_inherit ? "true":"false",
+		ntcm->frag_id_update ? "true":"false");
 }
 
 /*
@@ -87,8 +103,17 @@ static void nss_tunipip6_log_verbose(str
 		 */
 		break;
 
+	case NSS_TUNIPIP6_BMR_RULE_ADD:
+	case NSS_TUNIPIP6_BMR_RULE_DEL:
+	case NSS_TUNIPIP6_FMR_RULE_ADD:
+	case NSS_TUNIPIP6_FMR_RULE_DEL:
+		nss_tunipip6_log_map_rule(ntm);
+		break;
+	case NSS_TUNIPIP6_FMR_RULE_FLUSH:
+		nss_trace("%px: FMR rule flush.\n", ntm);
+		break;
 	default:
-		nss_trace("%p: Invalid message type\n", ntm);
+		nss_trace("%px: Invalid message type\n", ntm);
 		break;
 	}
 }
@@ -100,11 +125,11 @@ static void nss_tunipip6_log_verbose(str
 void nss_tunipip6_log_tx_msg(struct nss_tunipip6_msg *ntm)
 {
 	if (ntm->cm.type >= NSS_TUNIPIP6_MAX) {
-		nss_warning("%p: Invalid message type\n", ntm);
+		nss_warning("%px: Invalid message type\n", ntm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", ntm, ntm->cm.type, nss_tunipip6_log_message_types_str[ntm->cm.type]);
+	nss_info("%px: type[%d]:%s\n", ntm, ntm->cm.type, nss_tunipip6_log_message_types_str[ntm->cm.type]);
 	nss_tunipip6_log_verbose(ntm);
 }
 
@@ -115,18 +140,18 @@ void nss_tunipip6_log_tx_msg(struct nss_
 void nss_tunipip6_log_rx_msg(struct nss_tunipip6_msg *ntm)
 {
 	if (ntm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", ntm);
+		nss_warning("%px: Invalid response\n", ntm);
 		return;
 	}
 
 	if (ntm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (ntm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", ntm, ntm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", ntm, ntm->cm.type,
 			nss_tunipip6_log_message_types_str[ntm->cm.type],
 			ntm->cm.response, nss_cmn_response_str[ntm->cm.response]);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s\n",
 		ntm, ntm->cm.type, nss_tunipip6_log_message_types_str[ntm->cm.type],
 		ntm->cm.response, nss_cmn_response_str[ntm->cm.response]);
 
--- a/nss_tx_msg_sync.c
+++ b/nss_tx_msg_sync.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -101,7 +101,7 @@ static nss_tx_status_t nss_tx_msg_sync_i
 		status = tx_msg_async_with_size(nss_ctx, ncm, msg_buf_size);
 
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: Tx msg async failed\n", nss_ctx);
+		nss_warning("%px: Tx msg async failed\n", nss_ctx);
 		return status;
 	}
 
@@ -110,7 +110,7 @@ static nss_tx_status_t nss_tx_msg_sync_i
 	 */
 	ret = wait_for_completion_timeout(&sync_data->complete, msecs_to_jiffies(timeout));
 	if (!ret) {
-		nss_warning("%p: Tx msg sync timeout\n", nss_ctx);
+		nss_warning("%px: Tx msg sync timeout\n", nss_ctx);
 		return NSS_TX_FAILURE_SYNC_TIMEOUT;
 	}
 
@@ -144,7 +144,7 @@ nss_tx_status_t nss_tx_msg_sync(struct n
 	 * Check Tx msg async API
 	 */
 	if (!unlikely(tx_msg_async)) {
-		nss_warning("%p: missing Tx msg async API\n", nss_ctx);
+		nss_warning("%px: missing Tx msg async API\n", nss_ctx);
 		return NSS_TX_FAILURE_SYNC_BAD_PARAM;
 	}
 
@@ -178,7 +178,7 @@ nss_tx_status_t nss_tx_msg_sync_with_siz
 	 * Check Tx msg async API
 	 */
 	if (!unlikely(tx_msg_async_with_size)) {
-		nss_warning("%p: missing Tx msg async API\n", nss_ctx);
+		nss_warning("%px: missing Tx msg async API\n", nss_ctx);
 		return NSS_TX_FAILURE_SYNC_BAD_PARAM;
 	}
 
--- a/nss_unaligned.c
+++ b/nss_unaligned.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -57,12 +57,12 @@ static void nss_unaligned_msg_handler(st
 	 * Sanity checks on message
 	 */
 	if (um->cm.type >= NSS_UNALIGNED_MSG_MAX) {
-		nss_warning("%p: message type out of range: %d\n", nss_ctx, um->cm.type);
+		nss_warning("%px: message type out of range: %d\n", nss_ctx, um->cm.type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(&(um->cm)) > sizeof(struct nss_unaligned_msg)) {
-		nss_warning("%p: message length is invalid: %d\n", nss_ctx, nss_cmn_get_msg_len(&(um->cm)));
+		nss_warning("%px: message length is invalid: %d\n", nss_ctx, nss_cmn_get_msg_len(&(um->cm)));
 		return;
 	}
 
--- a/nss_unaligned_log.c
+++ b/nss_unaligned_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -43,7 +43,7 @@ static void nss_unaligned_log_verbose(st
 		break;
 
 	default:
-		nss_trace("%p: Invalid message type\n", um);
+		nss_trace("%px: Invalid message type\n", um);
 		break;
 	}
 }
@@ -55,18 +55,18 @@ static void nss_unaligned_log_verbose(st
 void nss_unaligned_log_rx_msg(struct nss_unaligned_msg *um)
 {
 	if (um->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", um);
+		nss_warning("%px: Invalid response\n", um);
 		return;
 	}
 
 	if (um->cm.response == NSS_CMN_RESPONSE_NOTIFY || (um->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", um, um->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", um, um->cm.type,
 			nss_unaligned_log_message_types_str[um->cm.type],
 			um->cm.response, nss_cmn_response_str[um->cm.response]);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s\n",
 		um, um->cm.type, nss_unaligned_log_message_types_str[um->cm.type],
 		um->cm.response, nss_cmn_response_str[um->cm.response]);
 
--- a/nss_virt_if.c
+++ b/nss_virt_if.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -77,7 +77,7 @@ static void nss_virt_if_msg_handler(stru
 	 * Sanity check the message type
 	 */
 	if (ncm->type > NSS_VIRT_IF_MAX_MSG_TYPES) {
-		nss_warning("%p: message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
 		return;
 	}
 
@@ -89,7 +89,7 @@ static void nss_virt_if_msg_handler(stru
 	}
 
 	if (!nss_virt_if_verify_if_num(ncm->interface)) {
-		nss_warning("%p: response for another interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: response for another interface: %d", nss_ctx, ncm->interface);
 		return;
 	}
 
@@ -98,7 +98,7 @@ static void nss_virt_if_msg_handler(stru
 	spin_lock_bh(&nss_virt_if_lock);
 	if (!nss_virt_if_handle_t[if_num]) {
 		spin_unlock_bh(&nss_virt_if_lock);
-		nss_warning("%p: virt_if handle is NULL\n", nss_ctx);
+		nss_warning("%px: virt_if handle is NULL\n", nss_ctx);
 		return;
 	}
 
@@ -121,7 +121,7 @@ static void nss_virt_if_msg_handler(stru
 	 * to the same callback/app_data.
 	 */
 	if (ncm->response == NSS_CMN_RESPONSE_NOTIFY) {
-		ncm->cb = (nss_ptr_t)nss_ctx->nss_top->if_rx_msg_callback[ncm->interface];
+		ncm->cb = (nss_ptr_t)nss_core_get_msg_handler(nss_ctx, ncm->interface);
 		ncm->app_data = (nss_ptr_t)nss_ctx->subsys_dp_register[ncm->interface].ndev;
 	}
 
@@ -149,7 +149,7 @@ static void nss_virt_if_callback(void *a
 	struct nss_virt_if_pvt *nvip = handle->pvt;
 
 	if (ncm->response != NSS_CMN_RESPONSE_ACK) {
-		nss_warning("%p: virt_if Error response %d\n", handle->nss_ctx, ncm->response);
+		nss_warning("%px: virt_if Error response %d\n", handle->nss_ctx, ncm->response);
 		nvip->response = NSS_TX_FAILURE;
 		complete(&nvip->complete);
 		return;
@@ -175,7 +175,7 @@ static nss_tx_status_t nss_virt_if_tx_ms
 
 	status = nss_virt_if_tx_msg(nss_ctx, nvim);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: nss_virt_if_msg failed\n", nss_ctx);
+		nss_warning("%px: nss_virt_if_msg failed\n", nss_ctx);
 		up(&nwip->sem);
 		return status;
 	}
@@ -183,7 +183,7 @@ static nss_tx_status_t nss_virt_if_tx_ms
 	ret = wait_for_completion_timeout(&nwip->complete,
 						msecs_to_jiffies(NSS_VIRT_IF_TX_TIMEOUT));
 	if (!ret) {
-		nss_warning("%p: virt_if tx failed due to timeout\n", nss_ctx);
+		nss_warning("%px: virt_if tx failed due to timeout\n", nss_ctx);
 		nwip->response = NSS_TX_FAILURE;
 	}
 
@@ -220,7 +220,7 @@ static int nss_virt_if_handle_destroy_sy
 	int32_t index_h2n;
 
 	if (!nss_virt_if_verify_if_num(if_num_n2h) || !nss_virt_if_verify_if_num(if_num_h2n)) {
-		nss_warning("%p: bad interface numbers %d %d\n", handle->nss_ctx, if_num_n2h, if_num_h2n);
+		nss_warning("%px: bad interface numbers %d %d\n", handle->nss_ctx, if_num_n2h, if_num_h2n);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
@@ -229,13 +229,13 @@ static int nss_virt_if_handle_destroy_sy
 
 	status = nss_dynamic_interface_dealloc_node(if_num_n2h, NSS_DYNAMIC_INTERFACE_TYPE_GENERIC_REDIR_N2H);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: Dynamic interface destroy failed status %d\n", handle->nss_ctx, status);
+		nss_warning("%px: Dynamic interface destroy failed status %d\n", handle->nss_ctx, status);
 		return status;
 	}
 
 	status = nss_dynamic_interface_dealloc_node(if_num_h2n, NSS_DYNAMIC_INTERFACE_TYPE_GENERIC_REDIR_H2N);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: Dynamic interface destroy failed status %d\n", handle->nss_ctx, status);
+		nss_warning("%px: Dynamic interface destroy failed status %d\n", handle->nss_ctx, status);
 		return status;
 	}
 
@@ -261,7 +261,7 @@ static struct nss_virt_if_handle *nss_vi
 	struct nss_virt_if_handle *handle;
 
 	if (!nss_virt_if_verify_if_num(if_num_n2h) || !nss_virt_if_verify_if_num(if_num_h2n)) {
-		nss_warning("%p: bad interface numbers %d %d\n", nss_ctx, if_num_n2h, if_num_h2n);
+		nss_warning("%px: bad interface numbers %d %d\n", nss_ctx, if_num_n2h, if_num_h2n);
 		return NULL;
 	}
 
@@ -271,7 +271,7 @@ static struct nss_virt_if_handle *nss_vi
 	handle = (struct nss_virt_if_handle *)kzalloc(sizeof(struct nss_virt_if_handle),
 									GFP_KERNEL);
 	if (!handle) {
-		nss_warning("%p: handle memory alloc failed\n", nss_ctx);
+		nss_warning("%px: handle memory alloc failed\n", nss_ctx);
 		*cmd_rsp = NSS_VIRT_IF_ALLOC_FAILURE;
 		goto error1;
 	}
@@ -282,7 +282,7 @@ static struct nss_virt_if_handle *nss_vi
 	handle->pvt = (struct nss_virt_if_pvt *)kzalloc(sizeof(struct nss_virt_if_pvt),
 								GFP_KERNEL);
 	if (!handle->pvt) {
-		nss_warning("%p: failure allocating memory for nss_virt_if_pvt\n", nss_ctx);
+		nss_warning("%px: failure allocating memory for nss_virt_if_pvt\n", nss_ctx);
 		*cmd_rsp = NSS_VIRT_IF_ALLOC_FAILURE;
 		goto error2;
 	}
@@ -318,14 +318,14 @@ static uint32_t nss_virt_if_register_han
 
 	ret = nss_core_register_handler(nss_ctx, if_num_n2h, nss_virt_if_msg_handler, NULL);
 	if (ret != NSS_CORE_STATUS_SUCCESS) {
-		nss_warning("%p: Failed to register message handler for redir_n2h interface %d\n", nss_ctx, if_num_n2h);
+		nss_warning("%px: Failed to register message handler for redir_n2h interface %d\n", nss_ctx, if_num_n2h);
 		return NSS_VIRT_IF_CORE_FAILURE;
 	}
 
 	ret = nss_core_register_handler(nss_ctx, if_num_h2n, nss_virt_if_msg_handler, NULL);
 	if (ret != NSS_CORE_STATUS_SUCCESS) {
 		nss_core_unregister_handler(nss_ctx, if_num_n2h);
-		nss_warning("%p: Failed to register message handler for redir_h2n interface %d\n", nss_ctx, if_num_h2n);
+		nss_warning("%px: Failed to register message handler for redir_h2n interface %d\n", nss_ctx, if_num_h2n);
 		return NSS_VIRT_IF_CORE_FAILURE;
 	}
 
@@ -354,26 +354,26 @@ struct nss_virt_if_handle *nss_virt_if_c
 	int32_t if_num_n2h, if_num_h2n;
 
 	if (unlikely(nss_ctx->state != NSS_CORE_STATE_INITIALIZED)) {
-		nss_warning("%p: Interface could not be created as core not ready\n", nss_ctx);
+		nss_warning("%px: Interface could not be created as core not ready\n", nss_ctx);
 		return NULL;
 	}
 
 	if_num_n2h = nss_dynamic_interface_alloc_node(NSS_DYNAMIC_INTERFACE_TYPE_GENERIC_REDIR_N2H);
 	if (if_num_n2h < 0) {
-		nss_warning("%p: failure allocating redir_n2h\n", nss_ctx);
+		nss_warning("%px: failure allocating redir_n2h\n", nss_ctx);
 		return NULL;
 	}
 
 	if_num_h2n = nss_dynamic_interface_alloc_node(NSS_DYNAMIC_INTERFACE_TYPE_GENERIC_REDIR_H2N);
 	if (if_num_h2n < 0) {
-		nss_warning("%p: failure allocating redir_h2n\n", nss_ctx);
+		nss_warning("%px: failure allocating redir_h2n\n", nss_ctx);
 		nss_dynamic_interface_dealloc_node(if_num_n2h, NSS_DYNAMIC_INTERFACE_TYPE_GENERIC_REDIR_N2H);
 		return NULL;
 	}
 
 	handle = nss_virt_if_handle_create_sync(nss_ctx, if_num_n2h, if_num_h2n, &ret);
 	if (!handle) {
-		nss_warning("%p: virt_if handle creation failed ret %d\n", nss_ctx, ret);
+		nss_warning("%px: virt_if handle creation failed ret %d\n", nss_ctx, ret);
 		nss_dynamic_interface_dealloc_node(if_num_n2h, NSS_DYNAMIC_INTERFACE_TYPE_GENERIC_REDIR_N2H);
 		nss_dynamic_interface_dealloc_node(if_num_h2n, NSS_DYNAMIC_INTERFACE_TYPE_GENERIC_REDIR_H2N);
 		return NULL;
@@ -384,7 +384,7 @@ struct nss_virt_if_handle *nss_virt_if_c
 	 */
 	ret = nss_virt_if_register_handler_sync(nss_ctx, handle);
 	if (ret != NSS_VIRT_IF_SUCCESS) {
-		nss_warning("%p: Registration handler failed reason: %d\n", nss_ctx, ret);
+		nss_warning("%px: Registration handler failed reason: %d\n", nss_ctx, ret);
 		goto error1;
 	}
 
@@ -399,7 +399,7 @@ struct nss_virt_if_handle *nss_virt_if_c
 
 	ret = nss_virt_if_tx_msg_sync(handle, &nvim);
 	if (ret != NSS_TX_SUCCESS) {
-		nss_warning("%p: nss_virt_if_tx_msg_sync failed %u\n", nss_ctx, ret);
+		nss_warning("%px: nss_virt_if_tx_msg_sync failed %u\n", nss_ctx, ret);
 		goto error2;
 	}
 
@@ -409,7 +409,7 @@ struct nss_virt_if_handle *nss_virt_if_c
 
 	ret = nss_virt_if_tx_msg_sync(handle, &nvim);
 	if (ret != NSS_TX_SUCCESS) {
-		nss_warning("%p: nss_virt_if_tx_msg_sync failed %u\n", nss_ctx, ret);
+		nss_warning("%px: nss_virt_if_tx_msg_sync failed %u\n", nss_ctx, ret);
 		goto error2;
 	}
 
@@ -483,14 +483,14 @@ nss_tx_status_t nss_virt_if_destroy_sync
 	nss_ctx = handle->nss_ctx;
 
 	if (unlikely(nss_ctx->state != NSS_CORE_STATE_INITIALIZED)) {
-		nss_warning("%p: Interface could not be destroyed as core not ready\n", nss_ctx);
+		nss_warning("%px: Interface could not be destroyed as core not ready\n", nss_ctx);
 		return NSS_TX_FAILURE_NOT_READY;
 	}
 
 	spin_lock_bh(&nss_top_main.lock);
 	if (!nss_ctx->subsys_dp_register[if_num_n2h].ndev || !nss_ctx->subsys_dp_register[if_num_h2n].ndev) {
 		spin_unlock_bh(&nss_top_main.lock);
-		nss_warning("%p: Unregister virt interface %d %d: no context\n", nss_ctx, if_num_n2h, if_num_h2n);
+		nss_warning("%px: Unregister virt interface %d %d: no context\n", nss_ctx, if_num_n2h, if_num_h2n);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
@@ -503,19 +503,19 @@ nss_tx_status_t nss_virt_if_destroy_sync
 
 	status = nss_virt_if_handle_destroy_sync(handle);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: handle destroy failed for if_num_n2h %d and if_num_h2n %d\n", nss_ctx, if_num_n2h, if_num_h2n);
+		nss_warning("%px: handle destroy failed for if_num_n2h %d and if_num_h2n %d\n", nss_ctx, if_num_n2h, if_num_h2n);
 		return NSS_TX_FAILURE;
 	}
 
 	ret = nss_core_unregister_handler(nss_ctx, if_num_n2h);
 	if (ret != NSS_CORE_STATUS_SUCCESS) {
-		nss_warning("%p: Not able to unregister handler for redir_n2h interface %d with NSS core\n", nss_ctx, if_num_n2h);
+		nss_warning("%px: Not able to unregister handler for redir_n2h interface %d with NSS core\n", nss_ctx, if_num_n2h);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
 	ret = nss_core_unregister_handler(nss_ctx, if_num_h2n);
 	if (ret != NSS_CORE_STATUS_SUCCESS) {
-		nss_warning("%p: Not able to unregister handler for redir_h2n interface %d with NSS core\n", nss_ctx, if_num_h2n);
+		nss_warning("%px: Not able to unregister handler for redir_h2n interface %d with NSS core\n", nss_ctx, if_num_h2n);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
@@ -543,17 +543,17 @@ nss_tx_status_t nss_virt_if_tx_buf(struc
 	}
 
 	if (!nss_virt_if_verify_if_num(if_num)) {
-		nss_warning("%p: bad interface number %d\n", nss_ctx, if_num);
+		nss_warning("%px: bad interface number %d\n", nss_ctx, if_num);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
-	nss_trace("%p: Virtual Rx packet, if_num:%d, skb:%p", nss_ctx, if_num, skb);
+	nss_trace("%px: Virtual Rx packet, if_num:%d, skb:%px", nss_ctx, if_num, skb);
 
 	/*
 	 * Sanity check the SKB to ensure that it's suitable for us
 	 */
 	if (unlikely(skb->len <= ETH_HLEN)) {
-		nss_warning("%p: Virtual Rx packet: %p too short", nss_ctx, skb);
+		nss_warning("%px: Virtual Rx packet: %px too short", nss_ctx, skb);
 		return NSS_TX_FAILURE_TOO_SHORT;
 	}
 
@@ -564,7 +564,8 @@ nss_tx_status_t nss_virt_if_tx_buf(struc
 	put_cpu();
 	skb_set_queue_mapping(skb, cpu);
 
-	return nss_core_send_packet(nss_ctx, skb, if_num, H2N_BIT_FLAG_VIRTUAL_BUFFER);
+	return nss_core_send_packet(nss_ctx, skb, if_num, H2N_BIT_FLAG_VIRTUAL_BUFFER |
+                                                        H2N_BIT_FLAG_BUFFER_REUSABLE);
 }
 EXPORT_SYMBOL(nss_virt_if_tx_buf);
 
@@ -579,12 +580,12 @@ nss_tx_status_t nss_virt_if_tx_msg(struc
 	 * Sanity check the message
 	 */
 	if (!nss_virt_if_verify_if_num(ncm->interface)) {
-		nss_warning("%p: tx request for another interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: tx request for another interface: %d", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
 	if (ncm->type > NSS_VIRT_IF_MAX_MSG_TYPES) {
-		nss_warning("%p: message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
@@ -656,6 +657,7 @@ void nss_virt_if_register(struct nss_vir
 {
 	struct nss_ctx_instance *nss_ctx;
 	int32_t if_num;
+	uint32_t status;
 
 	if (!handle) {
 		nss_warning("handle is NULL\n");
@@ -673,7 +675,11 @@ void nss_virt_if_register(struct nss_vir
 	if_num = handle->if_num_n2h;
 
 	nss_core_register_subsys_dp(nss_ctx, if_num, data_callback, NULL, NULL, netdev, (uint32_t)netdev->features);
-	nss_top_main.if_rx_msg_callback[if_num] = NULL;
+	status = nss_core_unregister_msg_handler(nss_ctx, if_num);
+	if (status != NSS_CORE_STATUS_SUCCESS) {
+		nss_warning("%px: unable to unregister event handler for interface(%u)", nss_ctx, if_num);
+		return;
+	}
 }
 EXPORT_SYMBOL(nss_virt_if_register);
 
@@ -684,6 +690,7 @@ void nss_virt_if_unregister(struct nss_v
 {
 	struct nss_ctx_instance *nss_ctx;
 	int32_t if_num;
+	uint32_t status;
 
 	if (!handle) {
 		nss_warning("handle is NULL\n");
@@ -702,7 +709,11 @@ void nss_virt_if_unregister(struct nss_v
 
 	nss_core_unregister_subsys_dp(nss_ctx, if_num);
 
-	nss_top_main.if_rx_msg_callback[if_num] = NULL;
+	status = nss_core_unregister_msg_handler(nss_ctx, if_num);
+	if (status != NSS_CORE_STATUS_SUCCESS) {
+		nss_warning("%px: unable to unregister event handler for interface(%u)", nss_ctx, if_num);
+		return;
+	}
 }
 EXPORT_SYMBOL(nss_virt_if_unregister);
 
--- a/nss_vlan.c
+++ b/nss_vlan.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -76,12 +76,12 @@ static void nss_vlan_handler(struct nss_
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >= NSS_VLAN_MSG_TYPE_MAX) {
-		nss_warning("%p: received invalid message %d for vlan interface", nss_ctx, ncm->type);
+		nss_warning("%px: received invalid message %d for vlan interface", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_vlan_msg)) {
-		nss_warning("%p: length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
@@ -154,12 +154,12 @@ nss_tx_status_t nss_vlan_tx_msg(struct n
 	 * Sanity check the message
 	 */
 	if (!nss_vlan_verify_if_num(ncm->interface)) {
-		nss_warning("%p: tx request for interface that is not a vlan: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: tx request for interface that is not a vlan: %d", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
 	if (ncm->type >= NSS_VLAN_MSG_TYPE_MAX) {
-		nss_warning("%p: message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
@@ -185,14 +185,14 @@ nss_tx_status_t nss_vlan_tx_msg_sync(str
 
 	status = nss_vlan_tx_msg(nss_ctx, nvm);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: vlan_tx_msg failed\n", nss_ctx);
+		nss_warning("%px: vlan_tx_msg failed\n", nss_ctx);
 		up(&vlan_pvt.sem);
 		return status;
 	}
 
 	ret = wait_for_completion_timeout(&vlan_pvt.complete, msecs_to_jiffies(NSS_VLAN_TX_TIMEOUT));
 	if (!ret) {
-		nss_warning("%p: vlan msg tx failed due to timeout\n", nss_ctx);
+		nss_warning("%px: vlan msg tx failed due to timeout\n", nss_ctx);
 		vlan_pvt.response = NSS_TX_FAILURE;
 	}
 
@@ -228,7 +228,7 @@ nss_tx_status_t nss_vlan_tx_set_mtu_msg(
 	}
 
 	if (nss_vlan_verify_if_num(vlan_if_num) == false) {
-		nss_warning("%p: received invalid interface %d", nss_ctx, vlan_if_num);
+		nss_warning("%px: received invalid interface %d", nss_ctx, vlan_if_num);
 		return NSS_TX_FAILURE;
 	}
 
@@ -258,7 +258,7 @@ nss_tx_status_t nss_vlan_tx_set_mac_addr
 	}
 
 	if (nss_vlan_verify_if_num(vlan_if_num) == false) {
-		nss_warning("%p: received invalid interface %d", nss_ctx, vlan_if_num);
+		nss_warning("%px: received invalid interface %d", nss_ctx, vlan_if_num);
 		return NSS_TX_FAILURE;
 	}
 
@@ -286,7 +286,7 @@ nss_tx_status_t nss_vlan_tx_vsi_attach_m
 	}
 
 	if (nss_vlan_verify_if_num(vlan_if_num) == false) {
-		nss_warning("%p: received invalid interface %d\n", nss_ctx, vlan_if_num);
+		nss_warning("%px: received invalid interface %d\n", nss_ctx, vlan_if_num);
 		return NSS_TX_FAILURE;
 	}
 
@@ -313,7 +313,7 @@ nss_tx_status_t nss_vlan_tx_vsi_detach_m
 	}
 
 	if (nss_vlan_verify_if_num(vlan_if_num) == false) {
-		nss_warning("%p: received invalid interface %d\n", nss_ctx, vlan_if_num);
+		nss_warning("%px: received invalid interface %d\n", nss_ctx, vlan_if_num);
 		return NSS_TX_FAILURE;
 	}
 
@@ -340,7 +340,7 @@ nss_tx_status_t nss_vlan_tx_add_tag_msg(
 	}
 
 	if (nss_vlan_verify_if_num(vlan_if_num) == false) {
-		nss_warning("%p: received invalid interface %d\n", nss_ctx, vlan_if_num);
+		nss_warning("%px: received invalid interface %d\n", nss_ctx, vlan_if_num);
 		return NSS_TX_FAILURE;
 	}
 
--- a/nss_vlan_log.c
+++ b/nss_vlan_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -44,7 +44,7 @@ static int8_t *nss_vlan_log_error_respon
 static void nss_vlan_log_add_tag_msg(struct nss_vlan_msg *nvm)
 {
 	struct nss_vlan_msg_add_tag *nvtm __maybe_unused = &nvm->msg.add_tag;
-	nss_trace("%p: NSS VLAN Add Tag Message:\n"
+	nss_trace("%px: NSS VLAN Add Tag Message:\n"
 		"VLAN Tag: %d\n"
 		"VLAN Next Hop: %d\n"
 		"VLAN Interface Number: %d\n",
@@ -64,7 +64,7 @@ static void nss_vlan_log_verbose(struct
 		break;
 
 	default:
-		nss_warning("%p: Invalid message type\n", nvm);
+		nss_warning("%px: Invalid message type\n", nvm);
 		break;
 	}
 }
@@ -76,11 +76,11 @@ static void nss_vlan_log_verbose(struct
 void nss_vlan_log_tx_msg(struct nss_vlan_msg *nvm)
 {
 	if (nvm->cm.type >= NSS_VLAN_MSG_TYPE_MAX) {
-		nss_warning("%p: Invalid message type\n", nvm);
+		nss_warning("%px: Invalid message type\n", nvm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", nvm, nvm->cm.type, nss_vlan_log_message_types_str[nvm->cm.type]);
+	nss_info("%px: type[%d]:%s\n", nvm, nvm->cm.type, nss_vlan_log_message_types_str[nvm->cm.type]);
 	nss_vlan_log_verbose(nvm);
 }
 
@@ -91,26 +91,26 @@ void nss_vlan_log_tx_msg(struct nss_vlan
 void nss_vlan_log_rx_msg(struct nss_vlan_msg *nvm)
 {
 	if (nvm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", nvm);
+		nss_warning("%px: Invalid response\n", nvm);
 		return;
 	}
 
 	if (nvm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (nvm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", nvm, nvm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", nvm, nvm->cm.type,
 			nss_vlan_log_message_types_str[nvm->cm.type],
 			nvm->cm.response, nss_cmn_response_str[nvm->cm.response]);
 		goto verbose;
 	}
 
 	if (nvm->cm.error >= NSS_VLAN_ERROR_TYPE_MAX) {
-		nss_warning("%p: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
+		nss_warning("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
 			nvm, nvm->cm.type, nss_vlan_log_message_types_str[nvm->cm.type],
 			nvm->cm.response, nss_cmn_response_str[nvm->cm.response],
 			nvm->cm.error);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
 		nvm, nvm->cm.type, nss_vlan_log_message_types_str[nvm->cm.type],
 		nvm->cm.response, nss_cmn_response_str[nvm->cm.response],
 		nvm->cm.error, nss_vlan_log_error_response_types_str[nvm->cm.error]);
--- a/nss_vxlan.c
+++ b/nss_vxlan.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -95,12 +95,12 @@ static void nss_vxlan_msg_handler(struct
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >= NSS_VXLAN_MSG_TYPE_MAX) {
-		nss_warning("%p: received invalid message %d for vxlan interface", nss_ctx, ncm->type);
+		nss_warning("%px: received invalid message %d for vxlan interface", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_vxlan_msg)) {
-		nss_warning("%p: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
@@ -122,7 +122,7 @@ static void nss_vxlan_msg_handler(struct
 	 * Update the callback for NOTIFY messages
 	 */
 	if (ncm->response == NSS_CMN_RESPONSE_NOTIFY) {
-		ncm->cb = (nss_ptr_t)nss_ctx->nss_top->if_rx_msg_callback[ncm->interface];
+		ncm->cb = (nss_ptr_t)nss_core_get_msg_handler(nss_ctx, ncm->interface);
 	}
 
 	cb = (nss_vxlan_msg_callback_t)ncm->cb;
@@ -131,7 +131,7 @@ static void nss_vxlan_msg_handler(struct
 	 * Do we have a callback?
 	 */
 	if (!cb) {
-		nss_trace("%p: cb is null for interface %d\n", nss_ctx, ncm->interface);
+		nss_trace("%px: cb is null for interface %d\n", nss_ctx, ncm->interface);
 		return;
 	}
 
@@ -147,12 +147,12 @@ nss_tx_status_t nss_vxlan_tx_msg(struct
 	struct nss_cmn_msg *ncm = &nvm->cm;
 
 	if (!nss_vxlan_verify_if_num(ncm->interface)) {
-		nss_warning("%p: wrong interface number %u\n", nss_ctx, nvm->cm.interface);
+		nss_warning("%px: wrong interface number %u\n", nss_ctx, nvm->cm.interface);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
 	if (ncm->type >= NSS_VXLAN_MSG_TYPE_MAX) {
-		nss_warning("%p: wrong message type %u\n", nss_ctx, ncm->type);
+		nss_warning("%px: wrong message type %u\n", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
@@ -183,14 +183,14 @@ nss_tx_status_t nss_vxlan_tx_msg_sync(st
 
 	status = nss_vxlan_tx_msg(nss_ctx, nvm);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: vxlan_tx_msg failed\n", nss_ctx);
+		nss_warning("%px: vxlan_tx_msg failed\n", nss_ctx);
 		up(&nss_vxlan_pvt.sem);
 		return status;
 	}
 
 	ret = wait_for_completion_timeout(&nss_vxlan_pvt.complete, msecs_to_jiffies(NSS_VXLAN_TX_TIMEOUT));
 	if (!ret) {
-		nss_warning("%p: vxlan tx sync failed due to timeout\n", nss_ctx);
+		nss_warning("%px: vxlan tx sync failed due to timeout\n", nss_ctx);
 		nss_vxlan_pvt.response = NSS_TX_FAILURE;
 	}
 
@@ -221,7 +221,7 @@ bool nss_vxlan_unregister_if(uint32_t if
 
 	nss_ctx = nss_vxlan_get_ctx();
 	if (!nss_vxlan_verify_if_num(if_num)) {
-		nss_warning("%p: data unregister received for invalid interface %d", nss_ctx, if_num);
+		nss_warning("%px: data unregister received for invalid interface %d", nss_ctx, if_num);
 		return false;
 	}
 
@@ -247,19 +247,25 @@ struct nss_ctx_instance *nss_vxlan_regis
 
 	nss_ctx = nss_vxlan_get_ctx();
 	if (!nss_vxlan_verify_if_num(if_num)) {
-		nss_warning("%p: data register received for invalid interface %d", nss_ctx, if_num);
+		nss_warning("%px: data register received for invalid interface %d", nss_ctx, if_num);
 		return NULL;
 	}
 
 	core_status = nss_core_register_handler(nss_ctx, if_num, nss_vxlan_msg_handler, NULL);
 	if (core_status != NSS_CORE_STATUS_SUCCESS) {
-		nss_warning("%p: nss core register handler failed for if_num:%d with error :%d", nss_ctx, if_num, core_status);
+		nss_warning("%px: nss core register handler failed for if_num:%d with error :%d", nss_ctx, if_num, core_status);
+		return NULL;
+	}
+
+	core_status = nss_core_register_msg_handler(nss_ctx, if_num, notify_cb);
+	if (core_status != NSS_CORE_STATUS_SUCCESS) {
+		nss_core_unregister_handler(nss_ctx, if_num);
+		nss_warning("%px: nss core register handler failed for if_num:%d with error :%d", nss_ctx, if_num, core_status);
 		return NULL;
 	}
 
 	nss_core_register_subsys_dp(nss_ctx, if_num, data_cb, NULL, NULL, netdev, features);
 	nss_core_set_subsys_dp_type(nss_ctx, netdev, if_num, type);
-	nss_top_main.if_rx_msg_callback[if_num] = (nss_if_rx_msg_callback_t)notify_cb;
 	return nss_ctx;
 }
 EXPORT_SYMBOL(nss_vxlan_register_if);
@@ -275,7 +281,7 @@ int nss_vxlan_ifnum_with_core_id(int if_
 	NSS_VERIFY_CTX_MAGIC(nss_ctx);
 
 	if (!nss_vxlan_verify_if_num(if_num)) {
-		nss_warning("%p: Invalid if_num: %d, must be a dynamic interface\n", nss_ctx, if_num);
+		nss_warning("%px: Invalid if_num: %d, must be a dynamic interface\n", nss_ctx, if_num);
 		return 0;
 	}
 	return NSS_INTERFACE_NUM_APPEND_COREID(nss_ctx, if_num);
@@ -304,7 +310,7 @@ void nss_vxlan_init()
 	uint32_t core_status;
 	struct nss_ctx_instance *nss_ctx = nss_vxlan_get_ctx();
 	if (!nss_ctx) {
-		nss_warning("%p: VxLAN is not registered", nss_ctx);
+		nss_warning("%px: VxLAN is not registered", nss_ctx);
 		return;
 	}
 
@@ -314,7 +320,7 @@ void nss_vxlan_init()
 	core_status = nss_core_register_handler(nss_ctx, NSS_VXLAN_INTERFACE, nss_vxlan_msg_handler, NULL);
 
 	if (core_status != NSS_CORE_STATUS_SUCCESS) {
-		nss_warning("%p: nss core register handler failed for if_num:%d with error :%d", nss_ctx, NSS_VXLAN_INTERFACE, core_status);
+		nss_warning("%px: nss core register handler failed for if_num:%d with error :%d", nss_ctx, NSS_VXLAN_INTERFACE, core_status);
 	}
 
 }
--- a/nss_vxlan_log.c
+++ b/nss_vxlan_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -70,7 +70,7 @@ static int8_t *nss_vxlan_log_error_respo
  */
 static void nss_vxlan_log_rule_msg(struct nss_vxlan_rule_msg *nvrm)
 {
-	nss_trace("%p: NSS VXLAN Rule message \n"
+	nss_trace("%px: NSS VXLAN Rule message \n"
 		"VxLAN Tunnel Flags: %x\n"
 		"VNET ID: %u\n"
 		"Flowlabel: %u\n"
@@ -95,9 +95,9 @@ static void nss_vxlan_log_rule_msg(struc
  */
 static void nss_vxlan_log_mac_msg(struct nss_vxlan_mac_msg *nvmm)
 {
-	nss_trace("%p: NSS VXLAN MAC message \n"
-		"Encap Rule Src IP: %p\n"
-		"Encap Rule Dst Ip: %p\n"
+	nss_trace("%px: NSS VXLAN MAC message \n"
+		"Encap Rule Src IP: %px\n"
+		"Encap Rule Dst Ip: %px\n"
 		"Vxlan VNet ID: %u\n"
 		"Vxlan Mac Addr: %pM",
 		nvmm,
@@ -133,7 +133,7 @@ static void nss_vxlan_log_rule_destroy_m
  */
 static void nss_vxlan_log_enable_msg(struct nss_vxlan_msg *nvm)
 {
-	nss_trace("%p: NSS VXLAN Tunnel state message: Enable \n", nvm);
+	nss_trace("%px: NSS VXLAN Tunnel state message: Enable \n", nvm);
 }
 
 /*
@@ -142,7 +142,7 @@ static void nss_vxlan_log_enable_msg(str
  */
 static void nss_vxlan_log_disable_msg(struct nss_vxlan_msg *nvm)
 {
-	nss_trace("%p: NSS VXLAN Tunnel state message: Disable \n", nvm);
+	nss_trace("%px: NSS VXLAN Tunnel state message: Disable \n", nvm);
 }
 
 /*
@@ -201,7 +201,7 @@ static void nss_vxlan_log_verbose(struct
 		break;
 
 	default:
-		nss_trace("%p: Invalid message type\n", nvm);
+		nss_trace("%px: Invalid message type\n", nvm);
 		break;
 	}
 }
@@ -213,11 +213,11 @@ static void nss_vxlan_log_verbose(struct
 void nss_vxlan_log_tx_msg(struct nss_vxlan_msg *nvm)
 {
 	if (nvm->cm.type >= NSS_VXLAN_MSG_TYPE_MAX) {
-		nss_warning("%p: Invalid message type\n", nvm);
+		nss_warning("%px: Invalid message type\n", nvm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", nvm, nvm->cm.type, nss_vxlan_log_message_types_str[nvm->cm.type]);
+	nss_info("%px: type[%d]:%s\n", nvm, nvm->cm.type, nss_vxlan_log_message_types_str[nvm->cm.type]);
 	nss_vxlan_log_verbose(nvm);
 }
 
@@ -228,26 +228,26 @@ void nss_vxlan_log_tx_msg(struct nss_vxl
 void nss_vxlan_log_rx_msg(struct nss_vxlan_msg *nvm)
 {
 	if (nvm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", nvm);
+		nss_warning("%px: Invalid response\n", nvm);
 		return;
 	}
 
 	if (nvm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (nvm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", nvm, nvm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", nvm, nvm->cm.type,
 			nss_vxlan_log_message_types_str[nvm->cm.type],
 			nvm->cm.response, nss_cmn_response_str[nvm->cm.response]);
 		goto verbose;
 	}
 
 	if (nvm->cm.error >= NSS_VXLAN_ERROR_TYPE_MAX) {
-		nss_warning("%p: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
+		nss_warning("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
 			nvm, nvm->cm.type, nss_vxlan_log_message_types_str[nvm->cm.type],
 			nvm->cm.response, nss_cmn_response_str[nvm->cm.response],
 			nvm->cm.error);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
 		nvm, nvm->cm.type, nss_vxlan_log_message_types_str[nvm->cm.type],
 		nvm->cm.response, nss_cmn_response_str[nvm->cm.response],
 		nvm->cm.error, nss_vxlan_log_error_response_types_str[nvm->cm.error]);
--- a/nss_wifi.c
+++ b/nss_wifi.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2015-2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2015-2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -37,7 +37,7 @@ static void nss_wifi_handler(struct nss_
 	void *ctx;
 	nss_wifi_msg_callback_t cb;
 
-	nss_info("%p: NSS ->HLOS message for wifi\n", nss_ctx);
+	nss_info("%px: NSS ->HLOS message for wifi\n", nss_ctx);
 
 	BUG_ON(((ncm->interface < NSS_WIFI_INTERFACE0) || (ncm->interface > NSS_WIFI_INTERFACE2)));
 
@@ -50,12 +50,12 @@ static void nss_wifi_handler(struct nss_
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >= NSS_WIFI_MAX_MSG) {
-		nss_warning("%p: received invalid message %d for wifi interface", nss_ctx, ncm->type);
+		nss_warning("%px: received invalid message %d for wifi interface", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_wifi_msg)) {
-		nss_warning("%p: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
@@ -88,7 +88,7 @@ static void nss_wifi_handler(struct nss_
 	 * Do we have a call back
 	 */
 	if (!ncm->cb) {
-		nss_info("%p: cb null for wifi interface %d", nss_ctx, ncm->interface);
+		nss_info("%px: cb null for wifi interface %d", nss_ctx, ncm->interface);
 		return;
 	}
 
@@ -102,7 +102,7 @@ static void nss_wifi_handler(struct nss_
 	 * call wifi msg callback
 	 */
 	if (!ctx) {
-		nss_warning("%p: Event received for wifi interface %d before registration", nss_ctx, ncm->interface);
+		nss_warning("%px: Event received for wifi interface %d before registration", nss_ctx, ncm->interface);
 		return;
 	}
 
@@ -123,7 +123,7 @@ nss_tx_status_t nss_wifi_tx_msg(struct n
 	nss_wifi_log_tx_msg(msg);
 
 	if (ncm->type > NSS_WIFI_MAX_MSG) {
-		nss_warning("%p: wifi message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: wifi message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
@@ -149,7 +149,7 @@ struct nss_ctx_instance *nss_register_wi
 	nss_assert(nss_ctx);
 	nss_assert((if_num >= NSS_MAX_VIRTUAL_INTERFACES) && (if_num < NSS_MAX_NET_INTERFACES));
 
-	nss_info("%p: nss_register_wifi_if if_num %d wifictx %p", nss_ctx, if_num, netdev);
+	nss_info("%px: nss_register_wifi_if if_num %d wifictx %px", nss_ctx, if_num, netdev);
 
 	nss_core_register_subsys_dp(nss_ctx, if_num, wifi_callback, wifi_ext_callback, NULL, netdev, features);
 
--- a/nss_wifi_if.c
+++ b/nss_wifi_if.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2015-2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2015-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -56,18 +56,18 @@ static void nss_wifi_if_msg_handler(stru
 	 * Sanity check the message type
 	 */
 	if (ncm->type >= NSS_WIFI_IF_MAX_MSG_TYPES) {
-		nss_warning("%p: message type out of range: %d",
+		nss_warning("%px: message type out of range: %d",
 						nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_wifi_if_msg)) {
-		nss_warning("%p: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
 	if (!NSS_IS_IF_TYPE(DYNAMIC, ncm->interface)) {
-		nss_warning("%p: response for another interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: response for another interface: %d", nss_ctx, ncm->interface);
 		return;
 	}
 
@@ -81,7 +81,7 @@ static void nss_wifi_if_msg_handler(stru
 	spin_lock_bh(&wifi_if_lock);
 	if (!wifi_handle[if_num]) {
 		spin_unlock_bh(&wifi_if_lock);
-		nss_warning("%p: wifi_if handle is NULL\n", nss_ctx);
+		nss_warning("%px: wifi_if handle is NULL\n", nss_ctx);
 		return;
 	}
 
@@ -156,7 +156,7 @@ static void nss_wifi_if_callback(void *a
 	struct nss_wifi_if_pvt *nwip = handle->pvt;
 
 	if (ncm->response != NSS_CMN_RESPONSE_ACK) {
-		nss_warning("%p: wifi_if Error response %d\n",
+		nss_warning("%px: wifi_if Error response %d\n",
 						handle->nss_ctx, ncm->response);
 		nwip->response = NSS_TX_FAILURE;
 		complete(&nwip->complete);
@@ -176,7 +176,7 @@ nss_tx_status_t nss_wifi_if_tx_msg(struc
 	struct nss_cmn_msg *ncm = &nwim->cm;
 
 	if (ncm->type > NSS_WIFI_IF_MAX_MSG_TYPES) {
-		nss_warning("%p: message type out of range: %d\n", nss_ctx, ncm->type);
+		nss_warning("%px: message type out of range: %d\n", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
@@ -199,7 +199,7 @@ static nss_tx_status_t nss_wifi_if_tx_ms
 
 	status = nss_wifi_if_tx_msg(nss_ctx, nwim);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: nss_wifi_if_msg failed\n", nss_ctx);
+		nss_warning("%px: nss_wifi_if_msg failed\n", nss_ctx);
 		up(&nwip->sem);
 		return status;
 	}
@@ -207,7 +207,7 @@ static nss_tx_status_t nss_wifi_if_tx_ms
 	ret = wait_for_completion_timeout(&nwip->complete,
 						msecs_to_jiffies(NSS_WIFI_IF_TX_TIMEOUT));
 	if (!ret) {
-		nss_warning("%p: wifi_if tx failed due to timeout\n", nss_ctx);
+		nss_warning("%px: wifi_if tx failed due to timeout\n", nss_ctx);
 		nwip->response = NSS_TX_FAILURE;
 	}
 
@@ -243,7 +243,7 @@ static int nss_wifi_if_handle_destroy(st
 
 	status = nss_dynamic_interface_dealloc_node(if_num, NSS_DYNAMIC_INTERFACE_TYPE_WIFI);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: Dynamic interface destroy failed status %d\n", nss_ctx, status);
+		nss_warning("%px: Dynamic interface destroy failed status %d\n", nss_ctx, status);
 		return status;
 	}
 
@@ -266,7 +266,7 @@ static struct nss_wifi_if_handle *nss_wi
 
 	if_num = nss_dynamic_interface_alloc_node(NSS_DYNAMIC_INTERFACE_TYPE_WIFI);
 	if (if_num < 0) {
-		nss_warning("%p:failure allocating wifi if\n", nss_ctx);
+		nss_warning("%px:failure allocating wifi if\n", nss_ctx);
 		*cmd_rsp = NSS_WIFI_IF_DYNAMIC_IF_FAILURE;
 		return NULL;
 	}
@@ -276,7 +276,7 @@ static struct nss_wifi_if_handle *nss_wi
 	handle = (struct nss_wifi_if_handle *)kzalloc(sizeof(struct nss_wifi_if_handle),
 									GFP_KERNEL);
 	if (!handle) {
-		nss_warning("%p: handle memory alloc failed\n", nss_ctx);
+		nss_warning("%px: handle memory alloc failed\n", nss_ctx);
 		*cmd_rsp = NSS_WIFI_IF_ALLOC_FAILURE;
 		goto error1;
 	}
@@ -286,7 +286,7 @@ static struct nss_wifi_if_handle *nss_wi
 	handle->pvt = (struct nss_wifi_if_pvt *)kzalloc(sizeof(struct nss_wifi_if_pvt),
 								GFP_KERNEL);
 	if (!handle->pvt) {
-		nss_warning("%p: failure allocating memory for nss_wifi_if_pvt\n", nss_ctx);
+		nss_warning("%px: failure allocating memory for nss_wifi_if_pvt\n", nss_ctx);
 		*cmd_rsp = NSS_WIFI_IF_ALLOC_FAILURE;
 		goto error2;
 	}
@@ -335,20 +335,20 @@ struct nss_wifi_if_handle *nss_wifi_if_c
 	struct nss_wifi_if_handle *handle = NULL;
 
 	if (unlikely(nss_ctx->state != NSS_CORE_STATE_INITIALIZED)) {
-		nss_warning("%p: Interface could not be created as core not ready\n", nss_ctx);
+		nss_warning("%px: Interface could not be created as core not ready\n", nss_ctx);
 		return NULL;
 	}
 
 	handle = nss_wifi_if_handle_create(nss_ctx, &ret);
 	if (!handle) {
-		nss_warning("%p:wifi_if handle creation failed ret %d\n", nss_ctx, ret);
+		nss_warning("%px:wifi_if handle creation failed ret %d\n", nss_ctx, ret);
 		return NULL;
 	}
 
 	/* Initializes the semaphore and also sets the msg handler for if_num */
 	ret = nss_wifi_if_register_handler(handle);
 	if (ret != NSS_WIFI_IF_SUCCESS) {
-		nss_warning("%p: Registration handler failed reason: %d\n", nss_ctx, ret);
+		nss_warning("%px: Registration handler failed reason: %d\n", nss_ctx, ret);
 		goto error;
 	}
 
@@ -361,7 +361,7 @@ struct nss_wifi_if_handle *nss_wifi_if_c
 
 	ret = nss_wifi_if_tx_msg_sync(handle, &nwim);
 	if (ret != NSS_TX_SUCCESS) {
-		nss_warning("%p: nss_wifi_if_tx_msg_sync failed %u\n", nss_ctx, ret);
+		nss_warning("%px: nss_wifi_if_tx_msg_sync failed %u\n", nss_ctx, ret);
 		goto error;
 	}
 
@@ -397,14 +397,14 @@ nss_tx_status_t nss_wifi_if_destroy_sync
 	struct nss_ctx_instance *nss_ctx = handle->nss_ctx;
 
 	if (unlikely(nss_ctx->state != NSS_CORE_STATE_INITIALIZED)) {
-		nss_warning("%p: Interface could not be destroyed as core not ready\n", nss_ctx);
+		nss_warning("%px: Interface could not be destroyed as core not ready\n", nss_ctx);
 		return NSS_TX_FAILURE_NOT_READY;
 	}
 
 	spin_lock_bh(&nss_top_main.lock);
 	if (!nss_ctx->subsys_dp_register[if_num].ndev) {
 		spin_unlock_bh(&nss_top_main.lock);
-		nss_warning("%p: Unregister wifi interface %d: no context\n", nss_ctx, if_num);
+		nss_warning("%px: Unregister wifi interface %d: no context\n", nss_ctx, if_num);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
@@ -500,7 +500,7 @@ nss_tx_status_t nss_wifi_if_tx_buf(struc
 	 * Sanity check the SKB to ensure that it's suitable for us
 	 */
 	if (unlikely(skb->len <= ETH_HLEN)) {
-		nss_warning("%p: Rx packet: %p too short", nss_ctx, skb);
+		nss_warning("%px: Rx packet: %px too short", nss_ctx, skb);
 		return NSS_TX_FAILURE_TOO_SHORT;
 	}
 
@@ -514,4 +514,3 @@ nss_tx_status_t nss_wifi_if_tx_buf(struc
 	return nss_core_send_packet(nss_ctx, skb, if_num, H2N_BIT_FLAG_VIRTUAL_BUFFER);
 }
 EXPORT_SYMBOL(nss_wifi_if_tx_buf);
-
--- a/nss_wifi_log.c
+++ b/nss_wifi_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -110,7 +110,7 @@ static void nss_wifi_log_init_msg(struct
 {
 	struct nss_wifi_init_msg *nwim __maybe_unused = &ncm->msg.initmsg;
 
-	nss_trace("%p: NSS WIFI Init Message:\n"
+	nss_trace("%px: NSS WIFI Init Message:\n"
 		"WIFI Radio ID: %d\n"
 		"WIFI PCI Memory Address: %x\n"
 		"WIFI Target Type: %d\n"
@@ -177,7 +177,7 @@ static void nss_wifi_log_init_msg(struct
 static void nss_wifi_log_stop_msg(struct nss_wifi_msg *ncm)
 {
 	struct nss_wifi_stop_msg *nwsm __maybe_unused = &ncm->msg.stopmsg;
-	nss_trace("%p: NSS WIFI Init Message:\n"
+	nss_trace("%px: NSS WIFI Init Message:\n"
 		"WIFI Radio ID: %d\n",
 		nwsm, nwsm->radio_id);
 }
@@ -189,7 +189,7 @@ static void nss_wifi_log_stop_msg(struct
 static void nss_wifi_log_reset_msg(struct nss_wifi_msg *ncm)
 {
 	struct nss_wifi_reset_msg *nwrm __maybe_unused = &ncm->msg.resetmsg;
-	nss_trace("%p: NSS WIFI Init Message:\n"
+	nss_trace("%px: NSS WIFI Init Message:\n"
 		"WIFI Radio ID: %d\n",
 		nwrm, nwrm->radio_id);
 }
@@ -201,7 +201,7 @@ static void nss_wifi_log_reset_msg(struc
 static void nss_wifi_log_htt_init_msg(struct nss_wifi_msg *ncm)
 {
 	struct nss_wifi_htt_init_msg *nwim __maybe_unused = &ncm->msg.httinitmsg;
-	nss_trace("%p: NSS WIFI HTT Init Message:\n"
+	nss_trace("%px: NSS WIFI HTT Init Message:\n"
 		"WIFI Radio ID: %d\n"
 		"WIFI Ring Size: %d\n"
 		"WIFI Fill Level: %d\n"
@@ -222,7 +222,7 @@ static void nss_wifi_log_htt_init_msg(st
 static void nss_wifi_log_tx_init_msg(struct nss_wifi_msg *ncm)
 {
 	struct nss_wifi_tx_init_msg *nwim __maybe_unused = &ncm->msg.pdevtxinitmsg;
-	nss_trace("%p: NSS WIFI HTT Init Message:\n"
+	nss_trace("%px: NSS WIFI HTT Init Message:\n"
 		"WIFI Radio ID: %d\n"
 		"WIFI Number of Descriptor Pools Allocated: %d\n"
 		"WIFI TX Descriptor Array: %x\n"
@@ -246,10 +246,10 @@ static void nss_wifi_log_tx_init_msg(str
 static void nss_wifi_log_rawsend_msg(struct nss_wifi_msg *ncm)
 {
 	struct nss_wifi_rawsend_msg *nwrm __maybe_unused = &ncm->msg.rawmsg;
-	nss_trace("%p: NSS WIFI RAW Send Message:\n"
+	nss_trace("%px: NSS WIFI RAW Send Message:\n"
 		"WIFI Radio ID: %d\n"
 		"WIFI Size of Raw Data: %d\n"
-		"WIFI Raw Data: %p",
+		"WIFI Raw Data: %px",
 		nwrm, nwrm->radio_id,
 		nwrm->len, nwrm->array);
 }
@@ -261,10 +261,10 @@ static void nss_wifi_log_rawsend_msg(str
 static void nss_wifi_log_mgmtsend_msg(struct nss_wifi_msg *ncm)
 {
 	struct nss_wifi_mgmtsend_msg *nwmm __maybe_unused = &ncm->msg.mgmtmsg;
-	nss_trace("%p: NSS WIFI Management Send Message:\n"
+	nss_trace("%px: NSS WIFI Management Send Message:\n"
 		"WIFI Descriptor ID: %d\n"
 		"WIFI Size of Management Data: %d\n"
-		"WIFI Management Data: %p",
+		"WIFI Management Data: %px",
 		nwmm, nwmm->desc_id,
 		nwmm->len, nwmm->array);
 }
@@ -276,7 +276,7 @@ static void nss_wifi_log_mgmtsend_msg(st
 static void nss_wifi_log_wds_peer_msg(struct nss_wifi_msg *ncm)
 {
 	struct nss_wifi_wds_peer_msg *nwmm __maybe_unused = &ncm->msg.pdevwdspeermsg;
-	nss_trace("%p: NSS WIFI WDS Peer Message:\n"
+	nss_trace("%px: NSS WIFI WDS Peer Message:\n"
 		"WIFI Dest MAC: %pM\n"
 		"WIFI Peer MAC: %pM\n",
 		nwmm, nwmm->dest_mac,
@@ -290,7 +290,7 @@ static void nss_wifi_log_wds_peer_msg(st
 static void nss_wifi_log_peer_freelist_append_msg(struct nss_wifi_msg *ncm)
 {
 	struct nss_wifi_peer_freelist_append_msg *nwpm __maybe_unused = &ncm->msg.peer_freelist_append;
-	nss_trace("%p: NSS WIFI Create/Append Freelist Message:\n"
+	nss_trace("%px: NSS WIFI Create/Append Freelist Message:\n"
 		"WIFI Starting Address of Peer Freelist Pool: %x\n"
 		"WIFI Length of freelist pool: %d\n"
 		"WIFI Number of Peers supported in freelist pool: %d\n",
@@ -305,7 +305,7 @@ static void nss_wifi_log_peer_freelist_a
 static void nss_wifi_log_rx_reorder_array_freelist_append_msg(struct nss_wifi_msg *ncm)
 {
 	struct nss_wifi_rx_reorder_array_freelist_append_msg *nwpm __maybe_unused = &ncm->msg.rx_reorder_array_freelist_append;
-	nss_trace("%p: NSS WIFI RX Reorder Array Freelist Message:\n"
+	nss_trace("%px: NSS WIFI RX Reorder Array Freelist Message:\n"
 		"WIFI Starting Address of TIDQ Freelist Pool: %x\n"
 		"WIFI Length of TIDQ freelist pool: %d\n"
 		"WIFI Number of Rx reorder array entries supported in freelist pool: %d\n",
@@ -320,7 +320,7 @@ static void nss_wifi_log_rx_reorder_arra
 static void nss_wifi_log_set_filter_msg(struct nss_wifi_msg *ncm)
 {
 	struct nss_wifi_monitor_set_filter_msg *nwfm __maybe_unused = &ncm->msg.monitor_filter_msg;
-	nss_trace("%p: NSS WIFI Set Filter Message:\n"
+	nss_trace("%px: NSS WIFI Set Filter Message:\n"
 		"WIFI Filter Type: %dn",
 		nwfm, nwfm->filter_type);
 }
@@ -332,7 +332,7 @@ static void nss_wifi_log_set_filter_msg(
 static void nss_wifi_log_peer_activity_msg(struct nss_wifi_msg *ncm)
 {
 	struct nss_wifi_bs_peer_activity *nwpm __maybe_unused = &ncm->msg.peer_activity;
-	nss_trace("%p: NSS WIFI Get Active Peer Message:\n"
+	nss_trace("%px: NSS WIFI Get Active Peer Message:\n"
 		"WIFI Number of Entries in Peer ID Array: %d\n"
 		"WIFI PEER ID: %d\n",
 		nwpm, nwpm->nentries,
@@ -346,7 +346,7 @@ static void nss_wifi_log_peer_activity_m
 static void nss_wifi_log_rx_vow_extstats_set_msg(struct nss_wifi_msg *ncm)
 {
 	struct nss_wifi_rx_vow_extstats_set_msg *nwpm __maybe_unused = &ncm->msg.vow_extstats_msg;
-	nss_trace("%p: NSS WIFI VoW Extended Statistics Set Message:\n"
+	nss_trace("%px: NSS WIFI VoW Extended Statistics Set Message:\n"
 		"WIFI VoW Extended Statistics Enable:: %d\n",
 		nwpm, nwpm->vow_extstats_en);
 }
@@ -358,7 +358,7 @@ static void nss_wifi_log_rx_vow_extstats
 static void nss_wifi_log_pktlog_cfg_msg(struct nss_wifi_msg *ncm)
 {
 	struct nss_wifi_pktlog_cfg_msg *nwpm __maybe_unused = &ncm->msg.pcm_msg;
-	nss_trace("%p: NSS WIFI Packet Log Configuration Message:\n"
+	nss_trace("%px: NSS WIFI Packet Log Configuration Message:\n"
 		"WIFI Packet Log Enable: %d\n"
 		"WIFI PAcket Log buffer Size: %d\n"
 		"WIFI Size of packet log header: %d\n"
@@ -375,7 +375,7 @@ static void nss_wifi_log_pktlog_cfg_msg(
 static void nss_wifi_log_enable_perpkt_txstats_msg(struct nss_wifi_msg *ncm)
 {
 	struct nss_wifi_enable_perpkt_txstats_msg *nwpm __maybe_unused = &ncm->msg.ept_msg;
-	nss_trace("%p: NSS WIFI Enable TX Stats Message:\n"
+	nss_trace("%px: NSS WIFI Enable TX Stats Message:\n"
 		"WIFI TX Stats Enable Flag: %d\n",
 		nwpm, nwpm->perpkt_txstats_flag);
 }
@@ -387,7 +387,7 @@ static void nss_wifi_log_enable_perpkt_t
 static void nss_wifi_log_override_tos_msg(struct nss_wifi_msg *ncm)
 {
 	struct nss_wifi_igmp_mld_override_tos_msg *nwpm __maybe_unused = &ncm->msg.wigmpmldtm_msg;
-	nss_trace("%p: NSS WIFI Override TOS Message:\n"
+	nss_trace("%px: NSS WIFI Override TOS Message:\n"
 		"WIFI enable TID override Flag: %d\n"
 		"WIFI Value of TID to be overriden: %d\n",
 		nwpm, nwpm->igmp_mld_ovride_tid_en,
@@ -401,7 +401,7 @@ static void nss_wifi_log_override_tos_ms
 static void nss_wifi_log_ol_stats_cfg_msg(struct nss_wifi_msg *ncm)
 {
 	struct nss_wifi_ol_stats_cfg_msg *nwpm __maybe_unused = &ncm->msg.scm_msg;
-	nss_trace("%p: NSS WIFI Enable/Disable Offload Stats Message:\n"
+	nss_trace("%px: NSS WIFI Enable/Disable Offload Stats Message:\n"
 		"WIFI enable/disable offload stats config: %d\n",
 		nwpm, nwpm->stats_cfg);
 }
@@ -413,7 +413,7 @@ static void nss_wifi_log_ol_stats_cfg_ms
 static void nss_wifi_log_tx_queue_cfg_msg(struct nss_wifi_msg *ncm)
 {
 	struct nss_wifi_tx_queue_cfg_msg *nwpm __maybe_unused = &ncm->msg.wtxqcm;
-	nss_trace("%p: NSS WIFI TX Queue Config Message:\n"
+	nss_trace("%px: NSS WIFI TX Queue Config Message:\n"
 		"WIFI TX Queue Size: %d\n"
 		"WIFI TX Queue Range: %d\n",
 		nwpm, nwpm->size, nwpm->range);
@@ -426,7 +426,7 @@ static void nss_wifi_log_tx_queue_cfg_ms
 static void nss_wifi_log_tx_min_threshold_cfg(struct nss_wifi_msg *ncm)
 {
 	struct nss_wifi_tx_min_threshold_cfg_msg *nwpm __maybe_unused = &ncm->msg.wtx_min_threshold_cm;
-	nss_trace("%p: NSS WIFI TX Queue Min Threshold Config Message:\n"
+	nss_trace("%px: NSS WIFI TX Queue Min Threshold Config Message:\n"
 		"WIFI TX Queue Min Threshold Value: %d\n",
 		nwpm, nwpm->min_threshold);
 }
@@ -438,7 +438,7 @@ static void nss_wifi_log_tx_min_threshol
 static void nss_wifi_log_dbdc_process_enable_msg(struct nss_wifi_msg *ncm)
 {
 	struct nss_wifi_dbdc_process_enable_msg *nwpm __maybe_unused = &ncm->msg.dbdcpe_msg;
-	nss_trace("%p: NSS WIFI DBDC repeater process configuration:\n"
+	nss_trace("%px: NSS WIFI DBDC repeater process configuration:\n"
 		"WIFI DBDC Process Enable Flag: %d\n",
 		nwpm, nwpm->dbdc_process_enable);
 }
@@ -450,7 +450,7 @@ static void nss_wifi_log_dbdc_process_en
 static void nss_wifi_log_primary_radio_set_msg(struct nss_wifi_msg *ncm)
 {
 	struct nss_wifi_primary_radio_set_msg *nwpm __maybe_unused = &ncm->msg.wprs_msg;
-	nss_trace("%p: NSS WIFI Primary Radio Set Message:\n"
+	nss_trace("%px: NSS WIFI Primary Radio Set Message:\n"
 		"WIFI Current Radio as Primary Radio Enable/Disable Flag: %d\n",
 		nwpm, nwpm->flag);
 }
@@ -462,7 +462,7 @@ static void nss_wifi_log_primary_radio_s
 static void nss_wifi_log_force_client_mcast_traffic_set_msg(struct nss_wifi_msg *ncm)
 {
 	struct nss_wifi_force_client_mcast_traffic_set_msg *nwpm __maybe_unused = &ncm->msg.wfcmts_msg;
-	nss_trace("%p: NSS WIFI Force Multicat Traffic for Radio Message:\n"
+	nss_trace("%px: NSS WIFI Force Multicat Traffic for Radio Message:\n"
 		"WIFI Radio Multicast Traffic Flag: %d\n",
 		nwpm, nwpm->flag);
 }
@@ -474,7 +474,7 @@ static void nss_wifi_log_force_client_mc
 static void nss_wifi_log_store_other_pdev_stavap_msg(struct nss_wifi_msg *ncm)
 {
 	struct nss_wifi_store_other_pdev_stavap_msg *nwpm __maybe_unused = &ncm->msg.wsops_msg;
-	nss_trace("%p: NSS WIFI Store Other Radio Station VAP Message:\n"
+	nss_trace("%px: NSS WIFI Store Other Radio Station VAP Message:\n"
 		"WIFI Station VAP Interface Number: %d\n",
 		nwpm, nwpm->stavap_ifnum);
 }
@@ -486,7 +486,7 @@ static void nss_wifi_log_store_other_pde
 static void nss_wifi_log_sta_kickout_msg(struct nss_wifi_msg *ncm)
 {
 	struct nss_wifi_sta_kickout_msg *nwpm __maybe_unused = &ncm->msg.sta_kickout_msg;
-	nss_trace("%p: NSS WIFI Station Kickout Message:\n"
+	nss_trace("%px: NSS WIFI Station Kickout Message:\n"
 		"WIFI PEER ID: %d\n",
 		nwpm, nwpm->peer_id);
 }
@@ -498,8 +498,8 @@ static void nss_wifi_log_sta_kickout_msg
 static void nss_wifi_log_wnm_peer_rx_activity(struct nss_wifi_msg *ncm)
 {
 	struct nss_wifi_wnm_peer_rx_activity_msg *nwpm __maybe_unused = &ncm->msg.wprm;
-	nss_trace("%p: NSS WIFI RX Active State Information of Peer:\n"
-		"WIFI Peer ID: %p\n"
+	nss_trace("%px: NSS WIFI RX Active State Information of Peer:\n"
+		"WIFI Peer ID: %px\n"
 		"WIFI Number of Entries: %d\n",
 		nwpm, nwpm->peer_id, nwpm->nentries);
 }
@@ -511,7 +511,7 @@ static void nss_wifi_log_wnm_peer_rx_act
 static void nss_wifi_log_wds_extn_peer_cfg_msg(struct nss_wifi_msg *ncm)
 {
 	struct nss_wifi_wds_extn_peer_cfg_msg *nwpm __maybe_unused = &ncm->msg.wpeercfg;
-	nss_trace("%p: NSS WIFI Extension Enabled Configuraion Message:\n"
+	nss_trace("%px: NSS WIFI Extension Enabled Configuraion Message:\n"
 		"WIFI Peer MAC Address: %pM\n"
 		"WIFI WDS Flags: %d\n"
 		"WIFI Peer ID: %d\n",
@@ -526,7 +526,7 @@ static void nss_wifi_log_wds_extn_peer_c
 static void nss_wifi_log_tx_capture_msg(struct nss_wifi_msg *ncm)
 {
 	struct nss_wifi_tx_capture_msg *nwpm __maybe_unused = &ncm->msg.tx_capture_msg;
-	nss_trace("%p: NSS WIFI Enable TX Capture Message:\n"
+	nss_trace("%px: NSS WIFI Enable TX Capture Message:\n"
 		"WIFI TX Capture Enable Flag: %d\n",
 		nwpm, nwpm->tx_capture_enable);
 }
@@ -538,7 +538,7 @@ static void nss_wifi_log_tx_capture_msg(
 static void nss_wifi_log_always_primary_set_msg(struct nss_wifi_msg *ncm)
 {
 	struct nss_wifi_always_primary_set_msg *nwpm __maybe_unused = &ncm->msg.waps_msg;
-	nss_trace("%p: NSS WIFI Always Set Current Radio Primary Message:\n"
+	nss_trace("%px: NSS WIFI Always Set Current Radio Primary Message:\n"
 		"WIFI Always Set Flag: %d\n",
 		nwpm, nwpm->flag);
 }
@@ -550,7 +550,7 @@ static void nss_wifi_log_always_primary_
 static void nss_wifi_log_cmd_msg(struct nss_wifi_msg *ncm)
 {
 	struct nss_wifi_cmd_msg *nwpm __maybe_unused = &ncm->msg.wcmdm;
-	nss_trace("%p: NSS WIFI PDEV Command Message:\n"
+	nss_trace("%px: NSS WIFI PDEV Command Message:\n"
 		"WIFI Type of Command: %d\n"
 		"WIFI Value of Command: %d\n",
 		nwpm, nwpm->cmd, nwpm->value);
@@ -563,7 +563,7 @@ static void nss_wifi_log_cmd_msg(struct
 static void nss_wifi_log_enable_ol_statsv2_msg(struct nss_wifi_msg *ncm)
 {
 	struct nss_wifi_enable_ol_statsv2 *nwpm __maybe_unused = &ncm->msg.wesh_msg;
-	nss_trace("%p: NSS WIFI Enable Version 2 of TX/RX Stats:\n"
+	nss_trace("%px: NSS WIFI Enable Version 2 of TX/RX Stats:\n"
 		"WIFI Enable Version 2 Stats: %d\n",
 		nwpm, nwpm->enable_ol_statsv2);
 }
@@ -577,7 +577,7 @@ static void nss_wifi_log_enable_ol_peer_
 	struct nss_wifi_ol_peer_time_msg *nwpm __maybe_unused = &ncm->msg.wopt_msg;
 	int32_t i;
 
-	nss_trace("%p: NSS WIFI Enable Per PEer Stats to Host:\n"
+	nss_trace("%px: NSS WIFI Enable Per PEer Stats to Host:\n"
 		"WIFI Number of Peers: %d\n"
 		"WIFI Peed ID: %d\n",
 		nwpm, nwpm->npeers,
@@ -750,7 +750,7 @@ static void nss_wifi_log_verbose(struct
 		break;
 
 	default:
-		nss_warning("%p: Invalid message type\n", ncm);
+		nss_warning("%px: Invalid message type\n", ncm);
 		break;
 	}
 }
@@ -762,11 +762,11 @@ static void nss_wifi_log_verbose(struct
 void nss_wifi_log_tx_msg(struct nss_wifi_msg *ncm)
 {
 	if (ncm->cm.type >= NSS_WIFI_MAX_MSG) {
-		nss_warning("%p: Invalid message type\n", ncm);
+		nss_warning("%px: Invalid message type\n", ncm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", ncm, ncm->cm.type, nss_wifi_log_message_types_str[ncm->cm.type]);
+	nss_info("%px: type[%d]:%s\n", ncm, ncm->cm.type, nss_wifi_log_message_types_str[ncm->cm.type]);
 	nss_wifi_log_verbose(ncm);
 }
 
@@ -777,26 +777,26 @@ void nss_wifi_log_tx_msg(struct nss_wifi
 void nss_wifi_log_rx_msg(struct nss_wifi_msg *ncm)
 {
 	if (ncm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", ncm);
+		nss_warning("%px: Invalid response\n", ncm);
 		return;
 	}
 
 	if (ncm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (ncm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", ncm, ncm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", ncm, ncm->cm.type,
 			nss_wifi_log_message_types_str[ncm->cm.type],
 			ncm->cm.response, nss_cmn_response_str[ncm->cm.response]);
 		goto verbose;
 	}
 
 	if (ncm->cm.error >= NSS_WIFI_EMSG_MAX) {
-		nss_warning("%p: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
+		nss_warning("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
 			ncm, ncm->cm.type, nss_wifi_log_message_types_str[ncm->cm.type],
 			ncm->cm.response, nss_cmn_response_str[ncm->cm.response],
 			ncm->cm.error);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
 		ncm, ncm->cm.type, nss_wifi_log_message_types_str[ncm->cm.type],
 		ncm->cm.response, nss_cmn_response_str[ncm->cm.response],
 		ncm->cm.error, nss_wifi_log_error_response_types_str[ncm->cm.error]);
--- a/nss_wifi_mac_db.c
+++ b/nss_wifi_mac_db.c
@@ -52,7 +52,7 @@ static void nss_wifi_mac_db_handler(stru
 	void *ctx;
 	nss_wifi_mac_db_msg_callback_t cb;
 
-	nss_info("%p: NSS->HLOS message for wifi_mac_db\n", nss_ctx);
+	nss_info("%px: NSS->HLOS message for wifi_mac_db\n", nss_ctx);
 
 	/*
 	 * The interface number shall be wifi_mac_db soc interface or wifi_mac_db radio interface
@@ -63,12 +63,12 @@ static void nss_wifi_mac_db_handler(stru
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >= NSS_WIFI_MAC_DB_MAX_MSG) {
-		nss_warning("%p: Received invalid message %d for wifi_mac_db interface", nss_ctx, ncm->type);
+		nss_warning("%px: Received invalid message %d for wifi_mac_db interface", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_wifi_mac_db_msg)) {
-		nss_warning("%p: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
@@ -89,7 +89,7 @@ static void nss_wifi_mac_db_handler(stru
 	 * Do we have a call back
 	 */
 	if (!ncm->cb) {
-		nss_info("%p: cb null for wifi_mac_db interface %d", nss_ctx, ncm->interface);
+		nss_info("%px: cb null for wifi_mac_db interface %d", nss_ctx, ncm->interface);
 		return;
 	}
 
@@ -103,7 +103,7 @@ static void nss_wifi_mac_db_handler(stru
 	 * call wifi_mac_db msg callback
 	 */
 	if (!ctx) {
-		nss_warning("%p: Event received for wifi_mac_db interface %d before registration", nss_ctx, ncm->interface);
+		nss_warning("%px: Event received for wifi_mac_db interface %d before registration", nss_ctx, ncm->interface);
 		return;
 	}
 
@@ -122,7 +122,7 @@ nss_tx_status_t nss_wifi_mac_db_tx_msg(s
 	struct nss_cmn_msg *ncm = &msg->cm;
 
 	if (ncm->type >= NSS_WIFI_MAC_DB_MAX_MSG) {
-		nss_warning("%p: wifi_mac_db message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: wifi_mac_db message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
@@ -130,7 +130,7 @@ nss_tx_status_t nss_wifi_mac_db_tx_msg(s
 	 * The interface number shall be one of the wifi_mac_db soc interfaces
 	 */
 	if ((ncm->interface != NSS_WIFI_MAC_DB_INTERFACE)) {
-		nss_warning("%p: tx request for interface that is not a wifi_mac_db: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: tx request for interface that is not a wifi_mac_db: %d", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
@@ -159,7 +159,7 @@ struct nss_ctx_instance *nss_register_wi
 	 */
 	nss_assert(if_num == NSS_WIFI_MAC_DB_INTERFACE);
 
-	nss_info("%p: nss_register_wifi_mac_db_if if_num:%d wifi_mac_db_dev:%p", nss_ctx, if_num, netdev);
+	nss_info("%px: nss_register_wifi_mac_db_if if_num:%d wifi_mac_db_dev:%px", nss_ctx, if_num, netdev);
 
 	nss_core_register_subsys_dp(nss_ctx, if_num, wifi_mac_db_callback, NULL, NULL, netdev, features);
 
--- a/nss_wifi_stats.c
+++ b/nss_wifi_stats.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2016-2017, 2019 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016-2017, 2019-2020 The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -167,7 +167,7 @@ void nss_wifi_stats_sync(struct nss_ctx_
 	uint8_t i = 0;
 
 	if (radio_id >= NSS_MAX_WIFI_RADIO_INTERFACES) {
-		nss_warning("%p: invalid interface: %d", nss_ctx, interface);
+		nss_warning("%px: invalid interface: %d", nss_ctx, interface);
 		return;
 	}
 
--- a/nss_wifi_vdev.c
+++ b/nss_wifi_vdev.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2015-2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2015-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -24,7 +24,7 @@ static void nss_wifi_vdev_handler(struct
 {
 	nss_wifi_vdev_msg_callback_t cb;
 
-	nss_info("%p: NSS->HLOS message for wifi vdev on interface:%d", nss_ctx, ncm->interface);
+	nss_info("%px: NSS->HLOS message for wifi vdev on interface:%d", nss_ctx, ncm->interface);
 
 	BUG_ON(((ncm->interface < NSS_DYNAMIC_IF_START) || (ncm->interface >= (NSS_DYNAMIC_IF_START + NSS_MAX_DYNAMIC_INTERFACES))));
 
@@ -32,12 +32,12 @@ static void nss_wifi_vdev_handler(struct
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >= NSS_WIFI_VDEV_MAX_MSG) {
-		nss_warning("%p: received invalid message %d for wifi vdev interface", nss_ctx, ncm->type);
+		nss_warning("%px: received invalid message %d for wifi vdev interface", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_wifi_vdev_msg)) {
-		nss_warning("%p: Length of message %d is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm), (int)sizeof(struct nss_wifi_vdev_msg));
+		nss_warning("%px: Length of message %d is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm), (int)sizeof(struct nss_wifi_vdev_msg));
 		return;
 	}
 
@@ -50,13 +50,13 @@ static void nss_wifi_vdev_handler(struct
 	 * callback
 	 */
 	if (!nss_ctx->subsys_dp_register[ncm->interface].ndev) {
-		nss_warning("%p: Event received wifi vdev interface %d before registration", nss_ctx, ncm->interface);
+		nss_warning("%px: Event received wifi vdev interface %d before registration", nss_ctx, ncm->interface);
 		return;
 
 	}
 
 	if (ncm->response == NSS_CMN_RESPONSE_NOTIFY) {
-		ncm->cb = (nss_ptr_t)nss_ctx->nss_top->if_rx_msg_callback[ncm->interface];
+		ncm->cb = (nss_ptr_t)nss_core_get_msg_handler(nss_ctx, ncm->interface);
 		ncm->app_data = (nss_ptr_t)nss_ctx->subsys_dp_register[ncm->interface].ndev;
 	}
 
@@ -90,7 +90,7 @@ nss_tx_status_t nss_wifi_vdev_base_tx_ms
 {
 	struct nss_cmn_msg *ncm = &msg->cm;
 
-	nss_trace("%p: Sending wifi vdev message on interface :%d", nss_ctx, ncm->interface);
+	nss_trace("%px: Sending wifi vdev message on interface :%d", nss_ctx, ncm->interface);
 
 	/*
 	 * Sanity checks on the message
@@ -100,12 +100,12 @@ nss_tx_status_t nss_wifi_vdev_base_tx_ms
 	 * The interface number shall be wifi vdev base vap
 	 */
 	 if (ncm->interface != NSS_VAP_INTERFACE) {
-		nss_warning("%p: wifi vdev base tx request not on wifi vdev vap: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: wifi vdev base tx request not on wifi vdev vap: %d", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
 	if (ncm->type >= NSS_WIFI_VDEV_MAX_MSG) {
-		nss_warning("%p: wifi vdev base message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: wifi vdev base message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
@@ -121,7 +121,7 @@ nss_tx_status_t nss_wifi_vdev_tx_msg(str
 {
 	struct nss_cmn_msg *ncm = &msg->cm;
 
-	nss_trace("%p: Sending wifi vdev message on interface :%d", nss_ctx, ncm->interface);
+	nss_trace("%px: Sending wifi vdev message on interface :%d", nss_ctx, ncm->interface);
 
 	/*
 	 * Sanity checks on the message
@@ -131,12 +131,12 @@ nss_tx_status_t nss_wifi_vdev_tx_msg(str
 	 * Interface shall be of dynamic interface type
 	 */
 	 if ((ncm->interface < NSS_DYNAMIC_IF_START) || (ncm->interface >= (NSS_DYNAMIC_IF_START + NSS_MAX_DYNAMIC_INTERFACES))) {
-		nss_warning("%p: wifi vdev tx request for invalid interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: wifi vdev tx request for invalid interface: %d", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
 	if (ncm->type >= NSS_WIFI_VDEV_MAX_MSG) {
-		nss_warning("%p: wifi vdev message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: wifi vdev message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
@@ -157,31 +157,31 @@ nss_tx_status_t nss_wifi_vdev_tx_msg_ext
 	NSS_VERIFY_CTX_MAGIC(nss_ctx);
 
 	if (unlikely(nss_ctx->state != NSS_CORE_STATE_INITIALIZED)) {
-		nss_warning("%p: wifi vdev message dropped as core not ready", nss_ctx);
+		nss_warning("%px: wifi vdev message dropped as core not ready", nss_ctx);
 		return NSS_TX_FAILURE_NOT_READY;
 	}
 
 	nm = (struct nss_wifi_vdev_msg *) os_buf->data;
 	ncm = &nm->cm;
 
-	nss_trace("%p: Sending wifi vdev message on interface :%d", nss_ctx, ncm->interface);
+	nss_trace("%px: Sending wifi vdev message on interface :%d", nss_ctx, ncm->interface);
 
 	/*
 	 * Interface shall be of dynamic interface type
 	 */
 	if ((ncm->interface < NSS_DYNAMIC_IF_START) || (ncm->interface >= (NSS_DYNAMIC_IF_START + NSS_MAX_DYNAMIC_INTERFACES))) {
-		nss_warning("%p: wifi vdev tx request for invalid interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: wifi vdev tx request for invalid interface: %d", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
 	if (ncm->type >= NSS_WIFI_VDEV_MAX_MSG) {
-		nss_warning("%p: wifi vdev message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: wifi vdev message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
 	status = nss_core_send_buffer(nss_ctx, 0, os_buf, NSS_IF_H2N_CMD_QUEUE, H2N_BUFFER_CTRL, H2N_BIT_FLAG_BUFFER_REUSABLE);
 	if (status != NSS_CORE_STATUS_SUCCESS) {
-		nss_warning("%p: Unable to enqueue 'wifi vdev message'", nss_ctx);
+		nss_warning("%px: Unable to enqueue 'wifi vdev message'", nss_ctx);
 		return NSS_TX_FAILURE;
 	}
 
@@ -215,7 +215,7 @@ nss_tx_status_t nss_wifi_vdev_set_next_h
 	struct nss_wifi_vdev_set_next_hop_msg *next_hop_msg = NULL;
 
 	if (!wifivdevmsg) {
-		nss_warning("%p: Unable to allocate next hop message", ctx);
+		nss_warning("%px: Unable to allocate next hop message", ctx);
 		return NSS_TX_FAILURE;
 	}
 
@@ -226,7 +226,7 @@ nss_tx_status_t nss_wifi_vdev_set_next_h
 
 	status = nss_wifi_vdev_tx_msg(ctx, wifivdevmsg);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: Unable to send next hop message", ctx);
+		nss_warning("%px: Unable to send next hop message", ctx);
 	}
 
 	kfree(wifivdevmsg);
@@ -244,7 +244,7 @@ nss_tx_status_t nss_wifi_vdev_base_set_n
 	struct nss_wifi_vdev_set_next_hop_msg *next_hop_msg = NULL;
 
 	if (!wifivdevmsg) {
-		nss_warning("%p: Unable to allocate next hop message", ctx);
+		nss_warning("%px: Unable to allocate next hop message", ctx);
 		return NSS_TX_FAILURE;
 	}
 
@@ -255,7 +255,7 @@ nss_tx_status_t nss_wifi_vdev_base_set_n
 
 	status = nss_wifi_vdev_base_tx_msg(ctx, wifivdevmsg);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: Unable to send next hop message", ctx);
+		nss_warning("%px: Unable to send next hop message", ctx);
 	}
 
 	kfree(wifivdevmsg);
@@ -273,7 +273,7 @@ nss_tx_status_t nss_wifi_vdev_set_peer_n
 	struct nss_wifi_vdev_set_peer_next_hop_msg *peer_next_hop_msg = NULL;
 
 	if (!wifivdevmsg) {
-		nss_warning("%p: Unable to allocate next hop message", ctx);
+		nss_warning("%px: Unable to allocate next hop message", ctx);
 		return NSS_TX_FAILURE;
 	}
 
@@ -286,7 +286,7 @@ nss_tx_status_t nss_wifi_vdev_set_peer_n
 
 	status = nss_wifi_vdev_tx_msg(ctx, wifivdevmsg);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: Unable to send peer next hop message", ctx);
+		nss_warning("%px: Unable to send peer next hop message", ctx);
 	}
 
 	kfree(wifivdevmsg);
@@ -307,7 +307,7 @@ bool nss_wifi_vdev_set_dp_type(struct ns
 	nss_assert((if_num >= NSS_DYNAMIC_IF_START) && (if_num < (NSS_DYNAMIC_IF_START + NSS_MAX_DYNAMIC_INTERFACES)));
 
 	if (unlikely(nss_ctx->state != NSS_CORE_STATE_INITIALIZED)) {
-		nss_warning("%p: Vap interface dp type could not be set as core is not initialized\n", nss_ctx);
+		nss_warning("%px: Vap interface dp type could not be set as core is not initialized\n", nss_ctx);
 		return false;
 	}
 
@@ -337,11 +337,17 @@ uint32_t nss_register_wifi_vdev_if(struc
 				struct net_device *netdev,
 				uint32_t features)
 {
+	uint32_t status;
+
 	nss_assert((if_num >= NSS_DYNAMIC_IF_START) && (if_num < (NSS_DYNAMIC_IF_START + NSS_MAX_DYNAMIC_INTERFACES)));
 
 	nss_core_register_subsys_dp(nss_ctx, if_num, vdev_data_callback, vdev_ext_data_callback, NULL, netdev, features);
 
-	nss_top_main.if_rx_msg_callback[if_num] = vdev_event_callback;
+	status = nss_core_register_msg_handler(nss_ctx, if_num, vdev_event_callback);
+	if (status != NSS_CORE_STATUS_SUCCESS) {
+		nss_warning("%px: unable to register event handler for interface(%u)", nss_ctx, if_num);
+		return status;
+	}
 
 	nss_core_register_handler(nss_ctx, if_num, nss_wifi_vdev_handler, NULL);
 
@@ -355,13 +361,18 @@ EXPORT_SYMBOL(nss_register_wifi_vdev_if)
 void nss_unregister_wifi_vdev_if(uint32_t if_num)
 {
 	struct nss_ctx_instance *nss_ctx = (struct nss_ctx_instance *)&nss_top_main.nss[nss_top_main.wifi_handler_id];
+	uint32_t status;
 
 	nss_assert(nss_ctx);
 	nss_assert((if_num >= NSS_DYNAMIC_IF_START) && (if_num < (NSS_DYNAMIC_IF_START + NSS_MAX_DYNAMIC_INTERFACES)));
 
 	nss_core_unregister_subsys_dp(nss_ctx, if_num);
 
-	nss_top_main.if_rx_msg_callback[if_num] = NULL;
+	status = nss_core_unregister_msg_handler(nss_ctx, if_num);
+	if (status != NSS_CORE_STATUS_SUCCESS) {
+		nss_warning("%px: unable to unregister event handler for interface(%u)", nss_ctx, if_num);
+		return;
+	}
 
 	nss_core_unregister_handler(nss_ctx, if_num);
 }
--- a/nss_wifili.c
+++ b/nss_wifili.c
@@ -43,7 +43,7 @@ static void nss_wifili_handler(struct ns
 	void *ctx;
 	nss_wifili_msg_callback_t cb;
 
-	nss_info("%p: NSS->HLOS message for wifili\n", nss_ctx);
+	nss_info("%px: NSS->HLOS message for wifili\n", nss_ctx);
 
 	/*
 	 * The interface number shall be wifili soc interface or wifili radio interface
@@ -62,12 +62,13 @@ static void nss_wifili_handler(struct ns
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >= NSS_WIFILI_MAX_MSG) {
-		nss_warning("%p: Received invalid message %d for wifili interface", nss_ctx, ncm->type);
+		nss_warning("%px: Received invalid message %d for wifili interface", nss_ctx, ncm->type);
 		return;
 	}
 
-	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_wifili_msg)) {
-		nss_warning("%p: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+	if ((nss_cmn_get_msg_len(ncm) > sizeof(struct nss_wifili_msg)) &&
+		ntm->cm.type != NSS_WIFILI_PEER_EXT_STATS_MSG) {
+		nss_warning("%px: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
@@ -101,7 +102,7 @@ static void nss_wifili_handler(struct ns
 	 * Do we have a call back
 	 */
 	if (!ncm->cb) {
-		nss_info("%p: cb null for wifili interface %d", nss_ctx, ncm->interface);
+		nss_info("%px: cb null for wifili interface %d", nss_ctx, ncm->interface);
 		return;
 	}
 
@@ -115,7 +116,7 @@ static void nss_wifili_handler(struct ns
 	 * call wifili msg callback
 	 */
 	if (!ctx) {
-		nss_warning("%p: Event received for wifili interface %d before registration", nss_ctx, ncm->interface);
+		nss_warning("%px: Event received for wifili interface %d before registration", nss_ctx, ncm->interface);
 		return;
 	}
 
@@ -163,7 +164,7 @@ nss_tx_status_t nss_wifili_tx_msg(struct
 	nss_wifili_log_tx_msg(msg);
 
 	if (ncm->type >= NSS_WIFILI_MAX_MSG) {
-		nss_warning("%p: wifili message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%px: wifili message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
@@ -173,7 +174,7 @@ nss_tx_status_t nss_wifili_tx_msg(struct
 	if ((ncm->interface != NSS_WIFILI_INTERNAL_INTERFACE)
 		&& (ncm->interface != NSS_WIFILI_EXTERNAL_INTERFACE0)
 		&& (ncm->interface != NSS_WIFILI_EXTERNAL_INTERFACE1)) {
-		nss_warning("%p: tx request for interface that is not a wifili: %d", nss_ctx, ncm->interface);
+		nss_warning("%px: tx request for interface that is not a wifili: %d", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
@@ -199,14 +200,14 @@ nss_tx_status_t nss_wifili_tx_msg_sync(s
 
 	status = nss_wifili_tx_msg(nss_ctx, nvm);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%p: wifili_tx_msg failed\n", nss_ctx);
+		nss_warning("%px: wifili_tx_msg failed\n", nss_ctx);
 		up(&wifili_pvt.sem);
 		return status;
 	}
 
 	ret = wait_for_completion_timeout(&wifili_pvt.complete, msecs_to_jiffies(NSS_WIFILI_TX_TIMEOUT));
 	if (!ret) {
-		nss_warning("%p: wifili msg tx failed due to timeout\n", nss_ctx);
+		nss_warning("%px: wifili msg tx failed due to timeout\n", nss_ctx);
 		wifili_pvt.response = NSS_TX_FAILURE;
 	}
 
@@ -244,7 +245,7 @@ uint32_t nss_get_available_wifili_extern
 		return NSS_WIFILI_EXTERNAL_INTERFACE1;
 	}
 
-	nss_warning("%p: No available external intefaces\n", nss_ctx);
+	nss_warning("%px: No available external intefaces\n", nss_ctx);
 
 	return NSS_MAX_NET_INTERFACES;
 }
@@ -283,7 +284,7 @@ struct nss_ctx_instance *nss_register_wi
 			|| (if_num == NSS_WIFILI_EXTERNAL_INTERFACE0)
 			|| (if_num == NSS_WIFILI_EXTERNAL_INTERFACE1));
 
-	nss_info("nss_register_wifili_if if_num %d wifictx %p", if_num, netdev);
+	nss_info("nss_register_wifili_if if_num %d wifictx %px", if_num, netdev);
 
 	nss_core_register_subsys_dp(nss_ctx, if_num, wifili_callback, wifili_ext_callback, NULL, netdev, features);
 
@@ -326,7 +327,7 @@ struct nss_ctx_instance *nss_register_wi
 	 * The interface number shall be wifili radio dynamic interface
 	 */
 	nss_assert(nss_is_dynamic_interface(if_num));
-	nss_info("nss_register_wifili_if if_num %d wifictx %p", if_num, netdev);
+	nss_info("nss_register_wifili_if if_num %d wifictx %px", if_num, netdev);
 
 	nss_core_register_subsys_dp(nss_ctx, if_num, wifili_callback, wifili_ext_callback, NULL, netdev, features);
 
--- a/nss_wifili_log.c
+++ b/nss_wifili_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -157,7 +157,7 @@ static void nss_wifili_log_init_msg(stru
 {
 	struct nss_wifili_init_msg *nwim __maybe_unused = &nwm->msg.init;
 	int32_t i;
-	nss_trace("%p: NSS WIFILI Init Message:\n"
+	nss_trace("%px: NSS WIFILI Init Message:\n"
 		"WIFILI HAL Source Ring Base Address: %x\n"
 		"WIFILI HAL Source Ring Shadow Read Pointer Address: %x\n"
 		"WIFILI HAL Source Ring Shadow Write Pointer Address: %x\n"
@@ -210,7 +210,7 @@ static void nss_wifili_log_init_msg(stru
 static void nss_wifili_log_pdev_init_msg(struct nss_wifili_msg *nwm)
 {
 	struct nss_wifili_pdev_init_msg *nwim __maybe_unused = &nwm->msg.pdevmsg;
-	nss_trace("%p: NSS WIFILI PDEV Init Message:\n"
+	nss_trace("%px: NSS WIFILI PDEV Init Message:\n"
 		"WIFILI Radio ID: %x\n"
 		"WIFILI MAC Hardware Mode: %d\n"
 		"WIFILI Lower MAC ID: %x\n",
@@ -230,7 +230,7 @@ static void nss_wifili_log_pdev_init_msg
 static void nss_wifili_log_pdev_deinit_msg(struct nss_wifili_msg *nwm)
 {
 	struct nss_wifili_pdev_deinit_msg *nwim __maybe_unused = &nwm->msg.pdevdeinit;
-	nss_trace("%p: NSS WIFILI PDEV Deinit Message:\n"
+	nss_trace("%px: NSS WIFILI PDEV Deinit Message:\n"
 		"WIFILI Interface Number: %d\n",
 		nwim, nwim->ifnum);
 }
@@ -242,7 +242,7 @@ static void nss_wifili_log_pdev_deinit_m
 static void nss_wifili_log_peer_msg(struct nss_wifili_msg *nwm)
 {
 	struct nss_wifili_peer_msg *nwim __maybe_unused = &nwm->msg.peermsg;
-	nss_trace("%p: NSS WIFILI Peer Message:\n"
+	nss_trace("%px: NSS WIFILI Peer Message:\n"
 		"WIFILI Peer MAC Address: %pM\n"
 		"WIFILI VAP ID: %d\n"
 		"WIFILI Peed ID: %d\n"
@@ -262,7 +262,7 @@ static void nss_wifili_log_peer_msg(stru
 static void nss_wifili_log_peer_freelist_append_msg(struct nss_wifili_msg *nwm)
 {
 	struct nss_wifili_peer_freelist_append_msg *nwim __maybe_unused = &nwm->msg.peer_freelist_append;
-	nss_trace("%p: NSS WIFILI Peer Memory Request Message:\n"
+	nss_trace("%px: NSS WIFILI Peer Memory Request Message:\n"
 		"WIFILI Starting Address of Freelist: %x\n"
 		"WIFILI Length: %d\n"
 		"WIFILI Maximum number of peer entries supported in pool: %d\n",
@@ -277,7 +277,7 @@ static void nss_wifili_log_peer_freelist
 static void nss_wifili_log_wds_peer_msg(struct nss_wifili_msg *nwm)
 {
 	struct nss_wifili_wds_peer_msg *nwim __maybe_unused = &nwm->msg.wdspeermsg;
-	nss_trace("%p: NSS WIFILI WDS Peer Message:\n"
+	nss_trace("%px: NSS WIFILI WDS Peer Message:\n"
 		"WIFILI Destination MAC: %pM\n"
 		"WIFILI Peer MAC: %pM\n",
 		nwim, nwim->dest_mac, nwim->peer_mac);
@@ -290,7 +290,7 @@ static void nss_wifili_log_wds_peer_msg(
 static void nss_wifili_log_wds_active_info_msg(struct nss_wifili_msg *nwm)
 {
 	struct nss_wifili_wds_active_info_msg *nwim __maybe_unused = &nwm->msg.wdsinfomsg;
-	nss_trace("%p: NSS WIFILI WDS Active Info Message:\n"
+	nss_trace("%px: NSS WIFILI WDS Active Info Message:\n"
 		"WIFILI Number OF Entries: %d\n"
 		"WIFILI Hardware AST Index: %d\n",
 		nwim, nwim->nentries, nwim->info[0].ast_idx);
@@ -303,7 +303,7 @@ static void nss_wifili_log_wds_active_in
 static void nss_wifili_log_stats_cfg_msg(struct nss_wifili_msg *nwm)
 {
 	struct nss_wifili_stats_cfg_msg *nwim __maybe_unused = &nwm->msg.scm;
-	nss_trace("%p: NSS WIFILI Stats Config Message:\n"
+	nss_trace("%px: NSS WIFILI Stats Config Message:\n"
 		"WIFILI Enable/Disable Config: %d\n",
 		nwim, nwim->cfg);
 }
@@ -315,7 +315,7 @@ static void nss_wifili_log_stats_cfg_msg
 static void nss_wifili_log_reo_tidq_msg(struct nss_wifili_msg *nwm)
 {
 	struct nss_wifili_reo_tidq_msg *nwim __maybe_unused = &nwm->msg.reotidqmsg;
-	nss_trace("%p: NSS WIFILI reo tidq setup Message:\n"
+	nss_trace("%px: NSS WIFILI reo tidq setup Message:\n"
 		"WIFILI Traffic Identification Value: %d\n"
 		"WIFILI Peer ID: %d\n",
 		nwim, nwim->tid, nwim->peer_id);
@@ -328,7 +328,7 @@ static void nss_wifili_log_reo_tidq_msg(
 static void nss_wifili_log_radio_cfg_msg(struct nss_wifili_msg *nwm)
 {
 	struct nss_wifili_radio_cfg_msg *nwim __maybe_unused = &nwm->msg.radiocfgmsg;
-	nss_trace("%p: NSS WIFILI Radio Command Message:\n"
+	nss_trace("%px: NSS WIFILI Radio Command Message:\n"
 		"WIFILI Radio Interface Number %d\n",
 		nwim, nwim->radio_if_num);
 }
@@ -340,7 +340,7 @@ static void nss_wifili_log_radio_cfg_msg
 static void nss_wifili_log_wds_extn_peer_cfg_msg(struct nss_wifili_msg *nwm)
 {
 	struct nss_wifili_wds_extn_peer_cfg_msg *nwim __maybe_unused = &nwm->msg.wpeercfg;
-	nss_trace("%p: NSS WIFILI WDS vendor extension configuration message:\n"
+	nss_trace("%px: NSS WIFILI WDS vendor extension configuration message:\n"
 		"WIFILI Peer MAC Addr: %pM\n"
 		"WIFILI WDS Flags: %d\n"
 		"WIFILI Peer ID: %d\n",
@@ -355,7 +355,7 @@ static void nss_wifili_log_wds_extn_peer
 static void nss_wifili_log_soc_linkdesc_buf_info_msg(struct nss_wifili_msg *nwm)
 {
 	struct nss_wifili_soc_linkdesc_buf_info_msg *nwim __maybe_unused = &nwm->msg.linkdescinfomsg;
-	nss_trace("%p: NSS WIFILI Link descriptor buffer address information:\n"
+	nss_trace("%px: NSS WIFILI Link descriptor buffer address information:\n"
 		"WIFILI Link Descriptor Low Address: %x\n"
 		"WIFILI Link Descriptor High Address: %x\n",
 		nwim, nwim->buffer_addr_low,
@@ -370,7 +370,7 @@ static void nss_wifili_log_peer_security
 {
 	struct nss_wifili_peer_security_type_msg *nwim __maybe_unused = &nwm->msg.securitymsg;
 	int32_t i;
-	nss_trace("%p: NSS WIFILI Peer Security Message:\n"
+	nss_trace("%px: NSS WIFILI Peer Security Message:\n"
 		"WIFILI Peer ID: %d\n"
 		"WIFILI Packet Type: %d\n"
 		"WIFILI Security Type: %d\n",
@@ -392,7 +392,7 @@ static void nss_wifili_log_peer_security
 static void nss_wifili_log_peer_nawds_enable_msg(struct nss_wifili_msg *nwm)
 {
 	struct nss_wifili_peer_nawds_enable_msg *nwim __maybe_unused = &nwm->msg.nawdsmsg;
-	nss_trace("%p: NSS WIFILI NAWDS enable for peer:\n"
+	nss_trace("%px: NSS WIFILI NAWDS enable for peer:\n"
 		"WIFILI Peer ID: %d\n"
 		"WIFILI Enable NAWDS: %d\n",
 		nwim, nwim->peer_id, nwim->is_nawds);
@@ -405,7 +405,7 @@ static void nss_wifili_log_peer_nawds_en
 static void nss_wifili_log_dbdc_repeater_set_msg(struct nss_wifili_msg *nwm)
 {
 	struct nss_wifili_dbdc_repeater_set_msg *nwim __maybe_unused = &nwm->msg.dbdcrptrmsg;
-	nss_trace("%p: NSS WIFILI DBDC Repeater Enable Message:\n"
+	nss_trace("%px: NSS WIFILI DBDC Repeater Enable Message:\n"
 		"WIFILI DBDC Enable Flag: %d\n",
 		nwim, nwim->is_dbdc_en);
 }
@@ -497,7 +497,7 @@ static void nss_wifili_log_verbose(struc
 		break;
 
 	default:
-		nss_warning("%p: Invalid message type\n", nwm);
+		nss_warning("%px: Invalid message type\n", nwm);
 		break;
 	}
 }
@@ -509,11 +509,11 @@ static void nss_wifili_log_verbose(struc
 void nss_wifili_log_tx_msg(struct nss_wifili_msg *nwm)
 {
 	if (nwm->cm.type >= NSS_WIFILI_MAX_MSG) {
-		nss_warning("%p: Invalid message type\n", nwm);
+		nss_warning("%px: Invalid message type\n", nwm);
 		return;
 	}
 
-	nss_info("%p: type[%d]:%s\n", nwm, nwm->cm.type, nss_wifili_log_message_types_str[nwm->cm.type]);
+	nss_info("%px: type[%d]:%s\n", nwm, nwm->cm.type, nss_wifili_log_message_types_str[nwm->cm.type]);
 	nss_wifili_log_verbose(nwm);
 }
 
@@ -524,26 +524,26 @@ void nss_wifili_log_tx_msg(struct nss_wi
 void nss_wifili_log_rx_msg(struct nss_wifili_msg *nwm)
 {
 	if (nwm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%p: Invalid response\n", nwm);
+		nss_warning("%px: Invalid response\n", nwm);
 		return;
 	}
 
 	if (nwm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (nwm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%p: type[%d]:%s, response[%d]:%s\n", nwm, nwm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", nwm, nwm->cm.type,
 			nss_wifili_log_message_types_str[nwm->cm.type],
 			nwm->cm.response, nss_cmn_response_str[nwm->cm.response]);
 		goto verbose;
 	}
 
 	if (nwm->cm.error >= NSS_WIFILI_EMSG_UNKNOWN) {
-		nss_warning("%p: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
+		nss_warning("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
 			nwm, nwm->cm.type, nss_wifili_log_message_types_str[nwm->cm.type],
 			nwm->cm.response, nss_cmn_response_str[nwm->cm.response],
 			nwm->cm.error);
 		goto verbose;
 	}
 
-	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
 		nwm, nwm->cm.type, nss_wifili_log_message_types_str[nwm->cm.type],
 		nwm->cm.response, nss_cmn_response_str[nwm->cm.response],
 		nwm->cm.error, nss_wifili_log_error_response_types_str[nwm->cm.error]);
--- a/nss_wifili_stats.c
+++ b/nss_wifili_stats.c
@@ -259,7 +259,7 @@ void nss_wifili_stats_sync(struct nss_ct
 		break;
 
 	default:
-		nss_warning("%p: Invalid wifili interface\n", nss_ctx);
+		nss_warning("%px: Invalid wifili interface\n", nss_ctx);
 		return;
 	}
 
@@ -436,6 +436,7 @@ void nss_wifili_stats_sync(struct nss_ct
 	/*
 	 * update wbm ring stats
 	 */
+	stats->stats_wbm[NSS_WIFILI_STATS_WBM_IE_LOCAL_ALLOC_FAIL] += devstats->rxwbm_stats.invalid_buf_mgr;
 	stats->stats_wbm[NSS_WIFILI_STATS_WBM_SRC_DMA] += devstats->rxwbm_stats.err_src_rxdma;
 	stats->stats_wbm[NSS_WIFILI_STATS_WBM_SRC_DMA_CODE_INV] += devstats->rxwbm_stats.err_src_rxdma_code_inv;
 	stats->stats_wbm[NSS_WIFILI_STATS_WBM_SRC_REO] += devstats->rxwbm_stats.err_src_reo;
@@ -459,7 +460,7 @@ void nss_wifili_stats_notify(struct nss_
 
 	wifili_stats = kzalloc(sizeof(struct nss_wifili_stats_notification), GFP_KERNEL);
 	if (!wifili_stats) {
-		nss_warning("%p: Failed to allocate memory for wifili stats\n", nss_ctx);
+		nss_warning("%px: Failed to allocate memory for wifili stats\n", nss_ctx);
 		return;
 	}
 
@@ -478,7 +479,7 @@ void nss_wifili_stats_notify(struct nss_
 		break;
 
 	default:
-		nss_warning("%p: Invalid wifili interface\n", nss_ctx);
+		nss_warning("%px: Invalid wifili interface\n", nss_ctx);
 		goto done;
 	}
 	wifili_stats->if_num = if_num;
--- a/nss_wifili_strings.c
+++ b/nss_wifili_strings.c
@@ -138,6 +138,7 @@ struct nss_stats_info nss_wifili_strings
  *	wifili wbm ring stats
  */
 struct nss_stats_info nss_wifili_strings_stats_wbm[NSS_WIFILI_STATS_WBM_MAX] = {
+	{"wbm_ie_local_alloc_fail"	, NSS_STATS_TYPE_ERROR},
 	{"wbm_src_dma"			, NSS_STATS_TYPE_SPECIAL},
 	{"wbm_src_dma_code_inv"		, NSS_STATS_TYPE_SPECIAL},
 	{"wbm_src_reo"			, NSS_STATS_TYPE_SPECIAL},
--- a/exports/nss_cmn.h
+++ b/exports/nss_cmn.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014, 2016-2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014, 2016-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -27,6 +27,11 @@
  * @{
  */
 
+/*
+ * Interface Number 1 Valid 7 Core 8 Type 16 Index
+ */
+typedef int32_t nss_if_num_t;
+
 /**
  * @struct nss_ctx_instance
  *	Forward declaration for structure that contains instance data for each
