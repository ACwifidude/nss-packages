--- a/ecm_db/ecm_db.c
+++ b/ecm_db/ecm_db.c
@@ -242,166 +242,14 @@ static int ecm_db_ipv6_route_table_updat
 					       unsigned long event,
 					       void *ptr)
 {
-	struct fib6_config *cfg = (struct fib6_config *)ptr;
-	struct ecm_db_connection_instance *ci;
-
 	DEBUG_TRACE("route table update event v6\n");
 
-	if ((event != RTM_DELROUTE) && (event != RTM_NEWROUTE)) {
-		DEBUG_WARN("%px: Unhandled route table event: %lu\n", cfg, event);
-		return NOTIFY_DONE;
-	}
-
-	/*
-	 * If a default route is changed, fc_dst address is set to all zeros.
-	 * In this case, we should defunct all the IPv6 flows.
-	 */
-	if (ipv6_addr_any(&cfg->fc_dst)) {
-		DEBUG_TRACE("%px fc_dst (%pI6), default route is changed, defunct all IPv6 connections\n",
-			    cfg, &cfg->fc_dst);
-		ecm_db_connection_defunct_ip_version(6);
-		return NOTIFY_DONE;
-	}
-
 	/*
 	 * Disable IPv6 frontend processing until defunct function call is completed.
 	 */
 	ecm_front_end_ipv6_stop(1);
 
-	/*
-	 * Iterate all connections
-	 */
-	ci = ecm_db_connections_get_and_ref_first();
-	while (ci) {
-		struct ecm_db_connection_instance *cin;
-		struct in6_addr prefix_addr;
-		struct in6_addr ecm_in6;
-		ip_addr_t ecm_addr;
-		struct ecm_db_iface_instance *interfaces[ECM_DB_IFACE_HEIRARCHY_MAX];
-		int32_t if_first;
-		struct net_device *ecm_dev;
-		struct net_device *fc_dev;
-		bool is_dest_ip_match = true;
-		ecm_db_obj_dir_t obj_dir = ECM_DB_OBJ_DIR_TO;
-
-		if (ci->ip_version != 6) {
-			goto next;
-		}
-
-		/*
-		 * Get the ECM connection's destination IPv6 address.
-		 */
-		ecm_db_connection_address_get(ci, ECM_DB_OBJ_DIR_TO, ecm_addr);
-		ECM_IP_ADDR_TO_NIN6_ADDR(ecm_in6, ecm_addr);
-
-		/*
-		 * Compute ECM connection's prefix destination address by masking it with the
-		 * route config's destination address prefix length.
-		 */
-		ipv6_addr_prefix(&prefix_addr, &ecm_in6, cfg->fc_dst_len);
-
-		DEBUG_TRACE("dest addr prefix: %pI6 prefix_len: %d ecm_in6: %pI6\n", &prefix_addr, cfg->fc_dst_len, &ecm_in6);
-
-		/*
-		 * Compare the ECM connection's destination address prefix with the route config's
-		 * destination address. If they are not equal, try with the ECM's source address prefix.
-		 * Because ECM can create the connection in the reply direction, and in this case, ECM
-		 * connection's source prefix IP address will match with the route config's dst IP address.
-		 *
-		 * If none of them match with the route config's destination address, this means that
-		 * this connection is not related to this route change event.
-		 * We should check with the next connection.
-		 */
-		if (ipv6_addr_cmp(&prefix_addr, &cfg->fc_dst)) {
-			DEBUG_TRACE("dest addr prefix: %pI6 not equal to cfg->fc_dst: %pI6, go to next connection\n", &prefix_addr, &cfg->fc_dst);
-
-			/*
-			 * ECM's destination address didn't match.
-			 * Get the ECM connection's source IPv6 address.
-			 */
-			ecm_db_connection_address_get(ci, ECM_DB_OBJ_DIR_FROM, ecm_addr);
-			ECM_IP_ADDR_TO_NIN6_ADDR(ecm_in6, ecm_addr);
-
-			/*
-			 * Compute ECM connection's prefix source address by masking it with the
-			 * route config's destination address prefix length.
-			 */
-			ipv6_addr_prefix(&prefix_addr, &ecm_in6, cfg->fc_dst_len);
-
-			DEBUG_TRACE("src addr prefix: %pI6 prefix_len: %d ecm_in6: %pI6\n", &prefix_addr, cfg->fc_dst_len, &ecm_in6);
-
-			if (ipv6_addr_cmp(&prefix_addr, &cfg->fc_dst)) {
-				DEBUG_TRACE("src addr prefix: %pI6 not equal to cfg->fc_dst: %pI6, go to next connection\n", &prefix_addr, &cfg->fc_dst);
-				goto next;
-			}
-
-			is_dest_ip_match = false;
-			obj_dir = ECM_DB_OBJ_DIR_FROM;
-		}
-
-		DEBUG_TRACE("%px: ECM connection's %s address prefix: %pI6 equals to cfg->fc_dst: %pI6\n",
-			    ci, is_dest_ip_match?"dest":"src", &prefix_addr, &cfg->fc_dst);
-
-		/*
-		 * If the event is a route delete event, comparing only the IP address is enough
-		 * to defunct the connection.
-		 */
-		if (event == RTM_DELROUTE) {
-			DEBUG_TRACE("%px: Route DELETE event, defunct the connection\n", ci);
-			ecm_db_connection_make_defunct(ci);
-			goto next;
-		}
-
-		DEBUG_TRACE("%px: Route ADD event\n", ci);
-
-		/*
-		 * If there is a route for this connection's source or destination IP address, we should
-		 * compare the devices as well, because the IP address could remain the same, but
-		 * the output device could be changed. So, the flows should take the new out device
-		 * for their route.
-		 */
-		if_first = ecm_db_connection_interfaces_get_and_ref(ci, interfaces, obj_dir);
-		if (if_first == ECM_DB_IFACE_HEIRARCHY_MAX) {
-			DEBUG_WARN("%px: Failed to get %s interfaces list\n",
-					ci, ecm_db_obj_dir_strings[obj_dir]);
-			goto next;
-		}
-
-		/*
-		 * Inner most interface has the IP address, so we should get that interface.
-		 */
-		ecm_dev = dev_get_by_index(&init_net,
-				  ecm_db_iface_interface_identifier_get(interfaces[ECM_DB_IFACE_HEIRARCHY_MAX - 1]));
-		if (!ecm_dev) {
-			DEBUG_WARN("%px: unable to find ecm netdevice\n", ci);
-			ecm_db_connection_interfaces_deref(interfaces, if_first);
-			goto next;
-		}
-		ecm_db_connection_interfaces_deref(interfaces, if_first);
-
-		fc_dev = dev_get_by_index(&init_net, cfg->fc_ifindex);
-		if (!fc_dev) {
-			DEBUG_WARN("%px: unable to find fib6_config netdevice\n", ci);
-			dev_put(ecm_dev);
-			goto next;
-		}
-
-		/*
-		 * Compare the ECM connection's netdevice with the route change config's netdevice.
-		 * If they are different, this means the new route effected the connection. So, defunct it.
-		 */
-		if (ecm_dev != fc_dev) {
-			DEBUG_TRACE("%px: fib6_config dev: %s is different from ecm dev: %s, defunct the connection\n",
-				    ci, fc_dev->name, ecm_dev->name);
-			ecm_db_connection_make_defunct(ci);
-		}
-		dev_put(fc_dev);
-		dev_put(ecm_dev);
-next:
-		cin = ecm_db_connection_get_and_ref_next(ci);
-		ecm_db_connection_deref(ci);
-		ci = cin;
-	}
+	ecm_db_connection_defunct_ip_version(6);
 
 	/*
 	 * Re-enable IPv6 frontend processing.
